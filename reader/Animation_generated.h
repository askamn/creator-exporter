// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ANIMATION_CREATOR_BUFFERS_H_
#define FLATBUFFERS_GENERATED_ANIMATION_CREATOR_BUFFERS_H_

#include "flatbuffers/flatbuffers.h"

#include "Types_generated.h"

namespace creator {
namespace buffers {

struct AnimationClip;

struct AnimCurveData;

struct AnimProps;

struct AnimEvents;

struct AnimPropActive;

struct AnimPropRotation;

struct AnimPropPosition;

struct AnimPropPositionX;

struct AnimPropPositionY;

struct AnimPropScaleX;

struct AnimPropScaleY;

struct AnimPropWidth;

struct AnimPropHeight;

struct AnimPropColor;

struct AnimPropOpacity;

struct AnimPropAnchorX;

struct AnimPropAnchorY;

struct AnimPropSkewX;

struct AnimPropSkewY;

struct AnimPropSpriteFrame;

enum AnimWrapMode {
  AnimWrapMode_Default = 0,
  AnimWrapMode_Normal = 1,
  AnimWrapMode_Loop = 2,
  AnimWrapMode_PingPong = 22,
  AnimWrapMode_Reverse = 36,
  AnimWrapMode_LoopReverse = 38,
  AnimWrapMode_PingPongReverse = 54,
  AnimWrapMode_MIN = AnimWrapMode_Default,
  AnimWrapMode_MAX = AnimWrapMode_PingPongReverse
};

inline const AnimWrapMode (&EnumValuesAnimWrapMode())[7] {
  static const AnimWrapMode values[] = {
    AnimWrapMode_Default,
    AnimWrapMode_Normal,
    AnimWrapMode_Loop,
    AnimWrapMode_PingPong,
    AnimWrapMode_Reverse,
    AnimWrapMode_LoopReverse,
    AnimWrapMode_PingPongReverse
  };
  return values;
}

inline const char *EnumNameAnimWrapMode(AnimWrapMode e) {
  switch (e) {
    case AnimWrapMode_Default: return "Default";
    case AnimWrapMode_Normal: return "Normal";
    case AnimWrapMode_Loop: return "Loop";
    case AnimWrapMode_PingPong: return "PingPong";
    case AnimWrapMode_Reverse: return "Reverse";
    case AnimWrapMode_LoopReverse: return "LoopReverse";
    case AnimWrapMode_PingPongReverse: return "PingPongReverse";
    default: return "";
  }
}

struct AnimationClip FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_DURATION = 6,
    VT_SAMPLE = 8,
    VT_SPEED = 10,
    VT_WRAPMODE = 12,
    VT_CURVEDATA = 14,
    VT_EVENTS = 16
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  float duration() const {
    return GetField<float>(VT_DURATION, 0.0f);
  }
  float sample() const {
    return GetField<float>(VT_SAMPLE, 0.0f);
  }
  float speed() const {
    return GetField<float>(VT_SPEED, 0.0f);
  }
  AnimWrapMode wrapMode() const {
    return static_cast<AnimWrapMode>(GetField<int8_t>(VT_WRAPMODE, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<AnimCurveData>> *curveData() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimCurveData>> *>(VT_CURVEDATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AnimEvents>> *events() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimEvents>> *>(VT_EVENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<float>(verifier, VT_DURATION) &&
           VerifyField<float>(verifier, VT_SAMPLE) &&
           VerifyField<float>(verifier, VT_SPEED) &&
           VerifyField<int8_t>(verifier, VT_WRAPMODE) &&
           VerifyOffset(verifier, VT_CURVEDATA) &&
           verifier.VerifyVector(curveData()) &&
           verifier.VerifyVectorOfTables(curveData()) &&
           VerifyOffset(verifier, VT_EVENTS) &&
           verifier.VerifyVector(events()) &&
           verifier.VerifyVectorOfTables(events()) &&
           verifier.EndTable();
  }
};

struct AnimationClipBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(AnimationClip::VT_NAME, name);
  }
  void add_duration(float duration) {
    fbb_.AddElement<float>(AnimationClip::VT_DURATION, duration, 0.0f);
  }
  void add_sample(float sample) {
    fbb_.AddElement<float>(AnimationClip::VT_SAMPLE, sample, 0.0f);
  }
  void add_speed(float speed) {
    fbb_.AddElement<float>(AnimationClip::VT_SPEED, speed, 0.0f);
  }
  void add_wrapMode(AnimWrapMode wrapMode) {
    fbb_.AddElement<int8_t>(AnimationClip::VT_WRAPMODE, static_cast<int8_t>(wrapMode), 0);
  }
  void add_curveData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimCurveData>>> curveData) {
    fbb_.AddOffset(AnimationClip::VT_CURVEDATA, curveData);
  }
  void add_events(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimEvents>>> events) {
    fbb_.AddOffset(AnimationClip::VT_EVENTS, events);
  }
  explicit AnimationClipBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimationClipBuilder &operator=(const AnimationClipBuilder &);
  flatbuffers::Offset<AnimationClip> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimationClip>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimationClip> CreateAnimationClip(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    float duration = 0.0f,
    float sample = 0.0f,
    float speed = 0.0f,
    AnimWrapMode wrapMode = AnimWrapMode_Default,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimCurveData>>> curveData = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimEvents>>> events = 0) {
  AnimationClipBuilder builder_(_fbb);
  builder_.add_events(events);
  builder_.add_curveData(curveData);
  builder_.add_speed(speed);
  builder_.add_sample(sample);
  builder_.add_duration(duration);
  builder_.add_name(name);
  builder_.add_wrapMode(wrapMode);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimationClip> CreateAnimationClipDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    float duration = 0.0f,
    float sample = 0.0f,
    float speed = 0.0f,
    AnimWrapMode wrapMode = AnimWrapMode_Default,
    const std::vector<flatbuffers::Offset<AnimCurveData>> *curveData = nullptr,
    const std::vector<flatbuffers::Offset<AnimEvents>> *events = nullptr) {
  return creator::buffers::CreateAnimationClip(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      duration,
      sample,
      speed,
      wrapMode,
      curveData ? _fbb.CreateVector<flatbuffers::Offset<AnimCurveData>>(*curveData) : 0,
      events ? _fbb.CreateVector<flatbuffers::Offset<AnimEvents>>(*events) : 0);
}

struct AnimCurveData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PATH = 4,
    VT_PROPS = 6
  };
  const flatbuffers::String *path() const {
    return GetPointer<const flatbuffers::String *>(VT_PATH);
  }
  const AnimProps *props() const {
    return GetPointer<const AnimProps *>(VT_PROPS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyString(path()) &&
           VerifyOffset(verifier, VT_PROPS) &&
           verifier.VerifyTable(props()) &&
           verifier.EndTable();
  }
};

struct AnimCurveDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_path(flatbuffers::Offset<flatbuffers::String> path) {
    fbb_.AddOffset(AnimCurveData::VT_PATH, path);
  }
  void add_props(flatbuffers::Offset<AnimProps> props) {
    fbb_.AddOffset(AnimCurveData::VT_PROPS, props);
  }
  explicit AnimCurveDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimCurveDataBuilder &operator=(const AnimCurveDataBuilder &);
  flatbuffers::Offset<AnimCurveData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimCurveData>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimCurveData> CreateAnimCurveData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> path = 0,
    flatbuffers::Offset<AnimProps> props = 0) {
  AnimCurveDataBuilder builder_(_fbb);
  builder_.add_props(props);
  builder_.add_path(path);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimCurveData> CreateAnimCurveDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *path = nullptr,
    flatbuffers::Offset<AnimProps> props = 0) {
  return creator::buffers::CreateAnimCurveData(
      _fbb,
      path ? _fbb.CreateString(path) : 0,
      props);
}

struct AnimProps FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ROTATION = 4,
    VT_POSITION = 6,
    VT_POSITIONX = 8,
    VT_POSITIONY = 10,
    VT_ANCHORX = 12,
    VT_ANCHORY = 14,
    VT_COLOR = 16,
    VT_OPACITY = 18,
    VT_WIDTH = 20,
    VT_HEIGHT = 22,
    VT_SCALEX = 24,
    VT_SCALEY = 26,
    VT_SKEWX = 28,
    VT_SKEWY = 30,
    VT_ACTIVE = 32,
    VT_SPRITEFRAME = 34
  };
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropRotation>> *rotation() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropRotation>> *>(VT_ROTATION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropPosition>> *position() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropPosition>> *>(VT_POSITION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropPositionX>> *positionX() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropPositionX>> *>(VT_POSITIONX);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropPositionY>> *positionY() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropPositionY>> *>(VT_POSITIONY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropAnchorX>> *anchorX() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropAnchorX>> *>(VT_ANCHORX);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropAnchorY>> *anchorY() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropAnchorY>> *>(VT_ANCHORY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropColor>> *color() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropColor>> *>(VT_COLOR);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropOpacity>> *opacity() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropOpacity>> *>(VT_OPACITY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropWidth>> *width() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropWidth>> *>(VT_WIDTH);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropHeight>> *height() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropHeight>> *>(VT_HEIGHT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropScaleX>> *scaleX() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropScaleX>> *>(VT_SCALEX);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropScaleY>> *scaleY() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropScaleY>> *>(VT_SCALEY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropSkewX>> *skewX() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropSkewX>> *>(VT_SKEWX);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropSkewY>> *skewY() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropSkewY>> *>(VT_SKEWY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropActive>> *active() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropActive>> *>(VT_ACTIVE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropSpriteFrame>> *spriteFrame() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropSpriteFrame>> *>(VT_SPRITEFRAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ROTATION) &&
           verifier.VerifyVector(rotation()) &&
           verifier.VerifyVectorOfTables(rotation()) &&
           VerifyOffset(verifier, VT_POSITION) &&
           verifier.VerifyVector(position()) &&
           verifier.VerifyVectorOfTables(position()) &&
           VerifyOffset(verifier, VT_POSITIONX) &&
           verifier.VerifyVector(positionX()) &&
           verifier.VerifyVectorOfTables(positionX()) &&
           VerifyOffset(verifier, VT_POSITIONY) &&
           verifier.VerifyVector(positionY()) &&
           verifier.VerifyVectorOfTables(positionY()) &&
           VerifyOffset(verifier, VT_ANCHORX) &&
           verifier.VerifyVector(anchorX()) &&
           verifier.VerifyVectorOfTables(anchorX()) &&
           VerifyOffset(verifier, VT_ANCHORY) &&
           verifier.VerifyVector(anchorY()) &&
           verifier.VerifyVectorOfTables(anchorY()) &&
           VerifyOffset(verifier, VT_COLOR) &&
           verifier.VerifyVector(color()) &&
           verifier.VerifyVectorOfTables(color()) &&
           VerifyOffset(verifier, VT_OPACITY) &&
           verifier.VerifyVector(opacity()) &&
           verifier.VerifyVectorOfTables(opacity()) &&
           VerifyOffset(verifier, VT_WIDTH) &&
           verifier.VerifyVector(width()) &&
           verifier.VerifyVectorOfTables(width()) &&
           VerifyOffset(verifier, VT_HEIGHT) &&
           verifier.VerifyVector(height()) &&
           verifier.VerifyVectorOfTables(height()) &&
           VerifyOffset(verifier, VT_SCALEX) &&
           verifier.VerifyVector(scaleX()) &&
           verifier.VerifyVectorOfTables(scaleX()) &&
           VerifyOffset(verifier, VT_SCALEY) &&
           verifier.VerifyVector(scaleY()) &&
           verifier.VerifyVectorOfTables(scaleY()) &&
           VerifyOffset(verifier, VT_SKEWX) &&
           verifier.VerifyVector(skewX()) &&
           verifier.VerifyVectorOfTables(skewX()) &&
           VerifyOffset(verifier, VT_SKEWY) &&
           verifier.VerifyVector(skewY()) &&
           verifier.VerifyVectorOfTables(skewY()) &&
           VerifyOffset(verifier, VT_ACTIVE) &&
           verifier.VerifyVector(active()) &&
           verifier.VerifyVectorOfTables(active()) &&
           VerifyOffset(verifier, VT_SPRITEFRAME) &&
           verifier.VerifyVector(spriteFrame()) &&
           verifier.VerifyVectorOfTables(spriteFrame()) &&
           verifier.EndTable();
  }
};

struct AnimPropsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rotation(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropRotation>>> rotation) {
    fbb_.AddOffset(AnimProps::VT_ROTATION, rotation);
  }
  void add_position(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropPosition>>> position) {
    fbb_.AddOffset(AnimProps::VT_POSITION, position);
  }
  void add_positionX(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropPositionX>>> positionX) {
    fbb_.AddOffset(AnimProps::VT_POSITIONX, positionX);
  }
  void add_positionY(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropPositionY>>> positionY) {
    fbb_.AddOffset(AnimProps::VT_POSITIONY, positionY);
  }
  void add_anchorX(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropAnchorX>>> anchorX) {
    fbb_.AddOffset(AnimProps::VT_ANCHORX, anchorX);
  }
  void add_anchorY(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropAnchorY>>> anchorY) {
    fbb_.AddOffset(AnimProps::VT_ANCHORY, anchorY);
  }
  void add_color(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropColor>>> color) {
    fbb_.AddOffset(AnimProps::VT_COLOR, color);
  }
  void add_opacity(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropOpacity>>> opacity) {
    fbb_.AddOffset(AnimProps::VT_OPACITY, opacity);
  }
  void add_width(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropWidth>>> width) {
    fbb_.AddOffset(AnimProps::VT_WIDTH, width);
  }
  void add_height(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropHeight>>> height) {
    fbb_.AddOffset(AnimProps::VT_HEIGHT, height);
  }
  void add_scaleX(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropScaleX>>> scaleX) {
    fbb_.AddOffset(AnimProps::VT_SCALEX, scaleX);
  }
  void add_scaleY(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropScaleY>>> scaleY) {
    fbb_.AddOffset(AnimProps::VT_SCALEY, scaleY);
  }
  void add_skewX(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropSkewX>>> skewX) {
    fbb_.AddOffset(AnimProps::VT_SKEWX, skewX);
  }
  void add_skewY(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropSkewY>>> skewY) {
    fbb_.AddOffset(AnimProps::VT_SKEWY, skewY);
  }
  void add_active(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropActive>>> active) {
    fbb_.AddOffset(AnimProps::VT_ACTIVE, active);
  }
  void add_spriteFrame(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropSpriteFrame>>> spriteFrame) {
    fbb_.AddOffset(AnimProps::VT_SPRITEFRAME, spriteFrame);
  }
  explicit AnimPropsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimPropsBuilder &operator=(const AnimPropsBuilder &);
  flatbuffers::Offset<AnimProps> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimProps>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimProps> CreateAnimProps(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropRotation>>> rotation = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropPosition>>> position = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropPositionX>>> positionX = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropPositionY>>> positionY = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropAnchorX>>> anchorX = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropAnchorY>>> anchorY = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropColor>>> color = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropOpacity>>> opacity = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropWidth>>> width = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropHeight>>> height = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropScaleX>>> scaleX = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropScaleY>>> scaleY = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropSkewX>>> skewX = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropSkewY>>> skewY = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropActive>>> active = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropSpriteFrame>>> spriteFrame = 0) {
  AnimPropsBuilder builder_(_fbb);
  builder_.add_spriteFrame(spriteFrame);
  builder_.add_active(active);
  builder_.add_skewY(skewY);
  builder_.add_skewX(skewX);
  builder_.add_scaleY(scaleY);
  builder_.add_scaleX(scaleX);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_opacity(opacity);
  builder_.add_color(color);
  builder_.add_anchorY(anchorY);
  builder_.add_anchorX(anchorX);
  builder_.add_positionY(positionY);
  builder_.add_positionX(positionX);
  builder_.add_position(position);
  builder_.add_rotation(rotation);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimProps> CreateAnimPropsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<AnimPropRotation>> *rotation = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropPosition>> *position = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropPositionX>> *positionX = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropPositionY>> *positionY = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropAnchorX>> *anchorX = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropAnchorY>> *anchorY = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropColor>> *color = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropOpacity>> *opacity = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropWidth>> *width = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropHeight>> *height = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropScaleX>> *scaleX = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropScaleY>> *scaleY = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropSkewX>> *skewX = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropSkewY>> *skewY = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropActive>> *active = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropSpriteFrame>> *spriteFrame = nullptr) {
  return creator::buffers::CreateAnimProps(
      _fbb,
      rotation ? _fbb.CreateVector<flatbuffers::Offset<AnimPropRotation>>(*rotation) : 0,
      position ? _fbb.CreateVector<flatbuffers::Offset<AnimPropPosition>>(*position) : 0,
      positionX ? _fbb.CreateVector<flatbuffers::Offset<AnimPropPositionX>>(*positionX) : 0,
      positionY ? _fbb.CreateVector<flatbuffers::Offset<AnimPropPositionY>>(*positionY) : 0,
      anchorX ? _fbb.CreateVector<flatbuffers::Offset<AnimPropAnchorX>>(*anchorX) : 0,
      anchorY ? _fbb.CreateVector<flatbuffers::Offset<AnimPropAnchorY>>(*anchorY) : 0,
      color ? _fbb.CreateVector<flatbuffers::Offset<AnimPropColor>>(*color) : 0,
      opacity ? _fbb.CreateVector<flatbuffers::Offset<AnimPropOpacity>>(*opacity) : 0,
      width ? _fbb.CreateVector<flatbuffers::Offset<AnimPropWidth>>(*width) : 0,
      height ? _fbb.CreateVector<flatbuffers::Offset<AnimPropHeight>>(*height) : 0,
      scaleX ? _fbb.CreateVector<flatbuffers::Offset<AnimPropScaleX>>(*scaleX) : 0,
      scaleY ? _fbb.CreateVector<flatbuffers::Offset<AnimPropScaleY>>(*scaleY) : 0,
      skewX ? _fbb.CreateVector<flatbuffers::Offset<AnimPropSkewX>>(*skewX) : 0,
      skewY ? _fbb.CreateVector<flatbuffers::Offset<AnimPropSkewY>>(*skewY) : 0,
      active ? _fbb.CreateVector<flatbuffers::Offset<AnimPropActive>>(*active) : 0,
      spriteFrame ? _fbb.CreateVector<flatbuffers::Offset<AnimPropSpriteFrame>>(*spriteFrame) : 0);
}

struct AnimEvents FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_FUNC = 6,
    VT_PARAMS = 8
  };
  float frame() const {
    return GetField<float>(VT_FRAME, 0.0f);
  }
  const flatbuffers::String *func() const {
    return GetPointer<const flatbuffers::String *>(VT_FUNC);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *params() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_PARAMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyOffset(verifier, VT_FUNC) &&
           verifier.VerifyString(func()) &&
           VerifyOffset(verifier, VT_PARAMS) &&
           verifier.VerifyVector(params()) &&
           verifier.VerifyVectorOfStrings(params()) &&
           verifier.EndTable();
  }
};

struct AnimEventsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) {
    fbb_.AddElement<float>(AnimEvents::VT_FRAME, frame, 0.0f);
  }
  void add_func(flatbuffers::Offset<flatbuffers::String> func) {
    fbb_.AddOffset(AnimEvents::VT_FUNC, func);
  }
  void add_params(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> params) {
    fbb_.AddOffset(AnimEvents::VT_PARAMS, params);
  }
  explicit AnimEventsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimEventsBuilder &operator=(const AnimEventsBuilder &);
  flatbuffers::Offset<AnimEvents> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimEvents>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimEvents> CreateAnimEvents(
    flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    flatbuffers::Offset<flatbuffers::String> func = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> params = 0) {
  AnimEventsBuilder builder_(_fbb);
  builder_.add_params(params);
  builder_.add_func(func);
  builder_.add_frame(frame);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimEvents> CreateAnimEventsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    const char *func = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *params = nullptr) {
  return creator::buffers::CreateAnimEvents(
      _fbb,
      frame,
      func ? _fbb.CreateString(func) : 0,
      params ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*params) : 0);
}

struct AnimPropActive FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6,
    VT_CURVETYPE = 8,
    VT_CURVEDATA = 10
  };
  float frame() const {
    return GetField<float>(VT_FRAME, 0.0f);
  }
  bool value() const {
    return GetField<uint8_t>(VT_VALUE, 0) != 0;
  }
  const flatbuffers::String *curveType() const {
    return GetPointer<const flatbuffers::String *>(VT_CURVETYPE);
  }
  const flatbuffers::Vector<float> *curveData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_CURVEDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<uint8_t>(verifier, VT_VALUE) &&
           VerifyOffset(verifier, VT_CURVETYPE) &&
           verifier.VerifyString(curveType()) &&
           VerifyOffset(verifier, VT_CURVEDATA) &&
           verifier.VerifyVector(curveData()) &&
           verifier.EndTable();
  }
};

struct AnimPropActiveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) {
    fbb_.AddElement<float>(AnimPropActive::VT_FRAME, frame, 0.0f);
  }
  void add_value(bool value) {
    fbb_.AddElement<uint8_t>(AnimPropActive::VT_VALUE, static_cast<uint8_t>(value), 0);
  }
  void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType) {
    fbb_.AddOffset(AnimPropActive::VT_CURVETYPE, curveType);
  }
  void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData) {
    fbb_.AddOffset(AnimPropActive::VT_CURVEDATA, curveData);
  }
  explicit AnimPropActiveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimPropActiveBuilder &operator=(const AnimPropActiveBuilder &);
  flatbuffers::Offset<AnimPropActive> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimPropActive>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimPropActive> CreateAnimPropActive(
    flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    bool value = false,
    flatbuffers::Offset<flatbuffers::String> curveType = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0) {
  AnimPropActiveBuilder builder_(_fbb);
  builder_.add_curveData(curveData);
  builder_.add_curveType(curveType);
  builder_.add_frame(frame);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropActive> CreateAnimPropActiveDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    bool value = false,
    const char *curveType = nullptr,
    const std::vector<float> *curveData = nullptr) {
  return creator::buffers::CreateAnimPropActive(
      _fbb,
      frame,
      value,
      curveType ? _fbb.CreateString(curveType) : 0,
      curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropRotation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6,
    VT_CURVETYPE = 8,
    VT_CURVEDATA = 10
  };
  float frame() const {
    return GetField<float>(VT_FRAME, 0.0f);
  }
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  const flatbuffers::String *curveType() const {
    return GetPointer<const flatbuffers::String *>(VT_CURVETYPE);
  }
  const flatbuffers::Vector<float> *curveData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_CURVEDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           VerifyOffset(verifier, VT_CURVETYPE) &&
           verifier.VerifyString(curveType()) &&
           VerifyOffset(verifier, VT_CURVEDATA) &&
           verifier.VerifyVector(curveData()) &&
           verifier.EndTable();
  }
};

struct AnimPropRotationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) {
    fbb_.AddElement<float>(AnimPropRotation::VT_FRAME, frame, 0.0f);
  }
  void add_value(float value) {
    fbb_.AddElement<float>(AnimPropRotation::VT_VALUE, value, 0.0f);
  }
  void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType) {
    fbb_.AddOffset(AnimPropRotation::VT_CURVETYPE, curveType);
  }
  void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData) {
    fbb_.AddOffset(AnimPropRotation::VT_CURVEDATA, curveData);
  }
  explicit AnimPropRotationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimPropRotationBuilder &operator=(const AnimPropRotationBuilder &);
  flatbuffers::Offset<AnimPropRotation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimPropRotation>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimPropRotation> CreateAnimPropRotation(
    flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    flatbuffers::Offset<flatbuffers::String> curveType = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0) {
  AnimPropRotationBuilder builder_(_fbb);
  builder_.add_curveData(curveData);
  builder_.add_curveType(curveType);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropRotation> CreateAnimPropRotationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    const char *curveType = nullptr,
    const std::vector<float> *curveData = nullptr) {
  return creator::buffers::CreateAnimPropRotation(
      _fbb,
      frame,
      value,
      curveType ? _fbb.CreateString(curveType) : 0,
      curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropPosition FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6,
    VT_CURVETYPE = 8,
    VT_CURVEDATA = 10
  };
  float frame() const {
    return GetField<float>(VT_FRAME, 0.0f);
  }
  const Vec2 *value() const {
    return GetStruct<const Vec2 *>(VT_VALUE);
  }
  const flatbuffers::String *curveType() const {
    return GetPointer<const flatbuffers::String *>(VT_CURVETYPE);
  }
  const flatbuffers::Vector<float> *curveData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_CURVEDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<Vec2>(verifier, VT_VALUE) &&
           VerifyOffset(verifier, VT_CURVETYPE) &&
           verifier.VerifyString(curveType()) &&
           VerifyOffset(verifier, VT_CURVEDATA) &&
           verifier.VerifyVector(curveData()) &&
           verifier.EndTable();
  }
};

struct AnimPropPositionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) {
    fbb_.AddElement<float>(AnimPropPosition::VT_FRAME, frame, 0.0f);
  }
  void add_value(const Vec2 *value) {
    fbb_.AddStruct(AnimPropPosition::VT_VALUE, value);
  }
  void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType) {
    fbb_.AddOffset(AnimPropPosition::VT_CURVETYPE, curveType);
  }
  void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData) {
    fbb_.AddOffset(AnimPropPosition::VT_CURVEDATA, curveData);
  }
  explicit AnimPropPositionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimPropPositionBuilder &operator=(const AnimPropPositionBuilder &);
  flatbuffers::Offset<AnimPropPosition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimPropPosition>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimPropPosition> CreateAnimPropPosition(
    flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    const Vec2 *value = 0,
    flatbuffers::Offset<flatbuffers::String> curveType = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0) {
  AnimPropPositionBuilder builder_(_fbb);
  builder_.add_curveData(curveData);
  builder_.add_curveType(curveType);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropPosition> CreateAnimPropPositionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    const Vec2 *value = 0,
    const char *curveType = nullptr,
    const std::vector<float> *curveData = nullptr) {
  return creator::buffers::CreateAnimPropPosition(
      _fbb,
      frame,
      value,
      curveType ? _fbb.CreateString(curveType) : 0,
      curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropPositionX FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6,
    VT_CURVETYPE = 8,
    VT_CURVEDATA = 10
  };
  float frame() const {
    return GetField<float>(VT_FRAME, 0.0f);
  }
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  const flatbuffers::String *curveType() const {
    return GetPointer<const flatbuffers::String *>(VT_CURVETYPE);
  }
  const flatbuffers::Vector<float> *curveData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_CURVEDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           VerifyOffset(verifier, VT_CURVETYPE) &&
           verifier.VerifyString(curveType()) &&
           VerifyOffset(verifier, VT_CURVEDATA) &&
           verifier.VerifyVector(curveData()) &&
           verifier.EndTable();
  }
};

struct AnimPropPositionXBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) {
    fbb_.AddElement<float>(AnimPropPositionX::VT_FRAME, frame, 0.0f);
  }
  void add_value(float value) {
    fbb_.AddElement<float>(AnimPropPositionX::VT_VALUE, value, 0.0f);
  }
  void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType) {
    fbb_.AddOffset(AnimPropPositionX::VT_CURVETYPE, curveType);
  }
  void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData) {
    fbb_.AddOffset(AnimPropPositionX::VT_CURVEDATA, curveData);
  }
  explicit AnimPropPositionXBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimPropPositionXBuilder &operator=(const AnimPropPositionXBuilder &);
  flatbuffers::Offset<AnimPropPositionX> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimPropPositionX>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimPropPositionX> CreateAnimPropPositionX(
    flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    flatbuffers::Offset<flatbuffers::String> curveType = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0) {
  AnimPropPositionXBuilder builder_(_fbb);
  builder_.add_curveData(curveData);
  builder_.add_curveType(curveType);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropPositionX> CreateAnimPropPositionXDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    const char *curveType = nullptr,
    const std::vector<float> *curveData = nullptr) {
  return creator::buffers::CreateAnimPropPositionX(
      _fbb,
      frame,
      value,
      curveType ? _fbb.CreateString(curveType) : 0,
      curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropPositionY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6,
    VT_CURVETYPE = 8,
    VT_CURVEDATA = 10
  };
  float frame() const {
    return GetField<float>(VT_FRAME, 0.0f);
  }
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  const flatbuffers::String *curveType() const {
    return GetPointer<const flatbuffers::String *>(VT_CURVETYPE);
  }
  const flatbuffers::Vector<float> *curveData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_CURVEDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           VerifyOffset(verifier, VT_CURVETYPE) &&
           verifier.VerifyString(curveType()) &&
           VerifyOffset(verifier, VT_CURVEDATA) &&
           verifier.VerifyVector(curveData()) &&
           verifier.EndTable();
  }
};

struct AnimPropPositionYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) {
    fbb_.AddElement<float>(AnimPropPositionY::VT_FRAME, frame, 0.0f);
  }
  void add_value(float value) {
    fbb_.AddElement<float>(AnimPropPositionY::VT_VALUE, value, 0.0f);
  }
  void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType) {
    fbb_.AddOffset(AnimPropPositionY::VT_CURVETYPE, curveType);
  }
  void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData) {
    fbb_.AddOffset(AnimPropPositionY::VT_CURVEDATA, curveData);
  }
  explicit AnimPropPositionYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimPropPositionYBuilder &operator=(const AnimPropPositionYBuilder &);
  flatbuffers::Offset<AnimPropPositionY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimPropPositionY>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimPropPositionY> CreateAnimPropPositionY(
    flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    flatbuffers::Offset<flatbuffers::String> curveType = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0) {
  AnimPropPositionYBuilder builder_(_fbb);
  builder_.add_curveData(curveData);
  builder_.add_curveType(curveType);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropPositionY> CreateAnimPropPositionYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    const char *curveType = nullptr,
    const std::vector<float> *curveData = nullptr) {
  return creator::buffers::CreateAnimPropPositionY(
      _fbb,
      frame,
      value,
      curveType ? _fbb.CreateString(curveType) : 0,
      curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropScaleX FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6,
    VT_CURVETYPE = 8,
    VT_CURVEDATA = 10
  };
  float frame() const {
    return GetField<float>(VT_FRAME, 0.0f);
  }
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  const flatbuffers::String *curveType() const {
    return GetPointer<const flatbuffers::String *>(VT_CURVETYPE);
  }
  const flatbuffers::Vector<float> *curveData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_CURVEDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           VerifyOffset(verifier, VT_CURVETYPE) &&
           verifier.VerifyString(curveType()) &&
           VerifyOffset(verifier, VT_CURVEDATA) &&
           verifier.VerifyVector(curveData()) &&
           verifier.EndTable();
  }
};

struct AnimPropScaleXBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) {
    fbb_.AddElement<float>(AnimPropScaleX::VT_FRAME, frame, 0.0f);
  }
  void add_value(float value) {
    fbb_.AddElement<float>(AnimPropScaleX::VT_VALUE, value, 0.0f);
  }
  void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType) {
    fbb_.AddOffset(AnimPropScaleX::VT_CURVETYPE, curveType);
  }
  void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData) {
    fbb_.AddOffset(AnimPropScaleX::VT_CURVEDATA, curveData);
  }
  explicit AnimPropScaleXBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimPropScaleXBuilder &operator=(const AnimPropScaleXBuilder &);
  flatbuffers::Offset<AnimPropScaleX> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimPropScaleX>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimPropScaleX> CreateAnimPropScaleX(
    flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    flatbuffers::Offset<flatbuffers::String> curveType = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0) {
  AnimPropScaleXBuilder builder_(_fbb);
  builder_.add_curveData(curveData);
  builder_.add_curveType(curveType);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropScaleX> CreateAnimPropScaleXDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    const char *curveType = nullptr,
    const std::vector<float> *curveData = nullptr) {
  return creator::buffers::CreateAnimPropScaleX(
      _fbb,
      frame,
      value,
      curveType ? _fbb.CreateString(curveType) : 0,
      curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropScaleY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6,
    VT_CURVETYPE = 8,
    VT_CURVEDATA = 10
  };
  float frame() const {
    return GetField<float>(VT_FRAME, 0.0f);
  }
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  const flatbuffers::String *curveType() const {
    return GetPointer<const flatbuffers::String *>(VT_CURVETYPE);
  }
  const flatbuffers::Vector<float> *curveData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_CURVEDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           VerifyOffset(verifier, VT_CURVETYPE) &&
           verifier.VerifyString(curveType()) &&
           VerifyOffset(verifier, VT_CURVEDATA) &&
           verifier.VerifyVector(curveData()) &&
           verifier.EndTable();
  }
};

struct AnimPropScaleYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) {
    fbb_.AddElement<float>(AnimPropScaleY::VT_FRAME, frame, 0.0f);
  }
  void add_value(float value) {
    fbb_.AddElement<float>(AnimPropScaleY::VT_VALUE, value, 0.0f);
  }
  void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType) {
    fbb_.AddOffset(AnimPropScaleY::VT_CURVETYPE, curveType);
  }
  void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData) {
    fbb_.AddOffset(AnimPropScaleY::VT_CURVEDATA, curveData);
  }
  explicit AnimPropScaleYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimPropScaleYBuilder &operator=(const AnimPropScaleYBuilder &);
  flatbuffers::Offset<AnimPropScaleY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimPropScaleY>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimPropScaleY> CreateAnimPropScaleY(
    flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    flatbuffers::Offset<flatbuffers::String> curveType = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0) {
  AnimPropScaleYBuilder builder_(_fbb);
  builder_.add_curveData(curveData);
  builder_.add_curveType(curveType);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropScaleY> CreateAnimPropScaleYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    const char *curveType = nullptr,
    const std::vector<float> *curveData = nullptr) {
  return creator::buffers::CreateAnimPropScaleY(
      _fbb,
      frame,
      value,
      curveType ? _fbb.CreateString(curveType) : 0,
      curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropWidth FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6,
    VT_CURVETYPE = 8,
    VT_CURVEDATA = 10
  };
  float frame() const {
    return GetField<float>(VT_FRAME, 0.0f);
  }
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  const flatbuffers::String *curveType() const {
    return GetPointer<const flatbuffers::String *>(VT_CURVETYPE);
  }
  const flatbuffers::Vector<float> *curveData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_CURVEDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           VerifyOffset(verifier, VT_CURVETYPE) &&
           verifier.VerifyString(curveType()) &&
           VerifyOffset(verifier, VT_CURVEDATA) &&
           verifier.VerifyVector(curveData()) &&
           verifier.EndTable();
  }
};

struct AnimPropWidthBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) {
    fbb_.AddElement<float>(AnimPropWidth::VT_FRAME, frame, 0.0f);
  }
  void add_value(float value) {
    fbb_.AddElement<float>(AnimPropWidth::VT_VALUE, value, 0.0f);
  }
  void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType) {
    fbb_.AddOffset(AnimPropWidth::VT_CURVETYPE, curveType);
  }
  void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData) {
    fbb_.AddOffset(AnimPropWidth::VT_CURVEDATA, curveData);
  }
  explicit AnimPropWidthBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimPropWidthBuilder &operator=(const AnimPropWidthBuilder &);
  flatbuffers::Offset<AnimPropWidth> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimPropWidth>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimPropWidth> CreateAnimPropWidth(
    flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    flatbuffers::Offset<flatbuffers::String> curveType = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0) {
  AnimPropWidthBuilder builder_(_fbb);
  builder_.add_curveData(curveData);
  builder_.add_curveType(curveType);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropWidth> CreateAnimPropWidthDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    const char *curveType = nullptr,
    const std::vector<float> *curveData = nullptr) {
  return creator::buffers::CreateAnimPropWidth(
      _fbb,
      frame,
      value,
      curveType ? _fbb.CreateString(curveType) : 0,
      curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropHeight FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6,
    VT_CURVETYPE = 8,
    VT_CURVEDATA = 10
  };
  float frame() const {
    return GetField<float>(VT_FRAME, 0.0f);
  }
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  const flatbuffers::String *curveType() const {
    return GetPointer<const flatbuffers::String *>(VT_CURVETYPE);
  }
  const flatbuffers::Vector<float> *curveData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_CURVEDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           VerifyOffset(verifier, VT_CURVETYPE) &&
           verifier.VerifyString(curveType()) &&
           VerifyOffset(verifier, VT_CURVEDATA) &&
           verifier.VerifyVector(curveData()) &&
           verifier.EndTable();
  }
};

struct AnimPropHeightBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) {
    fbb_.AddElement<float>(AnimPropHeight::VT_FRAME, frame, 0.0f);
  }
  void add_value(float value) {
    fbb_.AddElement<float>(AnimPropHeight::VT_VALUE, value, 0.0f);
  }
  void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType) {
    fbb_.AddOffset(AnimPropHeight::VT_CURVETYPE, curveType);
  }
  void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData) {
    fbb_.AddOffset(AnimPropHeight::VT_CURVEDATA, curveData);
  }
  explicit AnimPropHeightBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimPropHeightBuilder &operator=(const AnimPropHeightBuilder &);
  flatbuffers::Offset<AnimPropHeight> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimPropHeight>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimPropHeight> CreateAnimPropHeight(
    flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    flatbuffers::Offset<flatbuffers::String> curveType = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0) {
  AnimPropHeightBuilder builder_(_fbb);
  builder_.add_curveData(curveData);
  builder_.add_curveType(curveType);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropHeight> CreateAnimPropHeightDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    const char *curveType = nullptr,
    const std::vector<float> *curveData = nullptr) {
  return creator::buffers::CreateAnimPropHeight(
      _fbb,
      frame,
      value,
      curveType ? _fbb.CreateString(curveType) : 0,
      curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropColor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6,
    VT_CURVETYPE = 8,
    VT_CURVEDATA = 10
  };
  float frame() const {
    return GetField<float>(VT_FRAME, 0.0f);
  }
  const ColorRGBA *value() const {
    return GetStruct<const ColorRGBA *>(VT_VALUE);
  }
  const flatbuffers::String *curveType() const {
    return GetPointer<const flatbuffers::String *>(VT_CURVETYPE);
  }
  const flatbuffers::Vector<float> *curveData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_CURVEDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<ColorRGBA>(verifier, VT_VALUE) &&
           VerifyOffset(verifier, VT_CURVETYPE) &&
           verifier.VerifyString(curveType()) &&
           VerifyOffset(verifier, VT_CURVEDATA) &&
           verifier.VerifyVector(curveData()) &&
           verifier.EndTable();
  }
};

struct AnimPropColorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) {
    fbb_.AddElement<float>(AnimPropColor::VT_FRAME, frame, 0.0f);
  }
  void add_value(const ColorRGBA *value) {
    fbb_.AddStruct(AnimPropColor::VT_VALUE, value);
  }
  void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType) {
    fbb_.AddOffset(AnimPropColor::VT_CURVETYPE, curveType);
  }
  void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData) {
    fbb_.AddOffset(AnimPropColor::VT_CURVEDATA, curveData);
  }
  explicit AnimPropColorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimPropColorBuilder &operator=(const AnimPropColorBuilder &);
  flatbuffers::Offset<AnimPropColor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimPropColor>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimPropColor> CreateAnimPropColor(
    flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    const ColorRGBA *value = 0,
    flatbuffers::Offset<flatbuffers::String> curveType = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0) {
  AnimPropColorBuilder builder_(_fbb);
  builder_.add_curveData(curveData);
  builder_.add_curveType(curveType);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropColor> CreateAnimPropColorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    const ColorRGBA *value = 0,
    const char *curveType = nullptr,
    const std::vector<float> *curveData = nullptr) {
  return creator::buffers::CreateAnimPropColor(
      _fbb,
      frame,
      value,
      curveType ? _fbb.CreateString(curveType) : 0,
      curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropOpacity FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6,
    VT_CURVETYPE = 8,
    VT_CURVEDATA = 10
  };
  float frame() const {
    return GetField<float>(VT_FRAME, 0.0f);
  }
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  const flatbuffers::String *curveType() const {
    return GetPointer<const flatbuffers::String *>(VT_CURVETYPE);
  }
  const flatbuffers::Vector<float> *curveData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_CURVEDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           VerifyOffset(verifier, VT_CURVETYPE) &&
           verifier.VerifyString(curveType()) &&
           VerifyOffset(verifier, VT_CURVEDATA) &&
           verifier.VerifyVector(curveData()) &&
           verifier.EndTable();
  }
};

struct AnimPropOpacityBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) {
    fbb_.AddElement<float>(AnimPropOpacity::VT_FRAME, frame, 0.0f);
  }
  void add_value(float value) {
    fbb_.AddElement<float>(AnimPropOpacity::VT_VALUE, value, 0.0f);
  }
  void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType) {
    fbb_.AddOffset(AnimPropOpacity::VT_CURVETYPE, curveType);
  }
  void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData) {
    fbb_.AddOffset(AnimPropOpacity::VT_CURVEDATA, curveData);
  }
  explicit AnimPropOpacityBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimPropOpacityBuilder &operator=(const AnimPropOpacityBuilder &);
  flatbuffers::Offset<AnimPropOpacity> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimPropOpacity>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimPropOpacity> CreateAnimPropOpacity(
    flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    flatbuffers::Offset<flatbuffers::String> curveType = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0) {
  AnimPropOpacityBuilder builder_(_fbb);
  builder_.add_curveData(curveData);
  builder_.add_curveType(curveType);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropOpacity> CreateAnimPropOpacityDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    const char *curveType = nullptr,
    const std::vector<float> *curveData = nullptr) {
  return creator::buffers::CreateAnimPropOpacity(
      _fbb,
      frame,
      value,
      curveType ? _fbb.CreateString(curveType) : 0,
      curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropAnchorX FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6,
    VT_CURVETYPE = 8,
    VT_CURVEDATA = 10
  };
  float frame() const {
    return GetField<float>(VT_FRAME, 0.0f);
  }
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  const flatbuffers::String *curveType() const {
    return GetPointer<const flatbuffers::String *>(VT_CURVETYPE);
  }
  const flatbuffers::Vector<float> *curveData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_CURVEDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           VerifyOffset(verifier, VT_CURVETYPE) &&
           verifier.VerifyString(curveType()) &&
           VerifyOffset(verifier, VT_CURVEDATA) &&
           verifier.VerifyVector(curveData()) &&
           verifier.EndTable();
  }
};

struct AnimPropAnchorXBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) {
    fbb_.AddElement<float>(AnimPropAnchorX::VT_FRAME, frame, 0.0f);
  }
  void add_value(float value) {
    fbb_.AddElement<float>(AnimPropAnchorX::VT_VALUE, value, 0.0f);
  }
  void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType) {
    fbb_.AddOffset(AnimPropAnchorX::VT_CURVETYPE, curveType);
  }
  void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData) {
    fbb_.AddOffset(AnimPropAnchorX::VT_CURVEDATA, curveData);
  }
  explicit AnimPropAnchorXBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimPropAnchorXBuilder &operator=(const AnimPropAnchorXBuilder &);
  flatbuffers::Offset<AnimPropAnchorX> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimPropAnchorX>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimPropAnchorX> CreateAnimPropAnchorX(
    flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    flatbuffers::Offset<flatbuffers::String> curveType = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0) {
  AnimPropAnchorXBuilder builder_(_fbb);
  builder_.add_curveData(curveData);
  builder_.add_curveType(curveType);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropAnchorX> CreateAnimPropAnchorXDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    const char *curveType = nullptr,
    const std::vector<float> *curveData = nullptr) {
  return creator::buffers::CreateAnimPropAnchorX(
      _fbb,
      frame,
      value,
      curveType ? _fbb.CreateString(curveType) : 0,
      curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropAnchorY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6,
    VT_CURVETYPE = 8,
    VT_CURVEDATA = 10
  };
  float frame() const {
    return GetField<float>(VT_FRAME, 0.0f);
  }
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  const flatbuffers::String *curveType() const {
    return GetPointer<const flatbuffers::String *>(VT_CURVETYPE);
  }
  const flatbuffers::Vector<float> *curveData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_CURVEDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           VerifyOffset(verifier, VT_CURVETYPE) &&
           verifier.VerifyString(curveType()) &&
           VerifyOffset(verifier, VT_CURVEDATA) &&
           verifier.VerifyVector(curveData()) &&
           verifier.EndTable();
  }
};

struct AnimPropAnchorYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) {
    fbb_.AddElement<float>(AnimPropAnchorY::VT_FRAME, frame, 0.0f);
  }
  void add_value(float value) {
    fbb_.AddElement<float>(AnimPropAnchorY::VT_VALUE, value, 0.0f);
  }
  void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType) {
    fbb_.AddOffset(AnimPropAnchorY::VT_CURVETYPE, curveType);
  }
  void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData) {
    fbb_.AddOffset(AnimPropAnchorY::VT_CURVEDATA, curveData);
  }
  explicit AnimPropAnchorYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimPropAnchorYBuilder &operator=(const AnimPropAnchorYBuilder &);
  flatbuffers::Offset<AnimPropAnchorY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimPropAnchorY>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimPropAnchorY> CreateAnimPropAnchorY(
    flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    flatbuffers::Offset<flatbuffers::String> curveType = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0) {
  AnimPropAnchorYBuilder builder_(_fbb);
  builder_.add_curveData(curveData);
  builder_.add_curveType(curveType);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropAnchorY> CreateAnimPropAnchorYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    const char *curveType = nullptr,
    const std::vector<float> *curveData = nullptr) {
  return creator::buffers::CreateAnimPropAnchorY(
      _fbb,
      frame,
      value,
      curveType ? _fbb.CreateString(curveType) : 0,
      curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropSkewX FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6,
    VT_CURVETYPE = 8,
    VT_CURVEDATA = 10
  };
  float frame() const {
    return GetField<float>(VT_FRAME, 0.0f);
  }
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  const flatbuffers::String *curveType() const {
    return GetPointer<const flatbuffers::String *>(VT_CURVETYPE);
  }
  const flatbuffers::Vector<float> *curveData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_CURVEDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           VerifyOffset(verifier, VT_CURVETYPE) &&
           verifier.VerifyString(curveType()) &&
           VerifyOffset(verifier, VT_CURVEDATA) &&
           verifier.VerifyVector(curveData()) &&
           verifier.EndTable();
  }
};

struct AnimPropSkewXBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) {
    fbb_.AddElement<float>(AnimPropSkewX::VT_FRAME, frame, 0.0f);
  }
  void add_value(float value) {
    fbb_.AddElement<float>(AnimPropSkewX::VT_VALUE, value, 0.0f);
  }
  void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType) {
    fbb_.AddOffset(AnimPropSkewX::VT_CURVETYPE, curveType);
  }
  void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData) {
    fbb_.AddOffset(AnimPropSkewX::VT_CURVEDATA, curveData);
  }
  explicit AnimPropSkewXBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimPropSkewXBuilder &operator=(const AnimPropSkewXBuilder &);
  flatbuffers::Offset<AnimPropSkewX> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimPropSkewX>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimPropSkewX> CreateAnimPropSkewX(
    flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    flatbuffers::Offset<flatbuffers::String> curveType = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0) {
  AnimPropSkewXBuilder builder_(_fbb);
  builder_.add_curveData(curveData);
  builder_.add_curveType(curveType);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropSkewX> CreateAnimPropSkewXDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    const char *curveType = nullptr,
    const std::vector<float> *curveData = nullptr) {
  return creator::buffers::CreateAnimPropSkewX(
      _fbb,
      frame,
      value,
      curveType ? _fbb.CreateString(curveType) : 0,
      curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropSkewY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6,
    VT_CURVETYPE = 8,
    VT_CURVEDATA = 10
  };
  float frame() const {
    return GetField<float>(VT_FRAME, 0.0f);
  }
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  const flatbuffers::String *curveType() const {
    return GetPointer<const flatbuffers::String *>(VT_CURVETYPE);
  }
  const flatbuffers::Vector<float> *curveData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_CURVEDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           VerifyOffset(verifier, VT_CURVETYPE) &&
           verifier.VerifyString(curveType()) &&
           VerifyOffset(verifier, VT_CURVEDATA) &&
           verifier.VerifyVector(curveData()) &&
           verifier.EndTable();
  }
};

struct AnimPropSkewYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) {
    fbb_.AddElement<float>(AnimPropSkewY::VT_FRAME, frame, 0.0f);
  }
  void add_value(float value) {
    fbb_.AddElement<float>(AnimPropSkewY::VT_VALUE, value, 0.0f);
  }
  void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType) {
    fbb_.AddOffset(AnimPropSkewY::VT_CURVETYPE, curveType);
  }
  void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData) {
    fbb_.AddOffset(AnimPropSkewY::VT_CURVEDATA, curveData);
  }
  explicit AnimPropSkewYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimPropSkewYBuilder &operator=(const AnimPropSkewYBuilder &);
  flatbuffers::Offset<AnimPropSkewY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimPropSkewY>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimPropSkewY> CreateAnimPropSkewY(
    flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    flatbuffers::Offset<flatbuffers::String> curveType = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0) {
  AnimPropSkewYBuilder builder_(_fbb);
  builder_.add_curveData(curveData);
  builder_.add_curveType(curveType);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropSkewY> CreateAnimPropSkewYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    const char *curveType = nullptr,
    const std::vector<float> *curveData = nullptr) {
  return creator::buffers::CreateAnimPropSkewY(
      _fbb,
      frame,
      value,
      curveType ? _fbb.CreateString(curveType) : 0,
      curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropSpriteFrame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6,
    VT_CURVETYPE = 8,
    VT_CURVEDATA = 10
  };
  float frame() const {
    return GetField<float>(VT_FRAME, 0.0f);
  }
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  const flatbuffers::String *curveType() const {
    return GetPointer<const flatbuffers::String *>(VT_CURVETYPE);
  }
  const flatbuffers::Vector<float> *curveData() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_CURVEDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           VerifyOffset(verifier, VT_CURVETYPE) &&
           verifier.VerifyString(curveType()) &&
           VerifyOffset(verifier, VT_CURVEDATA) &&
           verifier.VerifyVector(curveData()) &&
           verifier.EndTable();
  }
};

struct AnimPropSpriteFrameBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) {
    fbb_.AddElement<float>(AnimPropSpriteFrame::VT_FRAME, frame, 0.0f);
  }
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(AnimPropSpriteFrame::VT_VALUE, value);
  }
  void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType) {
    fbb_.AddOffset(AnimPropSpriteFrame::VT_CURVETYPE, curveType);
  }
  void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData) {
    fbb_.AddOffset(AnimPropSpriteFrame::VT_CURVEDATA, curveData);
  }
  explicit AnimPropSpriteFrameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimPropSpriteFrameBuilder &operator=(const AnimPropSpriteFrameBuilder &);
  flatbuffers::Offset<AnimPropSpriteFrame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimPropSpriteFrame>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimPropSpriteFrame> CreateAnimPropSpriteFrame(
    flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    flatbuffers::Offset<flatbuffers::String> value = 0,
    flatbuffers::Offset<flatbuffers::String> curveType = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0) {
  AnimPropSpriteFrameBuilder builder_(_fbb);
  builder_.add_curveData(curveData);
  builder_.add_curveType(curveType);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropSpriteFrame> CreateAnimPropSpriteFrameDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    const char *value = nullptr,
    const char *curveType = nullptr,
    const std::vector<float> *curveData = nullptr) {
  return creator::buffers::CreateAnimPropSpriteFrame(
      _fbb,
      frame,
      value ? _fbb.CreateString(value) : 0,
      curveType ? _fbb.CreateString(curveType) : 0,
      curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

inline const creator::buffers::AnimationClip *GetAnimationClip(const void *buf) {
  return flatbuffers::GetRoot<creator::buffers::AnimationClip>(buf);
}

inline const creator::buffers::AnimationClip *GetSizePrefixedAnimationClip(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<creator::buffers::AnimationClip>(buf);
}

inline const char *AnimationClipIdentifier() {
  return "CCAM";
}

inline bool AnimationClipBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, AnimationClipIdentifier());
}

inline bool VerifyAnimationClipBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<creator::buffers::AnimationClip>(AnimationClipIdentifier());
}

inline bool VerifySizePrefixedAnimationClipBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<creator::buffers::AnimationClip>(AnimationClipIdentifier());
}

inline const char *AnimationClipExtension() {
  return "anim";
}

inline void FinishAnimationClipBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<creator::buffers::AnimationClip> root) {
  fbb.Finish(root, AnimationClipIdentifier());
}

inline void FinishSizePrefixedAnimationClipBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<creator::buffers::AnimationClip> root) {
  fbb.FinishSizePrefixed(root, AnimationClipIdentifier());
}

}  // namespace buffers
}  // namespace creator

#endif  // FLATBUFFERS_GENERATED_ANIMATION_CREATOR_BUFFERS_H_
