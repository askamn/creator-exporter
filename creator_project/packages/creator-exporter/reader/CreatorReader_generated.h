// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_CREATORREADER_CREATOR_BUFFERS_H_
#define FLATBUFFERS_GENERATED_CREATORREADER_CREATOR_BUFFERS_H_

#include "flatbuffers/flatbuffers.h"

namespace creator
{
namespace buffers
{

struct NodeGraph;

struct CollisionLine;

struct NodeTree;

struct SpriteFrame;

struct CreatorScene;

struct Node;

struct Sprite;

struct Label;

struct RichText;

struct Particle;

struct TileMap;

struct Scene;

struct Prefab;

struct Button;

struct ProgressBar;

struct ScrollView;

struct Widget;

struct Layout;

struct EditBox;

struct VideoPlayer;

struct WebView;

struct Slider;

struct Toggle;

struct ToggleGroup;

struct Mask;

struct PageViewIndicator;

struct PageViewPage;

struct PageViewBackground;

struct PageView;

struct MotionStreak;

struct SpineSkeleton;

struct AnimationRef;

struct Collider;

struct DragonBones;

struct AnimationClip;

struct AnimCurveData;

struct AnimProps;

struct AnimEvents;

struct AnimPropActive;

struct AnimPropRotation;

struct AnimPropPosition;

struct AnimPropPositionX;

struct AnimPropPositionY;

struct AnimPropScaleX;

struct AnimPropScaleY;

struct AnimPropWidth;

struct AnimPropHeight;

struct AnimPropColor;

struct AnimPropOpacity;

struct AnimPropAnchorX;

struct AnimPropAnchorY;

struct AnimPropSkewX;

struct AnimPropSkewY;

struct AnimPropSpriteFrame;

struct Vec2;

struct Vec3;

struct Size;

struct Rect;

struct ColorRGB;

struct ColorRGBA;

struct LabelOutline;

struct LabelShadow;

enum FontType
{
	FontType_System = 0,
	FontType_BMFont = 1,
	FontType_TTF = 2,
	FontType_MIN = FontType_System,
	FontType_MAX = FontType_TTF
};

inline const FontType (&EnumValuesFontType())[3]
{
	static const FontType values[] = {
		FontType_System,
		FontType_BMFont,
		FontType_TTF};
	return values;
}

inline const char* const* EnumNamesFontType()
{
	static const char* const names[] = {
		"System",
		"BMFont",
		"TTF",
		nullptr};
	return names;
}

inline const char* EnumNameFontType(FontType e)
{
	const size_t index = static_cast<int>(e);
	return EnumNamesFontType()[index];
}

enum VerticalAlignment
{
	VerticalAlignment_Top = 0,
	VerticalAlignment_Center = 1,
	VerticalAlignment_Bottom = 2,
	VerticalAlignment_MIN = VerticalAlignment_Top,
	VerticalAlignment_MAX = VerticalAlignment_Bottom
};

inline const VerticalAlignment (&EnumValuesVerticalAlignment())[3]
{
	static const VerticalAlignment values[] = {
		VerticalAlignment_Top,
		VerticalAlignment_Center,
		VerticalAlignment_Bottom};
	return values;
}

inline const char* const* EnumNamesVerticalAlignment()
{
	static const char* const names[] = {
		"Top",
		"Center",
		"Bottom",
		nullptr};
	return names;
}

inline const char* EnumNameVerticalAlignment(VerticalAlignment e)
{
	const size_t index = static_cast<int>(e);
	return EnumNamesVerticalAlignment()[index];
}

enum HorizontalAlignment
{
	HorizontalAlignment_Left = 0,
	HorizontalAlignment_Center = 1,
	HorizontalAlignment_Right = 2,
	HorizontalAlignment_MIN = HorizontalAlignment_Left,
	HorizontalAlignment_MAX = HorizontalAlignment_Right
};

inline const HorizontalAlignment (&EnumValuesHorizontalAlignment())[3]
{
	static const HorizontalAlignment values[] = {
		HorizontalAlignment_Left,
		HorizontalAlignment_Center,
		HorizontalAlignment_Right};
	return values;
}

inline const char* const* EnumNamesHorizontalAlignment()
{
	static const char* const names[] = {
		"Left",
		"Center",
		"Right",
		nullptr};
	return names;
}

inline const char* EnumNameHorizontalAlignment(HorizontalAlignment e)
{
	const size_t index = static_cast<int>(e);
	return EnumNamesHorizontalAlignment()[index];
}

enum SpriteType
{
	SpriteType_Simple = 0,
	SpriteType_Sliced = 1,
	SpriteType_Tiled = 2,
	SpriteType_Filled = 3,
	SpriteType_MIN = SpriteType_Simple,
	SpriteType_MAX = SpriteType_Filled
};

inline const SpriteType (&EnumValuesSpriteType())[4]
{
	static const SpriteType values[] = {
		SpriteType_Simple,
		SpriteType_Sliced,
		SpriteType_Tiled,
		SpriteType_Filled};
	return values;
}

inline const char* const* EnumNamesSpriteType()
{
	static const char* const names[] = {
		"Simple",
		"Sliced",
		"Tiled",
		"Filled",
		nullptr};
	return names;
}

inline const char* EnumNameSpriteType(SpriteType e)
{
	const size_t index = static_cast<int>(e);
	return EnumNamesSpriteType()[index];
}

enum SpriteFillType
{
	SpriteFillType_Horizontal = 0,
	SpriteFillType_Vertical = 1,
	SpriteFillType_Radial = 2,
	SpriteFillType_MIN = SpriteFillType_Horizontal,
	SpriteFillType_MAX = SpriteFillType_Radial
};

inline const SpriteFillType (&EnumValuesSpriteFillType())[3]
{
	static const SpriteFillType values[] = {
		SpriteFillType_Horizontal,
		SpriteFillType_Vertical,
		SpriteFillType_Radial};
	return values;
}

inline const char* const* EnumNamesSpriteFillType()
{
	static const char* const names[] = {
		"Horizontal",
		"Vertical",
		"Radial",
		nullptr};
	return names;
}

inline const char* EnumNameSpriteFillType(SpriteFillType e)
{
	const size_t index = static_cast<int>(e);
	return EnumNamesSpriteFillType()[index];
}

enum SpriteSizeMode
{
	SpriteSizeMode_Custom = 0,
	SpriteSizeMode_Trimmed = 1,
	SpriteSizeMode_Raw = 2,
	SpriteSizeMode_MIN = SpriteSizeMode_Custom,
	SpriteSizeMode_MAX = SpriteSizeMode_Raw
};

inline const SpriteSizeMode (&EnumValuesSpriteSizeMode())[3]
{
	static const SpriteSizeMode values[] = {
		SpriteSizeMode_Custom,
		SpriteSizeMode_Trimmed,
		SpriteSizeMode_Raw};
	return values;
}

inline const char* const* EnumNamesSpriteSizeMode()
{
	static const char* const names[] = {
		"Custom",
		"Trimmed",
		"Raw",
		nullptr};
	return names;
}

inline const char* EnumNameSpriteSizeMode(SpriteSizeMode e)
{
	const size_t index = static_cast<int>(e);
	return EnumNamesSpriteSizeMode()[index];
}

enum ScrollViewDirection
{
	ScrollViewDirection_None = 0,
	ScrollViewDirection_Vertical = 1,
	ScrollViewDirection_Horizontal = 2,
	ScrollViewDirection_Both = 3,
	ScrollViewDirection_MIN = ScrollViewDirection_None,
	ScrollViewDirection_MAX = ScrollViewDirection_Both
};

inline const ScrollViewDirection (&EnumValuesScrollViewDirection())[4]
{
	static const ScrollViewDirection values[] = {
		ScrollViewDirection_None,
		ScrollViewDirection_Vertical,
		ScrollViewDirection_Horizontal,
		ScrollViewDirection_Both};
	return values;
}

inline const char* const* EnumNamesScrollViewDirection()
{
	static const char* const names[] = {
		"None",
		"Vertical",
		"Horizontal",
		"Both",
		nullptr};
	return names;
}

inline const char* EnumNameScrollViewDirection(ScrollViewDirection e)
{
	const size_t index = static_cast<int>(e);
	return EnumNamesScrollViewDirection()[index];
}

enum EditBoxReturnType
{
	EditBoxReturnType_Default = 0,
	EditBoxReturnType_Done = 1,
	EditBoxReturnType_Send = 2,
	EditBoxReturnType_Search = 3,
	EditBoxReturnType_Go = 4,
	EditBoxReturnType_MIN = EditBoxReturnType_Default,
	EditBoxReturnType_MAX = EditBoxReturnType_Go
};

inline const EditBoxReturnType (&EnumValuesEditBoxReturnType())[5]
{
	static const EditBoxReturnType values[] = {
		EditBoxReturnType_Default,
		EditBoxReturnType_Done,
		EditBoxReturnType_Send,
		EditBoxReturnType_Search,
		EditBoxReturnType_Go};
	return values;
}

inline const char* const* EnumNamesEditBoxReturnType()
{
	static const char* const names[] = {
		"Default",
		"Done",
		"Send",
		"Search",
		"Go",
		nullptr};
	return names;
}

inline const char* EnumNameEditBoxReturnType(EditBoxReturnType e)
{
	const size_t index = static_cast<int>(e);
	return EnumNamesEditBoxReturnType()[index];
}

enum EditBoxInputFlag
{
	EditBoxInputFlag_Password = 0,
	EditBoxInputFlag_Sensitive = 1,
	EditBoxInputFlag_InitialCapsWord = 2,
	EditBoxInputFlag_InitialCapsSentence = 3,
	EditBoxInputFlag_InitialCapsAllCharacters = 4,
	EditBoxInputFlag_LowercaseAllCharacters = 5,
	EditBoxInputFlag_MIN = EditBoxInputFlag_Password,
	EditBoxInputFlag_MAX = EditBoxInputFlag_LowercaseAllCharacters
};

inline const EditBoxInputFlag (&EnumValuesEditBoxInputFlag())[6]
{
	static const EditBoxInputFlag values[] = {
		EditBoxInputFlag_Password,
		EditBoxInputFlag_Sensitive,
		EditBoxInputFlag_InitialCapsWord,
		EditBoxInputFlag_InitialCapsSentence,
		EditBoxInputFlag_InitialCapsAllCharacters,
		EditBoxInputFlag_LowercaseAllCharacters};
	return values;
}

inline const char* const* EnumNamesEditBoxInputFlag()
{
	static const char* const names[] = {
		"Password",
		"Sensitive",
		"InitialCapsWord",
		"InitialCapsSentence",
		"InitialCapsAllCharacters",
		"LowercaseAllCharacters",
		nullptr};
	return names;
}

inline const char* EnumNameEditBoxInputFlag(EditBoxInputFlag e)
{
	const size_t index = static_cast<int>(e);
	return EnumNamesEditBoxInputFlag()[index];
}

enum EditBoxInputMode
{
	EditBoxInputMode_Any = 0,
	EditBoxInputMode_EmailAddress = 1,
	EditBoxInputMode_Numeric = 2,
	EditBoxInputMode_PhoneNumber = 3,
	EditBoxInputMode_URL = 4,
	EditBoxInputMode_Decime = 5,
	EditBoxInputMode_SingleLine = 6,
	EditBoxInputMode_MIN = EditBoxInputMode_Any,
	EditBoxInputMode_MAX = EditBoxInputMode_SingleLine
};

inline const EditBoxInputMode (&EnumValuesEditBoxInputMode())[7]
{
	static const EditBoxInputMode values[] = {
		EditBoxInputMode_Any,
		EditBoxInputMode_EmailAddress,
		EditBoxInputMode_Numeric,
		EditBoxInputMode_PhoneNumber,
		EditBoxInputMode_URL,
		EditBoxInputMode_Decime,
		EditBoxInputMode_SingleLine};
	return values;
}

inline const char* const* EnumNamesEditBoxInputMode()
{
	static const char* const names[] = {
		"Any",
		"EmailAddress",
		"Numeric",
		"PhoneNumber",
		"URL",
		"Decime",
		"SingleLine",
		nullptr};
	return names;
}

inline const char* EnumNameEditBoxInputMode(EditBoxInputMode e)
{
	const size_t index = static_cast<int>(e);
	return EnumNamesEditBoxInputMode()[index];
}

enum LabelOverflowType
{
	LabelOverflowType_None = 0,
	LabelOverflowType_Clamp = 1,
	LabelOverflowType_Shrink = 2,
	LabelOverflowType_ResizeHeight = 3,
	LabelOverflowType_Toggle = 4,
	LabelOverflowType_MIN = LabelOverflowType_None,
	LabelOverflowType_MAX = LabelOverflowType_Toggle
};

inline const LabelOverflowType (&EnumValuesLabelOverflowType())[5]
{
	static const LabelOverflowType values[] = {
		LabelOverflowType_None,
		LabelOverflowType_Clamp,
		LabelOverflowType_Shrink,
		LabelOverflowType_ResizeHeight,
		LabelOverflowType_Toggle};
	return values;
}

inline const char* const* EnumNamesLabelOverflowType()
{
	static const char* const names[] = {
		"None",
		"Clamp",
		"Shrink",
		"ResizeHeight",
		"Toggle",
		nullptr};
	return names;
}

inline const char* EnumNameLabelOverflowType(LabelOverflowType e)
{
	const size_t index = static_cast<int>(e);
	return EnumNamesLabelOverflowType()[index];
}

enum MaskType
{
	MaskType_Rect = 0,
	MaskType_Ellipse = 1,
	MaskType_ImageStencil = 2,
	MaskType_MIN = MaskType_Rect,
	MaskType_MAX = MaskType_ImageStencil
};

inline const MaskType (&EnumValuesMaskType())[3]
{
	static const MaskType values[] = {
		MaskType_Rect,
		MaskType_Ellipse,
		MaskType_ImageStencil};
	return values;
}

inline const char* const* EnumNamesMaskType()
{
	static const char* const names[] = {
		"Rect",
		"Ellipse",
		"ImageStencil",
		nullptr};
	return names;
}

inline const char* EnumNameMaskType(MaskType e)
{
	const size_t index = static_cast<int>(e);
	return EnumNamesMaskType()[index];
}

enum ColliderType
{
	ColliderType_BoxCollider = 0,
	ColliderType_PolygonCollider = 1,
	ColliderType_CircleCollider = 2,
	ColliderType_MIN = ColliderType_BoxCollider,
	ColliderType_MAX = ColliderType_CircleCollider
};

inline const ColliderType (&EnumValuesColliderType())[3]
{
	static const ColliderType values[] = {
		ColliderType_BoxCollider,
		ColliderType_PolygonCollider,
		ColliderType_CircleCollider};
	return values;
}

inline const char* const* EnumNamesColliderType()
{
	static const char* const names[] = {
		"BoxCollider",
		"PolygonCollider",
		"CircleCollider",
		nullptr};
	return names;
}

inline const char* EnumNameColliderType(ColliderType e)
{
	const size_t index = static_cast<int>(e);
	return EnumNamesColliderType()[index];
}

enum LayoutType
{
	LayoutType_None = 0,
	LayoutType_Horizontal = 1,
	LayoutType_Vertical = 2,
	LayoutType_Grid = 3,
	LayoutType_MIN = LayoutType_None,
	LayoutType_MAX = LayoutType_Grid
};

inline const LayoutType (&EnumValuesLayoutType())[4]
{
	static const LayoutType values[] = {
		LayoutType_None,
		LayoutType_Horizontal,
		LayoutType_Vertical,
		LayoutType_Grid};
	return values;
}

inline const char* const* EnumNamesLayoutType()
{
	static const char* const names[] = {
		"None",
		"Horizontal",
		"Vertical",
		"Grid",
		nullptr};
	return names;
}

inline const char* EnumNameLayoutType(LayoutType e)
{
	const size_t index = static_cast<int>(e);
	return EnumNamesLayoutType()[index];
}

enum ResizeMode
{
	ResizeMode_None = 0,
	ResizeMode_Container = 1,
	ResizeMode_Children = 2,
	ResizeMode_MIN = ResizeMode_None,
	ResizeMode_MAX = ResizeMode_Children
};

inline const ResizeMode (&EnumValuesResizeMode())[3]
{
	static const ResizeMode values[] = {
		ResizeMode_None,
		ResizeMode_Container,
		ResizeMode_Children};
	return values;
}

inline const char* const* EnumNamesResizeMode()
{
	static const char* const names[] = {
		"None",
		"Container",
		"Children",
		nullptr};
	return names;
}

inline const char* EnumNameResizeMode(ResizeMode e)
{
	const size_t index = static_cast<int>(e);
	return EnumNamesResizeMode()[index];
}

enum AxisDirection
{
	AxisDirection_Horizontal = 0,
	AxisDirection_Vertical = 1,
	AxisDirection_MIN = AxisDirection_Horizontal,
	AxisDirection_MAX = AxisDirection_Vertical
};

inline const AxisDirection (&EnumValuesAxisDirection())[2]
{
	static const AxisDirection values[] = {
		AxisDirection_Horizontal,
		AxisDirection_Vertical};
	return values;
}

inline const char* const* EnumNamesAxisDirection()
{
	static const char* const names[] = {
		"Horizontal",
		"Vertical",
		nullptr};
	return names;
}

inline const char* EnumNameAxisDirection(AxisDirection e)
{
	const size_t index = static_cast<int>(e);
	return EnumNamesAxisDirection()[index];
}

enum VerticalDirection
{
	VerticalDirection_BottomToTop = 0,
	VerticalDirection_TopToBottom = 1,
	VerticalDirection_MIN = VerticalDirection_BottomToTop,
	VerticalDirection_MAX = VerticalDirection_TopToBottom
};

inline const VerticalDirection (&EnumValuesVerticalDirection())[2]
{
	static const VerticalDirection values[] = {
		VerticalDirection_BottomToTop,
		VerticalDirection_TopToBottom};
	return values;
}

inline const char* const* EnumNamesVerticalDirection()
{
	static const char* const names[] = {
		"BottomToTop",
		"TopToBottom",
		nullptr};
	return names;
}

inline const char* EnumNameVerticalDirection(VerticalDirection e)
{
	const size_t index = static_cast<int>(e);
	return EnumNamesVerticalDirection()[index];
}

enum HorizontalDirection
{
	HorizontalDirection_LeftToRight = 0,
	HorizontalDirection_RightToLeft = 1,
	HorizontalDirection_MIN = HorizontalDirection_LeftToRight,
	HorizontalDirection_MAX = HorizontalDirection_RightToLeft
};

inline const HorizontalDirection (&EnumValuesHorizontalDirection())[2]
{
	static const HorizontalDirection values[] = {
		HorizontalDirection_LeftToRight,
		HorizontalDirection_RightToLeft};
	return values;
}

inline const char* const* EnumNamesHorizontalDirection()
{
	static const char* const names[] = {
		"LeftToRight",
		"RightToLeft",
		nullptr};
	return names;
}

inline const char* EnumNameHorizontalDirection(HorizontalDirection e)
{
	const size_t index = static_cast<int>(e);
	return EnumNamesHorizontalDirection()[index];
}

enum AnyNode
{
	AnyNode_NONE = 0,
	AnyNode_Scene = 1,
	AnyNode_Sprite = 2,
	AnyNode_Label = 3,
	AnyNode_Particle = 4,
	AnyNode_TileMap = 5,
	AnyNode_Node = 6,
	AnyNode_Button = 7,
	AnyNode_ProgressBar = 8,
	AnyNode_ScrollView = 9,
	AnyNode_CreatorScene = 10,
	AnyNode_EditBox = 11,
	AnyNode_RichText = 12,
	AnyNode_SpineSkeleton = 13,
	AnyNode_VideoPlayer = 14,
	AnyNode_WebView = 15,
	AnyNode_Slider = 16,
	AnyNode_Toggle = 17,
	AnyNode_ToggleGroup = 18,
	AnyNode_PageView = 19,
	AnyNode_Mask = 20,
	AnyNode_DragonBones = 21,
	AnyNode_MotionStreak = 22,
	AnyNode_Prefab = 23,
	AnyNode_Layout = 24,
	AnyNode_MIN = AnyNode_NONE,
	AnyNode_MAX = AnyNode_Layout
};

inline const AnyNode (&EnumValuesAnyNode())[25]
{
	static const AnyNode values[] = {
		AnyNode_NONE,
		AnyNode_Scene,
		AnyNode_Sprite,
		AnyNode_Label,
		AnyNode_Particle,
		AnyNode_TileMap,
		AnyNode_Node,
		AnyNode_Button,
		AnyNode_ProgressBar,
		AnyNode_ScrollView,
		AnyNode_CreatorScene,
		AnyNode_EditBox,
		AnyNode_RichText,
		AnyNode_SpineSkeleton,
		AnyNode_VideoPlayer,
		AnyNode_WebView,
		AnyNode_Slider,
		AnyNode_Toggle,
		AnyNode_ToggleGroup,
		AnyNode_PageView,
		AnyNode_Mask,
		AnyNode_DragonBones,
		AnyNode_MotionStreak,
		AnyNode_Prefab,
		AnyNode_Layout};
	return values;
}

inline const char* const* EnumNamesAnyNode()
{
	static const char* const names[] = {
		"NONE",
		"Scene",
		"Sprite",
		"Label",
		"Particle",
		"TileMap",
		"Node",
		"Button",
		"ProgressBar",
		"ScrollView",
		"CreatorScene",
		"EditBox",
		"RichText",
		"SpineSkeleton",
		"VideoPlayer",
		"WebView",
		"Slider",
		"Toggle",
		"ToggleGroup",
		"PageView",
		"Mask",
		"DragonBones",
		"MotionStreak",
		"Prefab",
		"Layout",
		nullptr};
	return names;
}

inline const char* EnumNameAnyNode(AnyNode e)
{
	const size_t index = static_cast<int>(e);
	return EnumNamesAnyNode()[index];
}

template <typename T>
struct AnyNodeTraits
{
	static const AnyNode enum_value = AnyNode_NONE;
};

template <>
struct AnyNodeTraits<Scene>
{
	static const AnyNode enum_value = AnyNode_Scene;
};

template <>
struct AnyNodeTraits<Sprite>
{
	static const AnyNode enum_value = AnyNode_Sprite;
};

template <>
struct AnyNodeTraits<Label>
{
	static const AnyNode enum_value = AnyNode_Label;
};

template <>
struct AnyNodeTraits<Particle>
{
	static const AnyNode enum_value = AnyNode_Particle;
};

template <>
struct AnyNodeTraits<TileMap>
{
	static const AnyNode enum_value = AnyNode_TileMap;
};

template <>
struct AnyNodeTraits<Node>
{
	static const AnyNode enum_value = AnyNode_Node;
};

template <>
struct AnyNodeTraits<Button>
{
	static const AnyNode enum_value = AnyNode_Button;
};

template <>
struct AnyNodeTraits<ProgressBar>
{
	static const AnyNode enum_value = AnyNode_ProgressBar;
};

template <>
struct AnyNodeTraits<ScrollView>
{
	static const AnyNode enum_value = AnyNode_ScrollView;
};

template <>
struct AnyNodeTraits<CreatorScene>
{
	static const AnyNode enum_value = AnyNode_CreatorScene;
};

template <>
struct AnyNodeTraits<EditBox>
{
	static const AnyNode enum_value = AnyNode_EditBox;
};

template <>
struct AnyNodeTraits<RichText>
{
	static const AnyNode enum_value = AnyNode_RichText;
};

template <>
struct AnyNodeTraits<SpineSkeleton>
{
	static const AnyNode enum_value = AnyNode_SpineSkeleton;
};

template <>
struct AnyNodeTraits<VideoPlayer>
{
	static const AnyNode enum_value = AnyNode_VideoPlayer;
};

template <>
struct AnyNodeTraits<WebView>
{
	static const AnyNode enum_value = AnyNode_WebView;
};

template <>
struct AnyNodeTraits<Slider>
{
	static const AnyNode enum_value = AnyNode_Slider;
};

template <>
struct AnyNodeTraits<Toggle>
{
	static const AnyNode enum_value = AnyNode_Toggle;
};

template <>
struct AnyNodeTraits<ToggleGroup>
{
	static const AnyNode enum_value = AnyNode_ToggleGroup;
};

template <>
struct AnyNodeTraits<PageView>
{
	static const AnyNode enum_value = AnyNode_PageView;
};

template <>
struct AnyNodeTraits<Mask>
{
	static const AnyNode enum_value = AnyNode_Mask;
};

template <>
struct AnyNodeTraits<DragonBones>
{
	static const AnyNode enum_value = AnyNode_DragonBones;
};

template <>
struct AnyNodeTraits<MotionStreak>
{
	static const AnyNode enum_value = AnyNode_MotionStreak;
};

template <>
struct AnyNodeTraits<Prefab>
{
	static const AnyNode enum_value = AnyNode_Prefab;
};

template <>
struct AnyNodeTraits<Layout>
{
	static const AnyNode enum_value = AnyNode_Layout;
};

bool VerifyAnyNode(flatbuffers::Verifier& verifier, const void* obj, AnyNode type);
bool VerifyAnyNodeVector(flatbuffers::Verifier& verifier, const flatbuffers::Vector<flatbuffers::Offset<void>>* values, const flatbuffers::Vector<uint8_t>* types);

enum AnimWrapMode
{
	AnimWrapMode_Default = 0,
	AnimWrapMode_Normal = 1,
	AnimWrapMode_Loop = 2,
	AnimWrapMode_PingPong = 22,
	AnimWrapMode_Reverse = 36,
	AnimWrapMode_LoopReverse = 38,
	AnimWrapMode_PingPongReverse = 54,
	AnimWrapMode_MIN = AnimWrapMode_Default,
	AnimWrapMode_MAX = AnimWrapMode_PingPongReverse
};

inline const AnimWrapMode (&EnumValuesAnimWrapMode())[7]
{
	static const AnimWrapMode values[] = {
		AnimWrapMode_Default,
		AnimWrapMode_Normal,
		AnimWrapMode_Loop,
		AnimWrapMode_PingPong,
		AnimWrapMode_Reverse,
		AnimWrapMode_LoopReverse,
		AnimWrapMode_PingPongReverse};
	return values;
}

inline const char* EnumNameAnimWrapMode(AnimWrapMode e)
{
	switch (e)
	{
	case AnimWrapMode_Default: return "Default";
	case AnimWrapMode_Normal: return "Normal";
	case AnimWrapMode_Loop: return "Loop";
	case AnimWrapMode_PingPong: return "PingPong";
	case AnimWrapMode_Reverse: return "Reverse";
	case AnimWrapMode_LoopReverse: return "LoopReverse";
	case AnimWrapMode_PingPongReverse: return "PingPongReverse";
	default: return "";
	}
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4)
Vec2 FLATBUFFERS_FINAL_CLASS
{
	private:
	float x_;
	float y_;

	public:
	Vec2()
	{
		memset(this, 0, sizeof(Vec2));
	}
	Vec2(float _x, float _y) :
		x_(flatbuffers::EndianScalar(_x)),
		y_(flatbuffers::EndianScalar(_y))
	{
	}
	float x() const
	{
		return flatbuffers::EndianScalar(x_);
	}
	float y() const
	{
		return flatbuffers::EndianScalar(y_);
	}
};
FLATBUFFERS_STRUCT_END(Vec2, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4)
Vec3 FLATBUFFERS_FINAL_CLASS
{
	private:
	float x_;
	float y_;
	float z_;

	public:
	Vec3()
	{
		memset(this, 0, sizeof(Vec3));
	}
	Vec3(float _x, float _y, float _z) :
		x_(flatbuffers::EndianScalar(_x)),
		y_(flatbuffers::EndianScalar(_y)),
		z_(flatbuffers::EndianScalar(_z))
	{
	}
	float x() const
	{
		return flatbuffers::EndianScalar(x_);
	}
	float y() const
	{
		return flatbuffers::EndianScalar(y_);
	}
	float z() const
	{
		return flatbuffers::EndianScalar(z_);
	}
};
FLATBUFFERS_STRUCT_END(Vec3, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4)
Size FLATBUFFERS_FINAL_CLASS
{
	private:
	float w_;
	float h_;

	public:
	Size()
	{
		memset(this, 0, sizeof(Size));
	}
	Size(float _w, float _h) :
		w_(flatbuffers::EndianScalar(_w)),
		h_(flatbuffers::EndianScalar(_h))
	{
	}
	float w() const
	{
		return flatbuffers::EndianScalar(w_);
	}
	float h() const
	{
		return flatbuffers::EndianScalar(h_);
	}
};
FLATBUFFERS_STRUCT_END(Size, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4)
Rect FLATBUFFERS_FINAL_CLASS
{
	private:
	float x_;
	float y_;
	float w_;
	float h_;

	public:
	Rect()
	{
		memset(this, 0, sizeof(Rect));
	}
	Rect(float _x, float _y, float _w, float _h) :
		x_(flatbuffers::EndianScalar(_x)),
		y_(flatbuffers::EndianScalar(_y)),
		w_(flatbuffers::EndianScalar(_w)),
		h_(flatbuffers::EndianScalar(_h))
	{
	}
	float x() const
	{
		return flatbuffers::EndianScalar(x_);
	}
	float y() const
	{
		return flatbuffers::EndianScalar(y_);
	}
	float w() const
	{
		return flatbuffers::EndianScalar(w_);
	}
	float h() const
	{
		return flatbuffers::EndianScalar(h_);
	}
};
FLATBUFFERS_STRUCT_END(Rect, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1)
ColorRGB FLATBUFFERS_FINAL_CLASS
{
	private:
	uint8_t r_;
	uint8_t g_;
	uint8_t b_;

	public:
	ColorRGB()
	{
		memset(this, 0, sizeof(ColorRGB));
	}
	ColorRGB(uint8_t _r, uint8_t _g, uint8_t _b) :
		r_(flatbuffers::EndianScalar(_r)),
		g_(flatbuffers::EndianScalar(_g)),
		b_(flatbuffers::EndianScalar(_b))
	{
	}
	uint8_t r() const
	{
		return flatbuffers::EndianScalar(r_);
	}
	uint8_t g() const
	{
		return flatbuffers::EndianScalar(g_);
	}
	uint8_t b() const
	{
		return flatbuffers::EndianScalar(b_);
	}
};
FLATBUFFERS_STRUCT_END(ColorRGB, 3);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1)
ColorRGBA FLATBUFFERS_FINAL_CLASS
{
	private:
	uint8_t r_;
	uint8_t g_;
	uint8_t b_;
	uint8_t a_;

	public:
	ColorRGBA()
	{
		memset(this, 0, sizeof(ColorRGBA));
	}
	ColorRGBA(uint8_t _r, uint8_t _g, uint8_t _b, uint8_t _a) :
		r_(flatbuffers::EndianScalar(_r)),
		g_(flatbuffers::EndianScalar(_g)),
		b_(flatbuffers::EndianScalar(_b)),
		a_(flatbuffers::EndianScalar(_a))
	{
	}
	uint8_t r() const
	{
		return flatbuffers::EndianScalar(r_);
	}
	uint8_t g() const
	{
		return flatbuffers::EndianScalar(g_);
	}
	uint8_t b() const
	{
		return flatbuffers::EndianScalar(b_);
	}
	uint8_t a() const
	{
		return flatbuffers::EndianScalar(a_);
	}
};
FLATBUFFERS_STRUCT_END(ColorRGBA, 4);

struct NodeGraph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_VERSION = 4,
		VT_ROOT = 6,
		VT_DESIGNRESOLUTION = 8,
		VT_RESOLUTIONFITWIDTH = 10,
		VT_RESOLUTIONFITHEIGHT = 12,
		VT_SPRITEFRAMES = 14,
		VT_COLLISIONMATRIX = 16
	};
	const flatbuffers::String* version() const
	{
		return GetPointer<const flatbuffers::String*>(VT_VERSION);
	}
	const NodeTree* root() const
	{
		return GetPointer<const NodeTree*>(VT_ROOT);
	}
	const Size* designResolution() const
	{
		return GetStruct<const Size*>(VT_DESIGNRESOLUTION);
	}
	bool resolutionFitWidth() const
	{
		return GetField<uint8_t>(VT_RESOLUTIONFITWIDTH, 0) != 0;
	}
	bool resolutionFitHeight() const
	{
		return GetField<uint8_t>(VT_RESOLUTIONFITHEIGHT, 0) != 0;
	}
	const flatbuffers::Vector<flatbuffers::Offset<SpriteFrame>>* spriteFrames() const
	{
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SpriteFrame>>*>(VT_SPRITEFRAMES);
	}
	const flatbuffers::Vector<flatbuffers::Offset<CollisionLine>>* collisionMatrix() const
	{
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CollisionLine>>*>(VT_COLLISIONMATRIX);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyOffset(verifier, VT_VERSION) &&
			   verifier.VerifyString(version()) &&
			   VerifyOffset(verifier, VT_ROOT) &&
			   verifier.VerifyTable(root()) &&
			   VerifyField<Size>(verifier, VT_DESIGNRESOLUTION) &&
			   VerifyField<uint8_t>(verifier, VT_RESOLUTIONFITWIDTH) &&
			   VerifyField<uint8_t>(verifier, VT_RESOLUTIONFITHEIGHT) &&
			   VerifyOffset(verifier, VT_SPRITEFRAMES) &&
			   verifier.VerifyVector(spriteFrames()) &&
			   verifier.VerifyVectorOfTables(spriteFrames()) &&
			   VerifyOffset(verifier, VT_COLLISIONMATRIX) &&
			   verifier.VerifyVector(collisionMatrix()) &&
			   verifier.VerifyVectorOfTables(collisionMatrix()) &&
			   verifier.EndTable();
	}
};

struct NodeGraphBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_version(flatbuffers::Offset<flatbuffers::String> version)
	{
		fbb_.AddOffset(NodeGraph::VT_VERSION, version);
	}
	void add_root(flatbuffers::Offset<NodeTree> root)
	{
		fbb_.AddOffset(NodeGraph::VT_ROOT, root);
	}
	void add_designResolution(const Size* designResolution)
	{
		fbb_.AddStruct(NodeGraph::VT_DESIGNRESOLUTION, designResolution);
	}
	void add_resolutionFitWidth(bool resolutionFitWidth)
	{
		fbb_.AddElement<uint8_t>(NodeGraph::VT_RESOLUTIONFITWIDTH, static_cast<uint8_t>(resolutionFitWidth), 0);
	}
	void add_resolutionFitHeight(bool resolutionFitHeight)
	{
		fbb_.AddElement<uint8_t>(NodeGraph::VT_RESOLUTIONFITHEIGHT, static_cast<uint8_t>(resolutionFitHeight), 0);
	}
	void add_spriteFrames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SpriteFrame>>> spriteFrames)
	{
		fbb_.AddOffset(NodeGraph::VT_SPRITEFRAMES, spriteFrames);
	}
	void add_collisionMatrix(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CollisionLine>>> collisionMatrix)
	{
		fbb_.AddOffset(NodeGraph::VT_COLLISIONMATRIX, collisionMatrix);
	}
	explicit NodeGraphBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	NodeGraphBuilder& operator=(const NodeGraphBuilder&);
	flatbuffers::Offset<NodeGraph> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<NodeGraph>(end);
		return o;
	}
};

inline flatbuffers::Offset<NodeGraph> CreateNodeGraph(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<flatbuffers::String> version = 0,
	flatbuffers::Offset<NodeTree> root = 0,
	const Size* designResolution = 0,
	bool resolutionFitWidth = false,
	bool resolutionFitHeight = false,
	flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SpriteFrame>>> spriteFrames = 0,
	flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CollisionLine>>> collisionMatrix = 0)
{
	NodeGraphBuilder builder_(_fbb);
	builder_.add_collisionMatrix(collisionMatrix);
	builder_.add_spriteFrames(spriteFrames);
	builder_.add_designResolution(designResolution);
	builder_.add_root(root);
	builder_.add_version(version);
	builder_.add_resolutionFitHeight(resolutionFitHeight);
	builder_.add_resolutionFitWidth(resolutionFitWidth);
	return builder_.Finish();
}

inline flatbuffers::Offset<NodeGraph> CreateNodeGraphDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	const char* version = nullptr,
	flatbuffers::Offset<NodeTree> root = 0,
	const Size* designResolution = 0,
	bool resolutionFitWidth = false,
	bool resolutionFitHeight = false,
	const std::vector<flatbuffers::Offset<SpriteFrame>>* spriteFrames = nullptr,
	const std::vector<flatbuffers::Offset<CollisionLine>>* collisionMatrix = nullptr)
{
	return creator::buffers::CreateNodeGraph(
		_fbb,
		version ? _fbb.CreateString(version) : 0,
		root,
		designResolution,
		resolutionFitWidth,
		resolutionFitHeight,
		spriteFrames ? _fbb.CreateVector<flatbuffers::Offset<SpriteFrame>>(*spriteFrames) : 0,
		collisionMatrix ? _fbb.CreateVector<flatbuffers::Offset<CollisionLine>>(*collisionMatrix) : 0);
}

struct CollisionLine FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_VALUE = 4
	};
	const flatbuffers::Vector<uint8_t>* value() const
	{
		return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_VALUE);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyOffset(verifier, VT_VALUE) &&
			   verifier.VerifyVector(value()) &&
			   verifier.EndTable();
	}
};

struct CollisionLineBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_value(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value)
	{
		fbb_.AddOffset(CollisionLine::VT_VALUE, value);
	}
	explicit CollisionLineBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	CollisionLineBuilder& operator=(const CollisionLineBuilder&);
	flatbuffers::Offset<CollisionLine> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<CollisionLine>(end);
		return o;
	}
};

inline flatbuffers::Offset<CollisionLine> CreateCollisionLine(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value = 0)
{
	CollisionLineBuilder builder_(_fbb);
	builder_.add_value(value);
	return builder_.Finish();
}

inline flatbuffers::Offset<CollisionLine> CreateCollisionLineDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	const std::vector<uint8_t>* value = nullptr)
{
	return creator::buffers::CreateCollisionLine(
		_fbb,
		value ? _fbb.CreateVector<uint8_t>(*value) : 0);
}

struct NodeTree FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_CHILDREN = 4,
		VT_OBJECT_TYPE = 6,
		VT_OBJECT = 8
	};
	const flatbuffers::Vector<flatbuffers::Offset<NodeTree>>* children() const
	{
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<NodeTree>>*>(VT_CHILDREN);
	}
	AnyNode object_type() const
	{
		return static_cast<AnyNode>(GetField<uint8_t>(VT_OBJECT_TYPE, 0));
	}
	const void* object() const
	{
		return GetPointer<const void*>(VT_OBJECT);
	}
	template <typename T>
	const T* object_as() const;
	const Scene* object_as_Scene() const
	{
		return object_type() == AnyNode_Scene ? static_cast<const Scene*>(object()) : nullptr;
	}
	const Sprite* object_as_Sprite() const
	{
		return object_type() == AnyNode_Sprite ? static_cast<const Sprite*>(object()) : nullptr;
	}
	const Label* object_as_Label() const
	{
		return object_type() == AnyNode_Label ? static_cast<const Label*>(object()) : nullptr;
	}
	const Particle* object_as_Particle() const
	{
		return object_type() == AnyNode_Particle ? static_cast<const Particle*>(object()) : nullptr;
	}
	const TileMap* object_as_TileMap() const
	{
		return object_type() == AnyNode_TileMap ? static_cast<const TileMap*>(object()) : nullptr;
	}
	const Node* object_as_Node() const
	{
		return object_type() == AnyNode_Node ? static_cast<const Node*>(object()) : nullptr;
	}
	const Button* object_as_Button() const
	{
		return object_type() == AnyNode_Button ? static_cast<const Button*>(object()) : nullptr;
	}
	const ProgressBar* object_as_ProgressBar() const
	{
		return object_type() == AnyNode_ProgressBar ? static_cast<const ProgressBar*>(object()) : nullptr;
	}
	const ScrollView* object_as_ScrollView() const
	{
		return object_type() == AnyNode_ScrollView ? static_cast<const ScrollView*>(object()) : nullptr;
	}
	const CreatorScene* object_as_CreatorScene() const
	{
		return object_type() == AnyNode_CreatorScene ? static_cast<const CreatorScene*>(object()) : nullptr;
	}
	const EditBox* object_as_EditBox() const
	{
		return object_type() == AnyNode_EditBox ? static_cast<const EditBox*>(object()) : nullptr;
	}
	const RichText* object_as_RichText() const
	{
		return object_type() == AnyNode_RichText ? static_cast<const RichText*>(object()) : nullptr;
	}
	const SpineSkeleton* object_as_SpineSkeleton() const
	{
		return object_type() == AnyNode_SpineSkeleton ? static_cast<const SpineSkeleton*>(object()) : nullptr;
	}
	const VideoPlayer* object_as_VideoPlayer() const
	{
		return object_type() == AnyNode_VideoPlayer ? static_cast<const VideoPlayer*>(object()) : nullptr;
	}
	const WebView* object_as_WebView() const
	{
		return object_type() == AnyNode_WebView ? static_cast<const WebView*>(object()) : nullptr;
	}
	const Slider* object_as_Slider() const
	{
		return object_type() == AnyNode_Slider ? static_cast<const Slider*>(object()) : nullptr;
	}
	const Toggle* object_as_Toggle() const
	{
		return object_type() == AnyNode_Toggle ? static_cast<const Toggle*>(object()) : nullptr;
	}
	const ToggleGroup* object_as_ToggleGroup() const
	{
		return object_type() == AnyNode_ToggleGroup ? static_cast<const ToggleGroup*>(object()) : nullptr;
	}
	const PageView* object_as_PageView() const
	{
		return object_type() == AnyNode_PageView ? static_cast<const PageView*>(object()) : nullptr;
	}
	const Mask* object_as_Mask() const
	{
		return object_type() == AnyNode_Mask ? static_cast<const Mask*>(object()) : nullptr;
	}
	const DragonBones* object_as_DragonBones() const
	{
		return object_type() == AnyNode_DragonBones ? static_cast<const DragonBones*>(object()) : nullptr;
	}
	const MotionStreak* object_as_MotionStreak() const
	{
		return object_type() == AnyNode_MotionStreak ? static_cast<const MotionStreak*>(object()) : nullptr;
	}
	const Prefab* object_as_Prefab() const
	{
		return object_type() == AnyNode_Prefab ? static_cast<const Prefab*>(object()) : nullptr;
	}
	const Layout* object_as_Layout() const
	{
		return object_type() == AnyNode_Layout ? static_cast<const Layout*>(object()) : nullptr;
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyOffset(verifier, VT_CHILDREN) &&
			   verifier.VerifyVector(children()) &&
			   verifier.VerifyVectorOfTables(children()) &&
			   VerifyField<uint8_t>(verifier, VT_OBJECT_TYPE) &&
			   VerifyOffset(verifier, VT_OBJECT) &&
			   VerifyAnyNode(verifier, object(), object_type()) &&
			   verifier.EndTable();
	}
};

template <>
inline const Scene* NodeTree::object_as<Scene>() const
{
	return object_as_Scene();
}

template <>
inline const Sprite* NodeTree::object_as<Sprite>() const
{
	return object_as_Sprite();
}

template <>
inline const Label* NodeTree::object_as<Label>() const
{
	return object_as_Label();
}

template <>
inline const Particle* NodeTree::object_as<Particle>() const
{
	return object_as_Particle();
}

template <>
inline const TileMap* NodeTree::object_as<TileMap>() const
{
	return object_as_TileMap();
}

template <>
inline const Node* NodeTree::object_as<Node>() const
{
	return object_as_Node();
}

template <>
inline const Button* NodeTree::object_as<Button>() const
{
	return object_as_Button();
}

template <>
inline const ProgressBar* NodeTree::object_as<ProgressBar>() const
{
	return object_as_ProgressBar();
}

template <>
inline const ScrollView* NodeTree::object_as<ScrollView>() const
{
	return object_as_ScrollView();
}

template <>
inline const CreatorScene* NodeTree::object_as<CreatorScene>() const
{
	return object_as_CreatorScene();
}

template <>
inline const EditBox* NodeTree::object_as<EditBox>() const
{
	return object_as_EditBox();
}

template <>
inline const RichText* NodeTree::object_as<RichText>() const
{
	return object_as_RichText();
}

template <>
inline const SpineSkeleton* NodeTree::object_as<SpineSkeleton>() const
{
	return object_as_SpineSkeleton();
}

template <>
inline const VideoPlayer* NodeTree::object_as<VideoPlayer>() const
{
	return object_as_VideoPlayer();
}

template <>
inline const WebView* NodeTree::object_as<WebView>() const
{
	return object_as_WebView();
}

template <>
inline const Slider* NodeTree::object_as<Slider>() const
{
	return object_as_Slider();
}

template <>
inline const Toggle* NodeTree::object_as<Toggle>() const
{
	return object_as_Toggle();
}

template <>
inline const ToggleGroup* NodeTree::object_as<ToggleGroup>() const
{
	return object_as_ToggleGroup();
}

template <>
inline const PageView* NodeTree::object_as<PageView>() const
{
	return object_as_PageView();
}

template <>
inline const Mask* NodeTree::object_as<Mask>() const
{
	return object_as_Mask();
}

template <>
inline const DragonBones* NodeTree::object_as<DragonBones>() const
{
	return object_as_DragonBones();
}

template <>
inline const MotionStreak* NodeTree::object_as<MotionStreak>() const
{
	return object_as_MotionStreak();
}

template <>
inline const Prefab* NodeTree::object_as<Prefab>() const
{
	return object_as_Prefab();
}

template <>
inline const Layout* NodeTree::object_as<Layout>() const
{
	return object_as_Layout();
}

struct NodeTreeBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_children(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NodeTree>>> children)
	{
		fbb_.AddOffset(NodeTree::VT_CHILDREN, children);
	}
	void add_object_type(AnyNode object_type)
	{
		fbb_.AddElement<uint8_t>(NodeTree::VT_OBJECT_TYPE, static_cast<uint8_t>(object_type), 0);
	}
	void add_object(flatbuffers::Offset<void> object)
	{
		fbb_.AddOffset(NodeTree::VT_OBJECT, object);
	}
	explicit NodeTreeBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	NodeTreeBuilder& operator=(const NodeTreeBuilder&);
	flatbuffers::Offset<NodeTree> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<NodeTree>(end);
		return o;
	}
};

inline flatbuffers::Offset<NodeTree> CreateNodeTree(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NodeTree>>> children = 0,
	AnyNode object_type = AnyNode_NONE,
	flatbuffers::Offset<void> object = 0)
{
	NodeTreeBuilder builder_(_fbb);
	builder_.add_object(object);
	builder_.add_children(children);
	builder_.add_object_type(object_type);
	return builder_.Finish();
}

inline flatbuffers::Offset<NodeTree> CreateNodeTreeDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	const std::vector<flatbuffers::Offset<NodeTree>>* children = nullptr,
	AnyNode object_type = AnyNode_NONE,
	flatbuffers::Offset<void> object = 0)
{
	return creator::buffers::CreateNodeTree(
		_fbb,
		children ? _fbb.CreateVector<flatbuffers::Offset<NodeTree>>(*children) : 0,
		object_type,
		object);
}

struct SpriteFrame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_NAME = 4,
		VT_TEXTUREPATH = 6,
		VT_RECT = 8,
		VT_OFFSET = 10,
		VT_ROTATED = 12,
		VT_ORIGINALSIZE = 14,
		VT_CENTERRECT = 16,
		VT_ATLAS = 18
	};
	const flatbuffers::String* name() const
	{
		return GetPointer<const flatbuffers::String*>(VT_NAME);
	}
	const flatbuffers::String* texturePath() const
	{
		return GetPointer<const flatbuffers::String*>(VT_TEXTUREPATH);
	}
	const Rect* rect() const
	{
		return GetStruct<const Rect*>(VT_RECT);
	}
	const Vec2* offset() const
	{
		return GetStruct<const Vec2*>(VT_OFFSET);
	}
	bool rotated() const
	{
		return GetField<uint8_t>(VT_ROTATED, 0) != 0;
	}
	const Size* originalSize() const
	{
		return GetStruct<const Size*>(VT_ORIGINALSIZE);
	}
	const Rect* centerRect() const
	{
		return GetStruct<const Rect*>(VT_CENTERRECT);
	}
	bool atlas() const
	{
		return GetField<uint8_t>(VT_ATLAS, 0) != 0;
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyOffset(verifier, VT_NAME) &&
			   verifier.VerifyString(name()) &&
			   VerifyOffset(verifier, VT_TEXTUREPATH) &&
			   verifier.VerifyString(texturePath()) &&
			   VerifyField<Rect>(verifier, VT_RECT) &&
			   VerifyField<Vec2>(verifier, VT_OFFSET) &&
			   VerifyField<uint8_t>(verifier, VT_ROTATED) &&
			   VerifyField<Size>(verifier, VT_ORIGINALSIZE) &&
			   VerifyField<Rect>(verifier, VT_CENTERRECT) &&
			   VerifyField<uint8_t>(verifier, VT_ATLAS) &&
			   verifier.EndTable();
	}
};

struct SpriteFrameBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_name(flatbuffers::Offset<flatbuffers::String> name)
	{
		fbb_.AddOffset(SpriteFrame::VT_NAME, name);
	}
	void add_texturePath(flatbuffers::Offset<flatbuffers::String> texturePath)
	{
		fbb_.AddOffset(SpriteFrame::VT_TEXTUREPATH, texturePath);
	}
	void add_rect(const Rect* rect)
	{
		fbb_.AddStruct(SpriteFrame::VT_RECT, rect);
	}
	void add_offset(const Vec2* offset)
	{
		fbb_.AddStruct(SpriteFrame::VT_OFFSET, offset);
	}
	void add_rotated(bool rotated)
	{
		fbb_.AddElement<uint8_t>(SpriteFrame::VT_ROTATED, static_cast<uint8_t>(rotated), 0);
	}
	void add_originalSize(const Size* originalSize)
	{
		fbb_.AddStruct(SpriteFrame::VT_ORIGINALSIZE, originalSize);
	}
	void add_centerRect(const Rect* centerRect)
	{
		fbb_.AddStruct(SpriteFrame::VT_CENTERRECT, centerRect);
	}
	void add_atlas(bool atlas)
	{
		fbb_.AddElement<uint8_t>(SpriteFrame::VT_ATLAS, static_cast<uint8_t>(atlas), 0);
	}
	explicit SpriteFrameBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	SpriteFrameBuilder& operator=(const SpriteFrameBuilder&);
	flatbuffers::Offset<SpriteFrame> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<SpriteFrame>(end);
		return o;
	}
};

inline flatbuffers::Offset<SpriteFrame> CreateSpriteFrame(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<flatbuffers::String> name = 0,
	flatbuffers::Offset<flatbuffers::String> texturePath = 0,
	const Rect* rect = 0,
	const Vec2* offset = 0,
	bool rotated = false,
	const Size* originalSize = 0,
	const Rect* centerRect = 0,
	bool atlas = false)
{
	SpriteFrameBuilder builder_(_fbb);
	builder_.add_centerRect(centerRect);
	builder_.add_originalSize(originalSize);
	builder_.add_offset(offset);
	builder_.add_rect(rect);
	builder_.add_texturePath(texturePath);
	builder_.add_name(name);
	builder_.add_atlas(atlas);
	builder_.add_rotated(rotated);
	return builder_.Finish();
}

inline flatbuffers::Offset<SpriteFrame> CreateSpriteFrameDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	const char* name = nullptr,
	const char* texturePath = nullptr,
	const Rect* rect = 0,
	const Vec2* offset = 0,
	bool rotated = false,
	const Size* originalSize = 0,
	const Rect* centerRect = 0,
	bool atlas = false)
{
	return creator::buffers::CreateSpriteFrame(
		_fbb,
		name ? _fbb.CreateString(name) : 0,
		texturePath ? _fbb.CreateString(texturePath) : 0,
		rect,
		offset,
		rotated,
		originalSize,
		centerRect,
		atlas);
}

struct CreatorScene FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_FILENAME = 4
	};
	const flatbuffers::String* filename() const
	{
		return GetPointer<const flatbuffers::String*>(VT_FILENAME);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyOffset(verifier, VT_FILENAME) &&
			   verifier.VerifyString(filename()) &&
			   verifier.EndTable();
	}
};

struct CreatorSceneBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_filename(flatbuffers::Offset<flatbuffers::String> filename)
	{
		fbb_.AddOffset(CreatorScene::VT_FILENAME, filename);
	}
	explicit CreatorSceneBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	CreatorSceneBuilder& operator=(const CreatorSceneBuilder&);
	flatbuffers::Offset<CreatorScene> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<CreatorScene>(end);
		return o;
	}
};

inline flatbuffers::Offset<CreatorScene> CreateCreatorScene(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<flatbuffers::String> filename = 0)
{
	CreatorSceneBuilder builder_(_fbb);
	builder_.add_filename(filename);
	return builder_.Finish();
}

inline flatbuffers::Offset<CreatorScene> CreateCreatorSceneDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	const char* filename = nullptr)
{
	return creator::buffers::CreateCreatorScene(
		_fbb,
		filename ? _fbb.CreateString(filename) : 0);
}

struct Node FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_CONTENTSIZE = 4,
		VT_ENABLED = 6,
		VT_NAME = 8,
		VT_ANCHORPOINT = 10,
		VT_CASCADEOPACITYENABLED = 12,
		VT_COLOR = 14,
		VT_GLOBALZORDER = 16,
		VT_LOCALZORDER = 18,
		VT_OPACITY = 20,
		VT_OPACITYMODIFYRGB = 22,
		VT_POSITION = 24,
		VT_ROTATIONSKEWX = 26,
		VT_ROTATIONSKEWY = 28,
		VT_SCALEX = 30,
		VT_SCALEY = 32,
		VT_SKEWX = 34,
		VT_SKEWY = 36,
		VT_TAG = 38,
		VT_ANIM = 40,
		VT_COLLIDERS = 42,
		VT_WIDGET = 44,
		VT_GROUPINDEX = 46
	};
	const Size* contentSize() const
	{
		return GetStruct<const Size*>(VT_CONTENTSIZE);
	}
	bool enabled() const
	{
		return GetField<uint8_t>(VT_ENABLED, 1) != 0;
	}
	const flatbuffers::String* name() const
	{
		return GetPointer<const flatbuffers::String*>(VT_NAME);
	}
	const Vec2* anchorPoint() const
	{
		return GetStruct<const Vec2*>(VT_ANCHORPOINT);
	}
	bool cascadeOpacityEnabled() const
	{
		return GetField<uint8_t>(VT_CASCADEOPACITYENABLED, 1) != 0;
	}
	const ColorRGB* color() const
	{
		return GetStruct<const ColorRGB*>(VT_COLOR);
	}
	float globalZOrder() const
	{
		return GetField<float>(VT_GLOBALZORDER, 0.0f);
	}
	int32_t localZOrder() const
	{
		return GetField<int32_t>(VT_LOCALZORDER, 0);
	}
	uint8_t opacity() const
	{
		return GetField<uint8_t>(VT_OPACITY, 255);
	}
	bool opacityModifyRGB() const
	{
		return GetField<uint8_t>(VT_OPACITYMODIFYRGB, 1) != 0;
	}
	const Vec2* position() const
	{
		return GetStruct<const Vec2*>(VT_POSITION);
	}
	float rotationSkewX() const
	{
		return GetField<float>(VT_ROTATIONSKEWX, 0.0f);
	}
	float rotationSkewY() const
	{
		return GetField<float>(VT_ROTATIONSKEWY, 0.0f);
	}
	float scaleX() const
	{
		return GetField<float>(VT_SCALEX, 1.0f);
	}
	float scaleY() const
	{
		return GetField<float>(VT_SCALEY, 1.0f);
	}
	float skewX() const
	{
		return GetField<float>(VT_SKEWX, 0.0f);
	}
	float skewY() const
	{
		return GetField<float>(VT_SKEWY, 0.0f);
	}
	int32_t tag() const
	{
		return GetField<int32_t>(VT_TAG, 0);
	}
	const AnimationRef* anim() const
	{
		return GetPointer<const AnimationRef*>(VT_ANIM);
	}
	const flatbuffers::Vector<flatbuffers::Offset<Collider>>* colliders() const
	{
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Collider>>*>(VT_COLLIDERS);
	}
	const Widget* widget() const
	{
		return GetPointer<const Widget*>(VT_WIDGET);
	}
	int32_t groupIndex() const
	{
		return GetField<int32_t>(VT_GROUPINDEX, 0);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyField<Size>(verifier, VT_CONTENTSIZE) &&
			   VerifyField<uint8_t>(verifier, VT_ENABLED) &&
			   VerifyOffset(verifier, VT_NAME) &&
			   verifier.VerifyString(name()) &&
			   VerifyField<Vec2>(verifier, VT_ANCHORPOINT) &&
			   VerifyField<uint8_t>(verifier, VT_CASCADEOPACITYENABLED) &&
			   VerifyField<ColorRGB>(verifier, VT_COLOR) &&
			   VerifyField<float>(verifier, VT_GLOBALZORDER) &&
			   VerifyField<int32_t>(verifier, VT_LOCALZORDER) &&
			   VerifyField<uint8_t>(verifier, VT_OPACITY) &&
			   VerifyField<uint8_t>(verifier, VT_OPACITYMODIFYRGB) &&
			   VerifyField<Vec2>(verifier, VT_POSITION) &&
			   VerifyField<float>(verifier, VT_ROTATIONSKEWX) &&
			   VerifyField<float>(verifier, VT_ROTATIONSKEWY) &&
			   VerifyField<float>(verifier, VT_SCALEX) &&
			   VerifyField<float>(verifier, VT_SCALEY) &&
			   VerifyField<float>(verifier, VT_SKEWX) &&
			   VerifyField<float>(verifier, VT_SKEWY) &&
			   VerifyField<int32_t>(verifier, VT_TAG) &&
			   VerifyOffset(verifier, VT_ANIM) &&
			   verifier.VerifyTable(anim()) &&
			   VerifyOffset(verifier, VT_COLLIDERS) &&
			   verifier.VerifyVector(colliders()) &&
			   verifier.VerifyVectorOfTables(colliders()) &&
			   VerifyOffset(verifier, VT_WIDGET) &&
			   verifier.VerifyTable(widget()) &&
			   VerifyField<int32_t>(verifier, VT_GROUPINDEX) &&
			   verifier.EndTable();
	}
};

struct NodeBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_contentSize(const Size* contentSize)
	{
		fbb_.AddStruct(Node::VT_CONTENTSIZE, contentSize);
	}
	void add_enabled(bool enabled)
	{
		fbb_.AddElement<uint8_t>(Node::VT_ENABLED, static_cast<uint8_t>(enabled), 1);
	}
	void add_name(flatbuffers::Offset<flatbuffers::String> name)
	{
		fbb_.AddOffset(Node::VT_NAME, name);
	}
	void add_anchorPoint(const Vec2* anchorPoint)
	{
		fbb_.AddStruct(Node::VT_ANCHORPOINT, anchorPoint);
	}
	void add_cascadeOpacityEnabled(bool cascadeOpacityEnabled)
	{
		fbb_.AddElement<uint8_t>(Node::VT_CASCADEOPACITYENABLED, static_cast<uint8_t>(cascadeOpacityEnabled), 1);
	}
	void add_color(const ColorRGB* color)
	{
		fbb_.AddStruct(Node::VT_COLOR, color);
	}
	void add_globalZOrder(float globalZOrder)
	{
		fbb_.AddElement<float>(Node::VT_GLOBALZORDER, globalZOrder, 0.0f);
	}
	void add_localZOrder(int32_t localZOrder)
	{
		fbb_.AddElement<int32_t>(Node::VT_LOCALZORDER, localZOrder, 0);
	}
	void add_opacity(uint8_t opacity)
	{
		fbb_.AddElement<uint8_t>(Node::VT_OPACITY, opacity, 255);
	}
	void add_opacityModifyRGB(bool opacityModifyRGB)
	{
		fbb_.AddElement<uint8_t>(Node::VT_OPACITYMODIFYRGB, static_cast<uint8_t>(opacityModifyRGB), 1);
	}
	void add_position(const Vec2* position)
	{
		fbb_.AddStruct(Node::VT_POSITION, position);
	}
	void add_rotationSkewX(float rotationSkewX)
	{
		fbb_.AddElement<float>(Node::VT_ROTATIONSKEWX, rotationSkewX, 0.0f);
	}
	void add_rotationSkewY(float rotationSkewY)
	{
		fbb_.AddElement<float>(Node::VT_ROTATIONSKEWY, rotationSkewY, 0.0f);
	}
	void add_scaleX(float scaleX)
	{
		fbb_.AddElement<float>(Node::VT_SCALEX, scaleX, 1.0f);
	}
	void add_scaleY(float scaleY)
	{
		fbb_.AddElement<float>(Node::VT_SCALEY, scaleY, 1.0f);
	}
	void add_skewX(float skewX)
	{
		fbb_.AddElement<float>(Node::VT_SKEWX, skewX, 0.0f);
	}
	void add_skewY(float skewY)
	{
		fbb_.AddElement<float>(Node::VT_SKEWY, skewY, 0.0f);
	}
	void add_tag(int32_t tag)
	{
		fbb_.AddElement<int32_t>(Node::VT_TAG, tag, 0);
	}
	void add_anim(flatbuffers::Offset<AnimationRef> anim)
	{
		fbb_.AddOffset(Node::VT_ANIM, anim);
	}
	void add_colliders(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Collider>>> colliders)
	{
		fbb_.AddOffset(Node::VT_COLLIDERS, colliders);
	}
	void add_widget(flatbuffers::Offset<Widget> widget)
	{
		fbb_.AddOffset(Node::VT_WIDGET, widget);
	}
	void add_groupIndex(int32_t groupIndex)
	{
		fbb_.AddElement<int32_t>(Node::VT_GROUPINDEX, groupIndex, 0);
	}
	explicit NodeBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	NodeBuilder& operator=(const NodeBuilder&);
	flatbuffers::Offset<Node> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Node>(end);
		return o;
	}
};

inline flatbuffers::Offset<Node> CreateNode(
	flatbuffers::FlatBufferBuilder& _fbb,
	const Size* contentSize = 0,
	bool enabled = true,
	flatbuffers::Offset<flatbuffers::String> name = 0,
	const Vec2* anchorPoint = 0,
	bool cascadeOpacityEnabled = true,
	const ColorRGB* color = 0,
	float globalZOrder = 0.0f,
	int32_t localZOrder = 0,
	uint8_t opacity = 255,
	bool opacityModifyRGB = true,
	const Vec2* position = 0,
	float rotationSkewX = 0.0f,
	float rotationSkewY = 0.0f,
	float scaleX = 1.0f,
	float scaleY = 1.0f,
	float skewX = 0.0f,
	float skewY = 0.0f,
	int32_t tag = 0,
	flatbuffers::Offset<AnimationRef> anim = 0,
	flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Collider>>> colliders = 0,
	flatbuffers::Offset<Widget> widget = 0,
	int32_t groupIndex = 0)
{
	NodeBuilder builder_(_fbb);
	builder_.add_groupIndex(groupIndex);
	builder_.add_widget(widget);
	builder_.add_colliders(colliders);
	builder_.add_anim(anim);
	builder_.add_tag(tag);
	builder_.add_skewY(skewY);
	builder_.add_skewX(skewX);
	builder_.add_scaleY(scaleY);
	builder_.add_scaleX(scaleX);
	builder_.add_rotationSkewY(rotationSkewY);
	builder_.add_rotationSkewX(rotationSkewX);
	builder_.add_position(position);
	builder_.add_localZOrder(localZOrder);
	builder_.add_globalZOrder(globalZOrder);
	builder_.add_color(color);
	builder_.add_anchorPoint(anchorPoint);
	builder_.add_name(name);
	builder_.add_contentSize(contentSize);
	builder_.add_opacityModifyRGB(opacityModifyRGB);
	builder_.add_opacity(opacity);
	builder_.add_cascadeOpacityEnabled(cascadeOpacityEnabled);
	builder_.add_enabled(enabled);
	return builder_.Finish();
}

inline flatbuffers::Offset<Node> CreateNodeDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	const Size* contentSize = 0,
	bool enabled = true,
	const char* name = nullptr,
	const Vec2* anchorPoint = 0,
	bool cascadeOpacityEnabled = true,
	const ColorRGB* color = 0,
	float globalZOrder = 0.0f,
	int32_t localZOrder = 0,
	uint8_t opacity = 255,
	bool opacityModifyRGB = true,
	const Vec2* position = 0,
	float rotationSkewX = 0.0f,
	float rotationSkewY = 0.0f,
	float scaleX = 1.0f,
	float scaleY = 1.0f,
	float skewX = 0.0f,
	float skewY = 0.0f,
	int32_t tag = 0,
	flatbuffers::Offset<AnimationRef> anim = 0,
	const std::vector<flatbuffers::Offset<Collider>>* colliders = nullptr,
	flatbuffers::Offset<Widget> widget = 0,
	int32_t groupIndex = 0)
{
	return creator::buffers::CreateNode(
		_fbb,
		contentSize,
		enabled,
		name ? _fbb.CreateString(name) : 0,
		anchorPoint,
		cascadeOpacityEnabled,
		color,
		globalZOrder,
		localZOrder,
		opacity,
		opacityModifyRGB,
		position,
		rotationSkewX,
		rotationSkewY,
		scaleX,
		scaleY,
		skewX,
		skewY,
		tag,
		anim,
		colliders ? _fbb.CreateVector<flatbuffers::Offset<Collider>>(*colliders) : 0,
		widget,
		groupIndex);
}

struct Sprite FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_NODE = 4,
		VT_SPRITEFRAMENAME = 6,
		VT_SPRITETYPE = 8,
		VT_SRCBLEND = 10,
		VT_DSTBLEND = 12,
		VT_TRIMENABLED = 14,
		VT_SIZEMODE = 16,
		VT_FILLTYPE = 18,
		VT_FILLCENTER = 20,
		VT_FILLSTART = 22,
		VT_FILLRANGE = 24
	};
	const Node* node() const
	{
		return GetPointer<const Node*>(VT_NODE);
	}
	const flatbuffers::String* spriteFrameName() const
	{
		return GetPointer<const flatbuffers::String*>(VT_SPRITEFRAMENAME);
	}
	SpriteType spriteType() const
	{
		return static_cast<SpriteType>(GetField<int8_t>(VT_SPRITETYPE, 0));
	}
	int32_t srcBlend() const
	{
		return GetField<int32_t>(VT_SRCBLEND, 770);
	}
	int32_t dstBlend() const
	{
		return GetField<int32_t>(VT_DSTBLEND, 771);
	}
	bool trimEnabled() const
	{
		return GetField<uint8_t>(VT_TRIMENABLED, 0) != 0;
	}
	SpriteSizeMode sizeMode() const
	{
		return static_cast<SpriteSizeMode>(GetField<int8_t>(VT_SIZEMODE, 0));
	}
	SpriteFillType fillType() const
	{
		return static_cast<SpriteFillType>(GetField<int8_t>(VT_FILLTYPE, 0));
	}
	const Vec2* fillCenter() const
	{
		return GetStruct<const Vec2*>(VT_FILLCENTER);
	}
	float fillStart() const
	{
		return GetField<float>(VT_FILLSTART, 0.0f);
	}
	float fillRange() const
	{
		return GetField<float>(VT_FILLRANGE, 0.0f);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyOffset(verifier, VT_NODE) &&
			   verifier.VerifyTable(node()) &&
			   VerifyOffset(verifier, VT_SPRITEFRAMENAME) &&
			   verifier.VerifyString(spriteFrameName()) &&
			   VerifyField<int8_t>(verifier, VT_SPRITETYPE) &&
			   VerifyField<int32_t>(verifier, VT_SRCBLEND) &&
			   VerifyField<int32_t>(verifier, VT_DSTBLEND) &&
			   VerifyField<uint8_t>(verifier, VT_TRIMENABLED) &&
			   VerifyField<int8_t>(verifier, VT_SIZEMODE) &&
			   VerifyField<int8_t>(verifier, VT_FILLTYPE) &&
			   VerifyField<Vec2>(verifier, VT_FILLCENTER) &&
			   VerifyField<float>(verifier, VT_FILLSTART) &&
			   VerifyField<float>(verifier, VT_FILLRANGE) &&
			   verifier.EndTable();
	}
};

struct SpriteBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_node(flatbuffers::Offset<Node> node)
	{
		fbb_.AddOffset(Sprite::VT_NODE, node);
	}
	void add_spriteFrameName(flatbuffers::Offset<flatbuffers::String> spriteFrameName)
	{
		fbb_.AddOffset(Sprite::VT_SPRITEFRAMENAME, spriteFrameName);
	}
	void add_spriteType(SpriteType spriteType)
	{
		fbb_.AddElement<int8_t>(Sprite::VT_SPRITETYPE, static_cast<int8_t>(spriteType), 0);
	}
	void add_srcBlend(int32_t srcBlend)
	{
		fbb_.AddElement<int32_t>(Sprite::VT_SRCBLEND, srcBlend, 770);
	}
	void add_dstBlend(int32_t dstBlend)
	{
		fbb_.AddElement<int32_t>(Sprite::VT_DSTBLEND, dstBlend, 771);
	}
	void add_trimEnabled(bool trimEnabled)
	{
		fbb_.AddElement<uint8_t>(Sprite::VT_TRIMENABLED, static_cast<uint8_t>(trimEnabled), 0);
	}
	void add_sizeMode(SpriteSizeMode sizeMode)
	{
		fbb_.AddElement<int8_t>(Sprite::VT_SIZEMODE, static_cast<int8_t>(sizeMode), 0);
	}
	void add_fillType(SpriteFillType fillType)
	{
		fbb_.AddElement<int8_t>(Sprite::VT_FILLTYPE, static_cast<int8_t>(fillType), 0);
	}
	void add_fillCenter(const Vec2* fillCenter)
	{
		fbb_.AddStruct(Sprite::VT_FILLCENTER, fillCenter);
	}
	void add_fillStart(float fillStart)
	{
		fbb_.AddElement<float>(Sprite::VT_FILLSTART, fillStart, 0.0f);
	}
	void add_fillRange(float fillRange)
	{
		fbb_.AddElement<float>(Sprite::VT_FILLRANGE, fillRange, 0.0f);
	}
	explicit SpriteBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	SpriteBuilder& operator=(const SpriteBuilder&);
	flatbuffers::Offset<Sprite> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Sprite>(end);
		return o;
	}
};

inline flatbuffers::Offset<Sprite> CreateSprite(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	flatbuffers::Offset<flatbuffers::String> spriteFrameName = 0,
	SpriteType spriteType = SpriteType_Simple,
	int32_t srcBlend = 770,
	int32_t dstBlend = 771,
	bool trimEnabled = false,
	SpriteSizeMode sizeMode = SpriteSizeMode_Custom,
	SpriteFillType fillType = SpriteFillType_Horizontal,
	const Vec2* fillCenter = 0,
	float fillStart = 0.0f,
	float fillRange = 0.0f)
{
	SpriteBuilder builder_(_fbb);
	builder_.add_fillRange(fillRange);
	builder_.add_fillStart(fillStart);
	builder_.add_fillCenter(fillCenter);
	builder_.add_dstBlend(dstBlend);
	builder_.add_srcBlend(srcBlend);
	builder_.add_spriteFrameName(spriteFrameName);
	builder_.add_node(node);
	builder_.add_fillType(fillType);
	builder_.add_sizeMode(sizeMode);
	builder_.add_trimEnabled(trimEnabled);
	builder_.add_spriteType(spriteType);
	return builder_.Finish();
}

inline flatbuffers::Offset<Sprite> CreateSpriteDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	const char* spriteFrameName = nullptr,
	SpriteType spriteType = SpriteType_Simple,
	int32_t srcBlend = 770,
	int32_t dstBlend = 771,
	bool trimEnabled = false,
	SpriteSizeMode sizeMode = SpriteSizeMode_Custom,
	SpriteFillType fillType = SpriteFillType_Horizontal,
	const Vec2* fillCenter = 0,
	float fillStart = 0.0f,
	float fillRange = 0.0f)
{
	return creator::buffers::CreateSprite(
		_fbb,
		node,
		spriteFrameName ? _fbb.CreateString(spriteFrameName) : 0,
		spriteType,
		srcBlend,
		dstBlend,
		trimEnabled,
		sizeMode,
		fillType,
		fillCenter,
		fillStart,
		fillRange);
}

struct Label FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_NODE = 4,
		VT_LABELTEXT = 6,
		VT_HORIZONTALALIGNMENT = 8,
		VT_VERTICALALIGNMENT = 10,
		VT_LINEHEIGHT = 12,
		VT_FONTNAME = 14,
		VT_FONTSIZE = 16,
		VT_FONTTYPE = 18,
		VT_OVERFLOWTYPE = 20,
		VT_ENABLEWRAP = 22,
		VT_OUTLINE = 24,
		VT_SHADOW = 26
	};
	const Node* node() const
	{
		return GetPointer<const Node*>(VT_NODE);
	}
	const flatbuffers::String* labelText() const
	{
		return GetPointer<const flatbuffers::String*>(VT_LABELTEXT);
	}
	HorizontalAlignment horizontalAlignment() const
	{
		return static_cast<HorizontalAlignment>(GetField<int8_t>(VT_HORIZONTALALIGNMENT, 0));
	}
	VerticalAlignment verticalAlignment() const
	{
		return static_cast<VerticalAlignment>(GetField<int8_t>(VT_VERTICALALIGNMENT, 0));
	}
	float lineHeight() const
	{
		return GetField<float>(VT_LINEHEIGHT, 0.0f);
	}
	const flatbuffers::String* fontName() const
	{
		return GetPointer<const flatbuffers::String*>(VT_FONTNAME);
	}
	float fontSize() const
	{
		return GetField<float>(VT_FONTSIZE, 0.0f);
	}
	FontType fontType() const
	{
		return static_cast<FontType>(GetField<int8_t>(VT_FONTTYPE, 0));
	}
	LabelOverflowType overflowType() const
	{
		return static_cast<LabelOverflowType>(GetField<int8_t>(VT_OVERFLOWTYPE, 0));
	}
	bool enableWrap() const
	{
		return GetField<uint8_t>(VT_ENABLEWRAP, 0) != 0;
	}
	const LabelOutline* outline() const
	{
		return GetPointer<const LabelOutline*>(VT_OUTLINE);
	}
	const LabelShadow* shadow() const
	{
		return GetPointer<const LabelShadow*>(VT_SHADOW);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyOffset(verifier, VT_NODE) &&
			   verifier.VerifyTable(node()) &&
			   VerifyOffset(verifier, VT_LABELTEXT) &&
			   verifier.VerifyString(labelText()) &&
			   VerifyField<int8_t>(verifier, VT_HORIZONTALALIGNMENT) &&
			   VerifyField<int8_t>(verifier, VT_VERTICALALIGNMENT) &&
			   VerifyField<float>(verifier, VT_LINEHEIGHT) &&
			   VerifyOffset(verifier, VT_FONTNAME) &&
			   verifier.VerifyString(fontName()) &&
			   VerifyField<float>(verifier, VT_FONTSIZE) &&
			   VerifyField<int8_t>(verifier, VT_FONTTYPE) &&
			   VerifyField<int8_t>(verifier, VT_OVERFLOWTYPE) &&
			   VerifyField<uint8_t>(verifier, VT_ENABLEWRAP) &&
			   VerifyOffset(verifier, VT_OUTLINE) &&
			   verifier.VerifyTable(outline()) &&
			   VerifyOffset(verifier, VT_SHADOW) &&
			   verifier.VerifyTable(shadow()) &&
			   verifier.EndTable();
	}
};

struct LabelBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_node(flatbuffers::Offset<Node> node)
	{
		fbb_.AddOffset(Label::VT_NODE, node);
	}
	void add_labelText(flatbuffers::Offset<flatbuffers::String> labelText)
	{
		fbb_.AddOffset(Label::VT_LABELTEXT, labelText);
	}
	void add_horizontalAlignment(HorizontalAlignment horizontalAlignment)
	{
		fbb_.AddElement<int8_t>(Label::VT_HORIZONTALALIGNMENT, static_cast<int8_t>(horizontalAlignment), 0);
	}
	void add_verticalAlignment(VerticalAlignment verticalAlignment)
	{
		fbb_.AddElement<int8_t>(Label::VT_VERTICALALIGNMENT, static_cast<int8_t>(verticalAlignment), 0);
	}
	void add_lineHeight(float lineHeight)
	{
		fbb_.AddElement<float>(Label::VT_LINEHEIGHT, lineHeight, 0.0f);
	}
	void add_fontName(flatbuffers::Offset<flatbuffers::String> fontName)
	{
		fbb_.AddOffset(Label::VT_FONTNAME, fontName);
	}
	void add_fontSize(float fontSize)
	{
		fbb_.AddElement<float>(Label::VT_FONTSIZE, fontSize, 0.0f);
	}
	void add_fontType(FontType fontType)
	{
		fbb_.AddElement<int8_t>(Label::VT_FONTTYPE, static_cast<int8_t>(fontType), 0);
	}
	void add_overflowType(LabelOverflowType overflowType)
	{
		fbb_.AddElement<int8_t>(Label::VT_OVERFLOWTYPE, static_cast<int8_t>(overflowType), 0);
	}
	void add_enableWrap(bool enableWrap)
	{
		fbb_.AddElement<uint8_t>(Label::VT_ENABLEWRAP, static_cast<uint8_t>(enableWrap), 0);
	}
	void add_outline(flatbuffers::Offset<LabelOutline> outline)
	{
		fbb_.AddOffset(Label::VT_OUTLINE, outline);
	}
	void add_shadow(flatbuffers::Offset<LabelShadow> shadow)
	{
		fbb_.AddOffset(Label::VT_SHADOW, shadow);
	}
	explicit LabelBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	LabelBuilder& operator=(const LabelBuilder&);
	flatbuffers::Offset<Label> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Label>(end);
		return o;
	}
};

inline flatbuffers::Offset<Label> CreateLabel(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	flatbuffers::Offset<flatbuffers::String> labelText = 0,
	HorizontalAlignment horizontalAlignment = HorizontalAlignment_Left,
	VerticalAlignment verticalAlignment = VerticalAlignment_Top,
	float lineHeight = 0.0f,
	flatbuffers::Offset<flatbuffers::String> fontName = 0,
	float fontSize = 0.0f,
	FontType fontType = FontType_System,
	LabelOverflowType overflowType = LabelOverflowType_None,
	bool enableWrap = false,
	flatbuffers::Offset<LabelOutline> outline = 0,
	flatbuffers::Offset<LabelShadow> shadow = 0)
{
	LabelBuilder builder_(_fbb);
	builder_.add_shadow(shadow);
	builder_.add_outline(outline);
	builder_.add_fontSize(fontSize);
	builder_.add_fontName(fontName);
	builder_.add_lineHeight(lineHeight);
	builder_.add_labelText(labelText);
	builder_.add_node(node);
	builder_.add_enableWrap(enableWrap);
	builder_.add_overflowType(overflowType);
	builder_.add_fontType(fontType);
	builder_.add_verticalAlignment(verticalAlignment);
	builder_.add_horizontalAlignment(horizontalAlignment);
	return builder_.Finish();
}

inline flatbuffers::Offset<Label> CreateLabelDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	const char* labelText = nullptr,
	HorizontalAlignment horizontalAlignment = HorizontalAlignment_Left,
	VerticalAlignment verticalAlignment = VerticalAlignment_Top,
	float lineHeight = 0.0f,
	const char* fontName = nullptr,
	float fontSize = 0.0f,
	FontType fontType = FontType_System,
	LabelOverflowType overflowType = LabelOverflowType_None,
	bool enableWrap = false,
	flatbuffers::Offset<LabelOutline> outline = 0,
	flatbuffers::Offset<LabelShadow> shadow = 0)
{
	return creator::buffers::CreateLabel(
		_fbb,
		node,
		labelText ? _fbb.CreateString(labelText) : 0,
		horizontalAlignment,
		verticalAlignment,
		lineHeight,
		fontName ? _fbb.CreateString(fontName) : 0,
		fontSize,
		fontType,
		overflowType,
		enableWrap,
		outline,
		shadow);
}

struct RichText FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_NODE = 4,
		VT_TEXT = 6,
		VT_HORIZONTALALIGNMENT = 8,
		VT_FONTSIZE = 10,
		VT_MAXWIDTH = 12,
		VT_LINEHEIGHT = 14,
		VT_FONTFILENAME = 16
	};
	const Node* node() const
	{
		return GetPointer<const Node*>(VT_NODE);
	}
	const flatbuffers::String* text() const
	{
		return GetPointer<const flatbuffers::String*>(VT_TEXT);
	}
	HorizontalAlignment horizontalAlignment() const
	{
		return static_cast<HorizontalAlignment>(GetField<int8_t>(VT_HORIZONTALALIGNMENT, 0));
	}
	float fontSize() const
	{
		return GetField<float>(VT_FONTSIZE, 0.0f);
	}
	float maxWidth() const
	{
		return GetField<float>(VT_MAXWIDTH, 0.0f);
	}
	float lineHeight() const
	{
		return GetField<float>(VT_LINEHEIGHT, 0.0f);
	}
	const flatbuffers::String* fontFilename() const
	{
		return GetPointer<const flatbuffers::String*>(VT_FONTFILENAME);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyOffset(verifier, VT_NODE) &&
			   verifier.VerifyTable(node()) &&
			   VerifyOffset(verifier, VT_TEXT) &&
			   verifier.VerifyString(text()) &&
			   VerifyField<int8_t>(verifier, VT_HORIZONTALALIGNMENT) &&
			   VerifyField<float>(verifier, VT_FONTSIZE) &&
			   VerifyField<float>(verifier, VT_MAXWIDTH) &&
			   VerifyField<float>(verifier, VT_LINEHEIGHT) &&
			   VerifyOffset(verifier, VT_FONTFILENAME) &&
			   verifier.VerifyString(fontFilename()) &&
			   verifier.EndTable();
	}
};

struct RichTextBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_node(flatbuffers::Offset<Node> node)
	{
		fbb_.AddOffset(RichText::VT_NODE, node);
	}
	void add_text(flatbuffers::Offset<flatbuffers::String> text)
	{
		fbb_.AddOffset(RichText::VT_TEXT, text);
	}
	void add_horizontalAlignment(HorizontalAlignment horizontalAlignment)
	{
		fbb_.AddElement<int8_t>(RichText::VT_HORIZONTALALIGNMENT, static_cast<int8_t>(horizontalAlignment), 0);
	}
	void add_fontSize(float fontSize)
	{
		fbb_.AddElement<float>(RichText::VT_FONTSIZE, fontSize, 0.0f);
	}
	void add_maxWidth(float maxWidth)
	{
		fbb_.AddElement<float>(RichText::VT_MAXWIDTH, maxWidth, 0.0f);
	}
	void add_lineHeight(float lineHeight)
	{
		fbb_.AddElement<float>(RichText::VT_LINEHEIGHT, lineHeight, 0.0f);
	}
	void add_fontFilename(flatbuffers::Offset<flatbuffers::String> fontFilename)
	{
		fbb_.AddOffset(RichText::VT_FONTFILENAME, fontFilename);
	}
	explicit RichTextBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	RichTextBuilder& operator=(const RichTextBuilder&);
	flatbuffers::Offset<RichText> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<RichText>(end);
		return o;
	}
};

inline flatbuffers::Offset<RichText> CreateRichText(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	flatbuffers::Offset<flatbuffers::String> text = 0,
	HorizontalAlignment horizontalAlignment = HorizontalAlignment_Left,
	float fontSize = 0.0f,
	float maxWidth = 0.0f,
	float lineHeight = 0.0f,
	flatbuffers::Offset<flatbuffers::String> fontFilename = 0)
{
	RichTextBuilder builder_(_fbb);
	builder_.add_fontFilename(fontFilename);
	builder_.add_lineHeight(lineHeight);
	builder_.add_maxWidth(maxWidth);
	builder_.add_fontSize(fontSize);
	builder_.add_text(text);
	builder_.add_node(node);
	builder_.add_horizontalAlignment(horizontalAlignment);
	return builder_.Finish();
}

inline flatbuffers::Offset<RichText> CreateRichTextDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	const char* text = nullptr,
	HorizontalAlignment horizontalAlignment = HorizontalAlignment_Left,
	float fontSize = 0.0f,
	float maxWidth = 0.0f,
	float lineHeight = 0.0f,
	const char* fontFilename = nullptr)
{
	return creator::buffers::CreateRichText(
		_fbb,
		node,
		text ? _fbb.CreateString(text) : 0,
		horizontalAlignment,
		fontSize,
		maxWidth,
		lineHeight,
		fontFilename ? _fbb.CreateString(fontFilename) : 0);
}

struct Particle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_NODE = 4,
		VT_PARTICLEFILENAME = 6,
		VT_TEXTUREPATH = 8
	};
	const Node* node() const
	{
		return GetPointer<const Node*>(VT_NODE);
	}
	const flatbuffers::String* particleFilename() const
	{
		return GetPointer<const flatbuffers::String*>(VT_PARTICLEFILENAME);
	}
	const flatbuffers::String* texturePath() const
	{
		return GetPointer<const flatbuffers::String*>(VT_TEXTUREPATH);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyOffset(verifier, VT_NODE) &&
			   verifier.VerifyTable(node()) &&
			   VerifyOffset(verifier, VT_PARTICLEFILENAME) &&
			   verifier.VerifyString(particleFilename()) &&
			   VerifyOffset(verifier, VT_TEXTUREPATH) &&
			   verifier.VerifyString(texturePath()) &&
			   verifier.EndTable();
	}
};

struct ParticleBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_node(flatbuffers::Offset<Node> node)
	{
		fbb_.AddOffset(Particle::VT_NODE, node);
	}
	void add_particleFilename(flatbuffers::Offset<flatbuffers::String> particleFilename)
	{
		fbb_.AddOffset(Particle::VT_PARTICLEFILENAME, particleFilename);
	}
	void add_texturePath(flatbuffers::Offset<flatbuffers::String> texturePath)
	{
		fbb_.AddOffset(Particle::VT_TEXTUREPATH, texturePath);
	}
	explicit ParticleBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	ParticleBuilder& operator=(const ParticleBuilder&);
	flatbuffers::Offset<Particle> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Particle>(end);
		return o;
	}
};

inline flatbuffers::Offset<Particle> CreateParticle(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	flatbuffers::Offset<flatbuffers::String> particleFilename = 0,
	flatbuffers::Offset<flatbuffers::String> texturePath = 0)
{
	ParticleBuilder builder_(_fbb);
	builder_.add_texturePath(texturePath);
	builder_.add_particleFilename(particleFilename);
	builder_.add_node(node);
	return builder_.Finish();
}

inline flatbuffers::Offset<Particle> CreateParticleDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	const char* particleFilename = nullptr,
	const char* texturePath = nullptr)
{
	return creator::buffers::CreateParticle(
		_fbb,
		node,
		particleFilename ? _fbb.CreateString(particleFilename) : 0,
		texturePath ? _fbb.CreateString(texturePath) : 0);
}

struct TileMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_NODE = 4,
		VT_TMXFILENAME = 6,
		VT_DESIREDCONTENTSIZE = 8
	};
	const Node* node() const
	{
		return GetPointer<const Node*>(VT_NODE);
	}
	const flatbuffers::String* tmxFilename() const
	{
		return GetPointer<const flatbuffers::String*>(VT_TMXFILENAME);
	}
	const Size* desiredContentSize() const
	{
		return GetStruct<const Size*>(VT_DESIREDCONTENTSIZE);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyOffset(verifier, VT_NODE) &&
			   verifier.VerifyTable(node()) &&
			   VerifyOffset(verifier, VT_TMXFILENAME) &&
			   verifier.VerifyString(tmxFilename()) &&
			   VerifyField<Size>(verifier, VT_DESIREDCONTENTSIZE) &&
			   verifier.EndTable();
	}
};

struct TileMapBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_node(flatbuffers::Offset<Node> node)
	{
		fbb_.AddOffset(TileMap::VT_NODE, node);
	}
	void add_tmxFilename(flatbuffers::Offset<flatbuffers::String> tmxFilename)
	{
		fbb_.AddOffset(TileMap::VT_TMXFILENAME, tmxFilename);
	}
	void add_desiredContentSize(const Size* desiredContentSize)
	{
		fbb_.AddStruct(TileMap::VT_DESIREDCONTENTSIZE, desiredContentSize);
	}
	explicit TileMapBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	TileMapBuilder& operator=(const TileMapBuilder&);
	flatbuffers::Offset<TileMap> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<TileMap>(end);
		return o;
	}
};

inline flatbuffers::Offset<TileMap> CreateTileMap(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	flatbuffers::Offset<flatbuffers::String> tmxFilename = 0,
	const Size* desiredContentSize = 0)
{
	TileMapBuilder builder_(_fbb);
	builder_.add_desiredContentSize(desiredContentSize);
	builder_.add_tmxFilename(tmxFilename);
	builder_.add_node(node);
	return builder_.Finish();
}

inline flatbuffers::Offset<TileMap> CreateTileMapDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	const char* tmxFilename = nullptr,
	const Size* desiredContentSize = 0)
{
	return creator::buffers::CreateTileMap(
		_fbb,
		node,
		tmxFilename ? _fbb.CreateString(tmxFilename) : 0,
		desiredContentSize);
}

struct Scene FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_NODE = 4
	};
	const Node* node() const
	{
		return GetPointer<const Node*>(VT_NODE);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyOffset(verifier, VT_NODE) &&
			   verifier.VerifyTable(node()) &&
			   verifier.EndTable();
	}
};

struct SceneBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_node(flatbuffers::Offset<Node> node)
	{
		fbb_.AddOffset(Scene::VT_NODE, node);
	}
	explicit SceneBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	SceneBuilder& operator=(const SceneBuilder&);
	flatbuffers::Offset<Scene> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Scene>(end);
		return o;
	}
};

inline flatbuffers::Offset<Scene> CreateScene(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0)
{
	SceneBuilder builder_(_fbb);
	builder_.add_node(node);
	return builder_.Finish();
}

struct Prefab FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_NODE = 4
	};
	const Node* node() const
	{
		return GetPointer<const Node*>(VT_NODE);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyOffset(verifier, VT_NODE) &&
			   verifier.VerifyTable(node()) &&
			   verifier.EndTable();
	}
};

struct PrefabBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_node(flatbuffers::Offset<Node> node)
	{
		fbb_.AddOffset(Prefab::VT_NODE, node);
	}
	explicit PrefabBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	PrefabBuilder& operator=(const PrefabBuilder&);
	flatbuffers::Offset<Prefab> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Prefab>(end);
		return o;
	}
};

inline flatbuffers::Offset<Prefab> CreatePrefab(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0)
{
	PrefabBuilder builder_(_fbb);
	builder_.add_node(node);
	return builder_.Finish();
}

struct Button FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_NODE = 4,
		VT_TRANSITION = 6,
		VT_DURATION = 8,
		VT_ZOOMSCALE = 10,
		VT_SPRITETYPE = 12,
		VT_TRIMENABLED = 14,
		VT_BACKGROUNDNODENAME = 16,
		VT_SPRITEFRAMENAME = 18,
		VT_PRESSEDSPRITEFRAMENAME = 20,
		VT_DISABLEDSPRITEFRAMENAME = 22,
		VT_IGNORECONTENTADAPTWITHSIZE = 24,
		VT_NORMALCOLOR = 26,
		VT_PRESSEDCOLOR = 28,
		VT_DISABLEDCOLOR = 30
	};
	const Node* node() const
	{
		return GetPointer<const Node*>(VT_NODE);
	}
	int32_t transition() const
	{
		return GetField<int32_t>(VT_TRANSITION, 0);
	}
	float duration() const
	{
		return GetField<float>(VT_DURATION, 0.0f);
	}
	float zoomScale() const
	{
		return GetField<float>(VT_ZOOMSCALE, 0.0f);
	}
	SpriteType spriteType() const
	{
		return static_cast<SpriteType>(GetField<int8_t>(VT_SPRITETYPE, 0));
	}
	bool trimEnabled() const
	{
		return GetField<uint8_t>(VT_TRIMENABLED, 0) != 0;
	}
	const flatbuffers::String* backgroundNodeName() const
	{
		return GetPointer<const flatbuffers::String*>(VT_BACKGROUNDNODENAME);
	}
	const flatbuffers::String* spriteFrameName() const
	{
		return GetPointer<const flatbuffers::String*>(VT_SPRITEFRAMENAME);
	}
	const flatbuffers::String* pressedSpriteFrameName() const
	{
		return GetPointer<const flatbuffers::String*>(VT_PRESSEDSPRITEFRAMENAME);
	}
	const flatbuffers::String* disabledSpriteFrameName() const
	{
		return GetPointer<const flatbuffers::String*>(VT_DISABLEDSPRITEFRAMENAME);
	}
	bool ignoreContentAdaptWithSize() const
	{
		return GetField<uint8_t>(VT_IGNORECONTENTADAPTWITHSIZE, 0) != 0;
	}
	const ColorRGBA* normalColor() const
	{
		return GetStruct<const ColorRGBA*>(VT_NORMALCOLOR);
	}
	const ColorRGBA* pressedColor() const
	{
		return GetStruct<const ColorRGBA*>(VT_PRESSEDCOLOR);
	}
	const ColorRGBA* disabledColor() const
	{
		return GetStruct<const ColorRGBA*>(VT_DISABLEDCOLOR);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyOffset(verifier, VT_NODE) &&
			   verifier.VerifyTable(node()) &&
			   VerifyField<int32_t>(verifier, VT_TRANSITION) &&
			   VerifyField<float>(verifier, VT_DURATION) &&
			   VerifyField<float>(verifier, VT_ZOOMSCALE) &&
			   VerifyField<int8_t>(verifier, VT_SPRITETYPE) &&
			   VerifyField<uint8_t>(verifier, VT_TRIMENABLED) &&
			   VerifyOffset(verifier, VT_BACKGROUNDNODENAME) &&
			   verifier.VerifyString(backgroundNodeName()) &&
			   VerifyOffset(verifier, VT_SPRITEFRAMENAME) &&
			   verifier.VerifyString(spriteFrameName()) &&
			   VerifyOffset(verifier, VT_PRESSEDSPRITEFRAMENAME) &&
			   verifier.VerifyString(pressedSpriteFrameName()) &&
			   VerifyOffset(verifier, VT_DISABLEDSPRITEFRAMENAME) &&
			   verifier.VerifyString(disabledSpriteFrameName()) &&
			   VerifyField<uint8_t>(verifier, VT_IGNORECONTENTADAPTWITHSIZE) &&
			   VerifyField<ColorRGBA>(verifier, VT_NORMALCOLOR) &&
			   VerifyField<ColorRGBA>(verifier, VT_PRESSEDCOLOR) &&
			   VerifyField<ColorRGBA>(verifier, VT_DISABLEDCOLOR) &&
			   verifier.EndTable();
	}
};

struct ButtonBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_node(flatbuffers::Offset<Node> node)
	{
		fbb_.AddOffset(Button::VT_NODE, node);
	}
	void add_transition(int32_t transition)
	{
		fbb_.AddElement<int32_t>(Button::VT_TRANSITION, transition, 0);
	}
	void add_duration(float duration)
	{
		fbb_.AddElement<float>(Button::VT_DURATION, duration, 0.0f);
	}
	void add_zoomScale(float zoomScale)
	{
		fbb_.AddElement<float>(Button::VT_ZOOMSCALE, zoomScale, 0.0f);
	}
	void add_spriteType(SpriteType spriteType)
	{
		fbb_.AddElement<int8_t>(Button::VT_SPRITETYPE, static_cast<int8_t>(spriteType), 0);
	}
	void add_trimEnabled(bool trimEnabled)
	{
		fbb_.AddElement<uint8_t>(Button::VT_TRIMENABLED, static_cast<uint8_t>(trimEnabled), 0);
	}
	void add_backgroundNodeName(flatbuffers::Offset<flatbuffers::String> backgroundNodeName)
	{
		fbb_.AddOffset(Button::VT_BACKGROUNDNODENAME, backgroundNodeName);
	}
	void add_spriteFrameName(flatbuffers::Offset<flatbuffers::String> spriteFrameName)
	{
		fbb_.AddOffset(Button::VT_SPRITEFRAMENAME, spriteFrameName);
	}
	void add_pressedSpriteFrameName(flatbuffers::Offset<flatbuffers::String> pressedSpriteFrameName)
	{
		fbb_.AddOffset(Button::VT_PRESSEDSPRITEFRAMENAME, pressedSpriteFrameName);
	}
	void add_disabledSpriteFrameName(flatbuffers::Offset<flatbuffers::String> disabledSpriteFrameName)
	{
		fbb_.AddOffset(Button::VT_DISABLEDSPRITEFRAMENAME, disabledSpriteFrameName);
	}
	void add_ignoreContentAdaptWithSize(bool ignoreContentAdaptWithSize)
	{
		fbb_.AddElement<uint8_t>(Button::VT_IGNORECONTENTADAPTWITHSIZE, static_cast<uint8_t>(ignoreContentAdaptWithSize), 0);
	}
	void add_normalColor(const ColorRGBA* normalColor)
	{
		fbb_.AddStruct(Button::VT_NORMALCOLOR, normalColor);
	}
	void add_pressedColor(const ColorRGBA* pressedColor)
	{
		fbb_.AddStruct(Button::VT_PRESSEDCOLOR, pressedColor);
	}
	void add_disabledColor(const ColorRGBA* disabledColor)
	{
		fbb_.AddStruct(Button::VT_DISABLEDCOLOR, disabledColor);
	}
	explicit ButtonBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	ButtonBuilder& operator=(const ButtonBuilder&);
	flatbuffers::Offset<Button> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Button>(end);
		return o;
	}
};

inline flatbuffers::Offset<Button> CreateButton(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	int32_t transition = 0,
	float duration = 0.0f,
	float zoomScale = 0.0f,
	SpriteType spriteType = SpriteType_Simple,
	bool trimEnabled = false,
	flatbuffers::Offset<flatbuffers::String> backgroundNodeName = 0,
	flatbuffers::Offset<flatbuffers::String> spriteFrameName = 0,
	flatbuffers::Offset<flatbuffers::String> pressedSpriteFrameName = 0,
	flatbuffers::Offset<flatbuffers::String> disabledSpriteFrameName = 0,
	bool ignoreContentAdaptWithSize = false,
	const ColorRGBA* normalColor = 0,
	const ColorRGBA* pressedColor = 0,
	const ColorRGBA* disabledColor = 0)
{
	ButtonBuilder builder_(_fbb);
	builder_.add_disabledColor(disabledColor);
	builder_.add_pressedColor(pressedColor);
	builder_.add_normalColor(normalColor);
	builder_.add_disabledSpriteFrameName(disabledSpriteFrameName);
	builder_.add_pressedSpriteFrameName(pressedSpriteFrameName);
	builder_.add_spriteFrameName(spriteFrameName);
	builder_.add_backgroundNodeName(backgroundNodeName);
	builder_.add_zoomScale(zoomScale);
	builder_.add_duration(duration);
	builder_.add_transition(transition);
	builder_.add_node(node);
	builder_.add_ignoreContentAdaptWithSize(ignoreContentAdaptWithSize);
	builder_.add_trimEnabled(trimEnabled);
	builder_.add_spriteType(spriteType);
	return builder_.Finish();
}

inline flatbuffers::Offset<Button> CreateButtonDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	int32_t transition = 0,
	float duration = 0.0f,
	float zoomScale = 0.0f,
	SpriteType spriteType = SpriteType_Simple,
	bool trimEnabled = false,
	const char* backgroundNodeName = nullptr,
	const char* spriteFrameName = nullptr,
	const char* pressedSpriteFrameName = nullptr,
	const char* disabledSpriteFrameName = nullptr,
	bool ignoreContentAdaptWithSize = false,
	const ColorRGBA* normalColor = 0,
	const ColorRGBA* pressedColor = 0,
	const ColorRGBA* disabledColor = 0)
{
	return creator::buffers::CreateButton(
		_fbb,
		node,
		transition,
		duration,
		zoomScale,
		spriteType,
		trimEnabled,
		backgroundNodeName ? _fbb.CreateString(backgroundNodeName) : 0,
		spriteFrameName ? _fbb.CreateString(spriteFrameName) : 0,
		pressedSpriteFrameName ? _fbb.CreateString(pressedSpriteFrameName) : 0,
		disabledSpriteFrameName ? _fbb.CreateString(disabledSpriteFrameName) : 0,
		ignoreContentAdaptWithSize,
		normalColor,
		pressedColor,
		disabledColor);
}

struct ProgressBar FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_NODE = 4,
		VT_PERCENT = 6,
		VT_BACKGROUNDSPRITEFRAMENAME = 8,
		VT_BARSPRITEFRAMENAME = 10,
		VT_BARSPRITETYPE = 12,
		VT_REVERSE = 14,
		VT_BARPOSITION = 16,
		VT_BARANCHORPOINT = 18,
		VT_BARCONTENTSIZE = 20
	};
	const Node* node() const
	{
		return GetPointer<const Node*>(VT_NODE);
	}
	float percent() const
	{
		return GetField<float>(VT_PERCENT, 0.0f);
	}
	const flatbuffers::String* backgroundSpriteFrameName() const
	{
		return GetPointer<const flatbuffers::String*>(VT_BACKGROUNDSPRITEFRAMENAME);
	}
	const flatbuffers::String* barSpriteFrameName() const
	{
		return GetPointer<const flatbuffers::String*>(VT_BARSPRITEFRAMENAME);
	}
	int32_t barSpriteType() const
	{
		return GetField<int32_t>(VT_BARSPRITETYPE, 0);
	}
	bool reverse() const
	{
		return GetField<uint8_t>(VT_REVERSE, 0) != 0;
	}
	const Vec2* barPosition() const
	{
		return GetStruct<const Vec2*>(VT_BARPOSITION);
	}
	const Vec2* barAnchorPoint() const
	{
		return GetStruct<const Vec2*>(VT_BARANCHORPOINT);
	}
	const Size* barContentSize() const
	{
		return GetStruct<const Size*>(VT_BARCONTENTSIZE);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyOffset(verifier, VT_NODE) &&
			   verifier.VerifyTable(node()) &&
			   VerifyField<float>(verifier, VT_PERCENT) &&
			   VerifyOffset(verifier, VT_BACKGROUNDSPRITEFRAMENAME) &&
			   verifier.VerifyString(backgroundSpriteFrameName()) &&
			   VerifyOffset(verifier, VT_BARSPRITEFRAMENAME) &&
			   verifier.VerifyString(barSpriteFrameName()) &&
			   VerifyField<int32_t>(verifier, VT_BARSPRITETYPE) &&
			   VerifyField<uint8_t>(verifier, VT_REVERSE) &&
			   VerifyField<Vec2>(verifier, VT_BARPOSITION) &&
			   VerifyField<Vec2>(verifier, VT_BARANCHORPOINT) &&
			   VerifyField<Size>(verifier, VT_BARCONTENTSIZE) &&
			   verifier.EndTable();
	}
};

struct ProgressBarBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_node(flatbuffers::Offset<Node> node)
	{
		fbb_.AddOffset(ProgressBar::VT_NODE, node);
	}
	void add_percent(float percent)
	{
		fbb_.AddElement<float>(ProgressBar::VT_PERCENT, percent, 0.0f);
	}
	void add_backgroundSpriteFrameName(flatbuffers::Offset<flatbuffers::String> backgroundSpriteFrameName)
	{
		fbb_.AddOffset(ProgressBar::VT_BACKGROUNDSPRITEFRAMENAME, backgroundSpriteFrameName);
	}
	void add_barSpriteFrameName(flatbuffers::Offset<flatbuffers::String> barSpriteFrameName)
	{
		fbb_.AddOffset(ProgressBar::VT_BARSPRITEFRAMENAME, barSpriteFrameName);
	}
	void add_barSpriteType(int32_t barSpriteType)
	{
		fbb_.AddElement<int32_t>(ProgressBar::VT_BARSPRITETYPE, barSpriteType, 0);
	}
	void add_reverse(bool reverse)
	{
		fbb_.AddElement<uint8_t>(ProgressBar::VT_REVERSE, static_cast<uint8_t>(reverse), 0);
	}
	void add_barPosition(const Vec2* barPosition)
	{
		fbb_.AddStruct(ProgressBar::VT_BARPOSITION, barPosition);
	}
	void add_barAnchorPoint(const Vec2* barAnchorPoint)
	{
		fbb_.AddStruct(ProgressBar::VT_BARANCHORPOINT, barAnchorPoint);
	}
	void add_barContentSize(const Size* barContentSize)
	{
		fbb_.AddStruct(ProgressBar::VT_BARCONTENTSIZE, barContentSize);
	}
	explicit ProgressBarBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	ProgressBarBuilder& operator=(const ProgressBarBuilder&);
	flatbuffers::Offset<ProgressBar> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<ProgressBar>(end);
		return o;
	}
};

inline flatbuffers::Offset<ProgressBar> CreateProgressBar(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	float percent = 0.0f,
	flatbuffers::Offset<flatbuffers::String> backgroundSpriteFrameName = 0,
	flatbuffers::Offset<flatbuffers::String> barSpriteFrameName = 0,
	int32_t barSpriteType = 0,
	bool reverse = false,
	const Vec2* barPosition = 0,
	const Vec2* barAnchorPoint = 0,
	const Size* barContentSize = 0)
{
	ProgressBarBuilder builder_(_fbb);
	builder_.add_barContentSize(barContentSize);
	builder_.add_barAnchorPoint(barAnchorPoint);
	builder_.add_barPosition(barPosition);
	builder_.add_barSpriteType(barSpriteType);
	builder_.add_barSpriteFrameName(barSpriteFrameName);
	builder_.add_backgroundSpriteFrameName(backgroundSpriteFrameName);
	builder_.add_percent(percent);
	builder_.add_node(node);
	builder_.add_reverse(reverse);
	return builder_.Finish();
}

inline flatbuffers::Offset<ProgressBar> CreateProgressBarDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	float percent = 0.0f,
	const char* backgroundSpriteFrameName = nullptr,
	const char* barSpriteFrameName = nullptr,
	int32_t barSpriteType = 0,
	bool reverse = false,
	const Vec2* barPosition = 0,
	const Vec2* barAnchorPoint = 0,
	const Size* barContentSize = 0)
{
	return creator::buffers::CreateProgressBar(
		_fbb,
		node,
		percent,
		backgroundSpriteFrameName ? _fbb.CreateString(backgroundSpriteFrameName) : 0,
		barSpriteFrameName ? _fbb.CreateString(barSpriteFrameName) : 0,
		barSpriteType,
		reverse,
		barPosition,
		barAnchorPoint,
		barContentSize);
}

struct ScrollView FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_NODE = 4,
		VT_BACKGROUNDIMAGE = 6,
		VT_BACKGROUNDIMAGESCALE9ENABLED = 8,
		VT_BACKGROUNDIMAGECOLOR = 10,
		VT_DIRECTION = 12,
		VT_BOUNCEENABLED = 14,
		VT_INNERCONTAINERSIZE = 16,
		VT_RECYCLEELEMENTS = 18
	};
	const Node* node() const
	{
		return GetPointer<const Node*>(VT_NODE);
	}
	const flatbuffers::String* backgroundImage() const
	{
		return GetPointer<const flatbuffers::String*>(VT_BACKGROUNDIMAGE);
	}
	bool backgroundImageScale9Enabled() const
	{
		return GetField<uint8_t>(VT_BACKGROUNDIMAGESCALE9ENABLED, 0) != 0;
	}
	const ColorRGB* backgroundImageColor() const
	{
		return GetStruct<const ColorRGB*>(VT_BACKGROUNDIMAGECOLOR);
	}
	ScrollViewDirection direction() const
	{
		return static_cast<ScrollViewDirection>(GetField<int8_t>(VT_DIRECTION, 0));
	}
	bool bounceEnabled() const
	{
		return GetField<uint8_t>(VT_BOUNCEENABLED, 0) != 0;
	}
	const Size* innerContainerSize() const
	{
		return GetStruct<const Size*>(VT_INNERCONTAINERSIZE);
	}
	bool recycleElements() const
	{
		return GetField<uint8_t>(VT_RECYCLEELEMENTS, 0) != 0;
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyOffset(verifier, VT_NODE) &&
			   verifier.VerifyTable(node()) &&
			   VerifyOffset(verifier, VT_BACKGROUNDIMAGE) &&
			   verifier.VerifyString(backgroundImage()) &&
			   VerifyField<uint8_t>(verifier, VT_BACKGROUNDIMAGESCALE9ENABLED) &&
			   VerifyField<ColorRGB>(verifier, VT_BACKGROUNDIMAGECOLOR) &&
			   VerifyField<int8_t>(verifier, VT_DIRECTION) &&
			   VerifyField<uint8_t>(verifier, VT_BOUNCEENABLED) &&
			   VerifyField<Size>(verifier, VT_INNERCONTAINERSIZE) &&
			   VerifyField<uint8_t>(verifier, VT_RECYCLEELEMENTS) &&
			   verifier.EndTable();
	}
};

struct ScrollViewBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_node(flatbuffers::Offset<Node> node)
	{
		fbb_.AddOffset(ScrollView::VT_NODE, node);
	}
	void add_backgroundImage(flatbuffers::Offset<flatbuffers::String> backgroundImage)
	{
		fbb_.AddOffset(ScrollView::VT_BACKGROUNDIMAGE, backgroundImage);
	}
	void add_backgroundImageScale9Enabled(bool backgroundImageScale9Enabled)
	{
		fbb_.AddElement<uint8_t>(ScrollView::VT_BACKGROUNDIMAGESCALE9ENABLED, static_cast<uint8_t>(backgroundImageScale9Enabled), 0);
	}
	void add_backgroundImageColor(const ColorRGB* backgroundImageColor)
	{
		fbb_.AddStruct(ScrollView::VT_BACKGROUNDIMAGECOLOR, backgroundImageColor);
	}
	void add_direction(ScrollViewDirection direction)
	{
		fbb_.AddElement<int8_t>(ScrollView::VT_DIRECTION, static_cast<int8_t>(direction), 0);
	}
	void add_bounceEnabled(bool bounceEnabled)
	{
		fbb_.AddElement<uint8_t>(ScrollView::VT_BOUNCEENABLED, static_cast<uint8_t>(bounceEnabled), 0);
	}
	void add_innerContainerSize(const Size* innerContainerSize)
	{
		fbb_.AddStruct(ScrollView::VT_INNERCONTAINERSIZE, innerContainerSize);
	}
	void add_recycleElements(bool recycleElements)
	{
		fbb_.AddElement<uint8_t>(ScrollView::VT_RECYCLEELEMENTS, static_cast<uint8_t>(recycleElements), 0);
	}
	explicit ScrollViewBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	ScrollViewBuilder& operator=(const ScrollViewBuilder&);
	flatbuffers::Offset<ScrollView> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<ScrollView>(end);
		return o;
	}
};

inline flatbuffers::Offset<ScrollView> CreateScrollView(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	flatbuffers::Offset<flatbuffers::String> backgroundImage = 0,
	bool backgroundImageScale9Enabled = false,
	const ColorRGB* backgroundImageColor = 0,
	ScrollViewDirection direction = ScrollViewDirection_None,
	bool bounceEnabled = false,
	const Size* innerContainerSize = 0,
	bool recycleElements = false)
{
	ScrollViewBuilder builder_(_fbb);
	builder_.add_innerContainerSize(innerContainerSize);
	builder_.add_backgroundImageColor(backgroundImageColor);
	builder_.add_backgroundImage(backgroundImage);
	builder_.add_node(node);
	builder_.add_recycleElements(recycleElements);
	builder_.add_bounceEnabled(bounceEnabled);
	builder_.add_direction(direction);
	builder_.add_backgroundImageScale9Enabled(backgroundImageScale9Enabled);
	return builder_.Finish();
}

inline flatbuffers::Offset<ScrollView> CreateScrollViewDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	const char* backgroundImage = nullptr,
	bool backgroundImageScale9Enabled = false,
	const ColorRGB* backgroundImageColor = 0,
	ScrollViewDirection direction = ScrollViewDirection_None,
	bool bounceEnabled = false,
	const Size* innerContainerSize = 0,
	bool recycleElements = false)
{
	return creator::buffers::CreateScrollView(
		_fbb,
		node,
		backgroundImage ? _fbb.CreateString(backgroundImage) : 0,
		backgroundImageScale9Enabled,
		backgroundImageColor,
		direction,
		bounceEnabled,
		innerContainerSize,
		recycleElements);
}

struct Widget FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_ISALIGNONCE = 4,
		VT_ALIGNFLAGS = 6,
		VT_LEFT = 8,
		VT_RIGHT = 10,
		VT_TOP = 12,
		VT_BOTTOM = 14,
		VT_VERTICALCENTER = 16,
		VT_HORIZONTALCENTER = 18,
		VT_ISABSLEFT = 20,
		VT_ISABSRIGHT = 22,
		VT_ISABSTOP = 24,
		VT_ISABSBOTTOM = 26,
		VT_ISABSHORIZONTALCENTER = 28,
		VT_ISABSVERTICALCENTER = 30
	};
	bool isAlignOnce() const
	{
		return GetField<uint8_t>(VT_ISALIGNONCE, 0) != 0;
	}
	int32_t alignFlags() const
	{
		return GetField<int32_t>(VT_ALIGNFLAGS, 0);
	}
	float left() const
	{
		return GetField<float>(VT_LEFT, 0.0f);
	}
	float right() const
	{
		return GetField<float>(VT_RIGHT, 0.0f);
	}
	float top() const
	{
		return GetField<float>(VT_TOP, 0.0f);
	}
	float bottom() const
	{
		return GetField<float>(VT_BOTTOM, 0.0f);
	}
	float verticalCenter() const
	{
		return GetField<float>(VT_VERTICALCENTER, 0.0f);
	}
	float horizontalCenter() const
	{
		return GetField<float>(VT_HORIZONTALCENTER, 0.0f);
	}
	bool isAbsLeft() const
	{
		return GetField<uint8_t>(VT_ISABSLEFT, 0) != 0;
	}
	bool isAbsRight() const
	{
		return GetField<uint8_t>(VT_ISABSRIGHT, 0) != 0;
	}
	bool isAbsTop() const
	{
		return GetField<uint8_t>(VT_ISABSTOP, 0) != 0;
	}
	bool isAbsBottom() const
	{
		return GetField<uint8_t>(VT_ISABSBOTTOM, 0) != 0;
	}
	bool isAbsHorizontalCenter() const
	{
		return GetField<uint8_t>(VT_ISABSHORIZONTALCENTER, 0) != 0;
	}
	bool isAbsVerticalCenter() const
	{
		return GetField<uint8_t>(VT_ISABSVERTICALCENTER, 0) != 0;
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyField<uint8_t>(verifier, VT_ISALIGNONCE) &&
			   VerifyField<int32_t>(verifier, VT_ALIGNFLAGS) &&
			   VerifyField<float>(verifier, VT_LEFT) &&
			   VerifyField<float>(verifier, VT_RIGHT) &&
			   VerifyField<float>(verifier, VT_TOP) &&
			   VerifyField<float>(verifier, VT_BOTTOM) &&
			   VerifyField<float>(verifier, VT_VERTICALCENTER) &&
			   VerifyField<float>(verifier, VT_HORIZONTALCENTER) &&
			   VerifyField<uint8_t>(verifier, VT_ISABSLEFT) &&
			   VerifyField<uint8_t>(verifier, VT_ISABSRIGHT) &&
			   VerifyField<uint8_t>(verifier, VT_ISABSTOP) &&
			   VerifyField<uint8_t>(verifier, VT_ISABSBOTTOM) &&
			   VerifyField<uint8_t>(verifier, VT_ISABSHORIZONTALCENTER) &&
			   VerifyField<uint8_t>(verifier, VT_ISABSVERTICALCENTER) &&
			   verifier.EndTable();
	}
};

struct WidgetBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_isAlignOnce(bool isAlignOnce)
	{
		fbb_.AddElement<uint8_t>(Widget::VT_ISALIGNONCE, static_cast<uint8_t>(isAlignOnce), 0);
	}
	void add_alignFlags(int32_t alignFlags)
	{
		fbb_.AddElement<int32_t>(Widget::VT_ALIGNFLAGS, alignFlags, 0);
	}
	void add_left(float left)
	{
		fbb_.AddElement<float>(Widget::VT_LEFT, left, 0.0f);
	}
	void add_right(float right)
	{
		fbb_.AddElement<float>(Widget::VT_RIGHT, right, 0.0f);
	}
	void add_top(float top)
	{
		fbb_.AddElement<float>(Widget::VT_TOP, top, 0.0f);
	}
	void add_bottom(float bottom)
	{
		fbb_.AddElement<float>(Widget::VT_BOTTOM, bottom, 0.0f);
	}
	void add_verticalCenter(float verticalCenter)
	{
		fbb_.AddElement<float>(Widget::VT_VERTICALCENTER, verticalCenter, 0.0f);
	}
	void add_horizontalCenter(float horizontalCenter)
	{
		fbb_.AddElement<float>(Widget::VT_HORIZONTALCENTER, horizontalCenter, 0.0f);
	}
	void add_isAbsLeft(bool isAbsLeft)
	{
		fbb_.AddElement<uint8_t>(Widget::VT_ISABSLEFT, static_cast<uint8_t>(isAbsLeft), 0);
	}
	void add_isAbsRight(bool isAbsRight)
	{
		fbb_.AddElement<uint8_t>(Widget::VT_ISABSRIGHT, static_cast<uint8_t>(isAbsRight), 0);
	}
	void add_isAbsTop(bool isAbsTop)
	{
		fbb_.AddElement<uint8_t>(Widget::VT_ISABSTOP, static_cast<uint8_t>(isAbsTop), 0);
	}
	void add_isAbsBottom(bool isAbsBottom)
	{
		fbb_.AddElement<uint8_t>(Widget::VT_ISABSBOTTOM, static_cast<uint8_t>(isAbsBottom), 0);
	}
	void add_isAbsHorizontalCenter(bool isAbsHorizontalCenter)
	{
		fbb_.AddElement<uint8_t>(Widget::VT_ISABSHORIZONTALCENTER, static_cast<uint8_t>(isAbsHorizontalCenter), 0);
	}
	void add_isAbsVerticalCenter(bool isAbsVerticalCenter)
	{
		fbb_.AddElement<uint8_t>(Widget::VT_ISABSVERTICALCENTER, static_cast<uint8_t>(isAbsVerticalCenter), 0);
	}
	explicit WidgetBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	WidgetBuilder& operator=(const WidgetBuilder&);
	flatbuffers::Offset<Widget> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Widget>(end);
		return o;
	}
};

inline flatbuffers::Offset<Widget> CreateWidget(
	flatbuffers::FlatBufferBuilder& _fbb,
	bool isAlignOnce = false,
	int32_t alignFlags = 0,
	float left = 0.0f,
	float right = 0.0f,
	float top = 0.0f,
	float bottom = 0.0f,
	float verticalCenter = 0.0f,
	float horizontalCenter = 0.0f,
	bool isAbsLeft = false,
	bool isAbsRight = false,
	bool isAbsTop = false,
	bool isAbsBottom = false,
	bool isAbsHorizontalCenter = false,
	bool isAbsVerticalCenter = false)
{
	WidgetBuilder builder_(_fbb);
	builder_.add_horizontalCenter(horizontalCenter);
	builder_.add_verticalCenter(verticalCenter);
	builder_.add_bottom(bottom);
	builder_.add_top(top);
	builder_.add_right(right);
	builder_.add_left(left);
	builder_.add_alignFlags(alignFlags);
	builder_.add_isAbsVerticalCenter(isAbsVerticalCenter);
	builder_.add_isAbsHorizontalCenter(isAbsHorizontalCenter);
	builder_.add_isAbsBottom(isAbsBottom);
	builder_.add_isAbsTop(isAbsTop);
	builder_.add_isAbsRight(isAbsRight);
	builder_.add_isAbsLeft(isAbsLeft);
	builder_.add_isAlignOnce(isAlignOnce);
	return builder_.Finish();
}

struct Layout FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_NODE = 4,
		VT_LAYOUTTYPE = 6,
		VT_RESIZEMODE = 8,
		VT_SPACINGX = 10,
		VT_SPACINGY = 12,
		VT_AFFECTEDBYSCALE = 14,
		VT_AXISDIRECTION = 16,
		VT_CELLSIZE = 18,
		VT_PADDINGLEFT = 20,
		VT_PADDINGRIGHT = 22,
		VT_PADDINGTOP = 24,
		VT_PADDINGBOTTOM = 26,
		VT_VERTICALDIRECTION = 28,
		VT_HORIZONTALDIRECTION = 30
	};
	const Node* node() const
	{
		return GetPointer<const Node*>(VT_NODE);
	}
	LayoutType layoutType() const
	{
		return static_cast<LayoutType>(GetField<int8_t>(VT_LAYOUTTYPE, 0));
	}
	ResizeMode resizeMode() const
	{
		return static_cast<ResizeMode>(GetField<int8_t>(VT_RESIZEMODE, 0));
	}
	float spacingX() const
	{
		return GetField<float>(VT_SPACINGX, 0.0f);
	}
	float spacingY() const
	{
		return GetField<float>(VT_SPACINGY, 0.0f);
	}
	bool affectedByScale() const
	{
		return GetField<uint8_t>(VT_AFFECTEDBYSCALE, 0) != 0;
	}
	AxisDirection axisDirection() const
	{
		return static_cast<AxisDirection>(GetField<int8_t>(VT_AXISDIRECTION, 0));
	}
	const Size* cellSize() const
	{
		return GetStruct<const Size*>(VT_CELLSIZE);
	}
	float paddingLeft() const
	{
		return GetField<float>(VT_PADDINGLEFT, 0.0f);
	}
	float paddingRight() const
	{
		return GetField<float>(VT_PADDINGRIGHT, 0.0f);
	}
	float paddingTop() const
	{
		return GetField<float>(VT_PADDINGTOP, 0.0f);
	}
	float paddingBottom() const
	{
		return GetField<float>(VT_PADDINGBOTTOM, 0.0f);
	}
	VerticalDirection verticalDirection() const
	{
		return static_cast<VerticalDirection>(GetField<int8_t>(VT_VERTICALDIRECTION, 0));
	}
	HorizontalDirection horizontalDirection() const
	{
		return static_cast<HorizontalDirection>(GetField<int8_t>(VT_HORIZONTALDIRECTION, 0));
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyOffset(verifier, VT_NODE) &&
			   verifier.VerifyTable(node()) &&
			   VerifyField<int8_t>(verifier, VT_LAYOUTTYPE) &&
			   VerifyField<int8_t>(verifier, VT_RESIZEMODE) &&
			   VerifyField<float>(verifier, VT_SPACINGX) &&
			   VerifyField<float>(verifier, VT_SPACINGY) &&
			   VerifyField<uint8_t>(verifier, VT_AFFECTEDBYSCALE) &&
			   VerifyField<int8_t>(verifier, VT_AXISDIRECTION) &&
			   VerifyField<Size>(verifier, VT_CELLSIZE) &&
			   VerifyField<float>(verifier, VT_PADDINGLEFT) &&
			   VerifyField<float>(verifier, VT_PADDINGRIGHT) &&
			   VerifyField<float>(verifier, VT_PADDINGTOP) &&
			   VerifyField<float>(verifier, VT_PADDINGBOTTOM) &&
			   VerifyField<int8_t>(verifier, VT_VERTICALDIRECTION) &&
			   VerifyField<int8_t>(verifier, VT_HORIZONTALDIRECTION) &&
			   verifier.EndTable();
	}
};

struct LayoutBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_node(flatbuffers::Offset<Node> node)
	{
		fbb_.AddOffset(Layout::VT_NODE, node);
	}
	void add_layoutType(LayoutType layoutType)
	{
		fbb_.AddElement<int8_t>(Layout::VT_LAYOUTTYPE, static_cast<int8_t>(layoutType), 0);
	}
	void add_resizeMode(ResizeMode resizeMode)
	{
		fbb_.AddElement<int8_t>(Layout::VT_RESIZEMODE, static_cast<int8_t>(resizeMode), 0);
	}
	void add_spacingX(float spacingX)
	{
		fbb_.AddElement<float>(Layout::VT_SPACINGX, spacingX, 0.0f);
	}
	void add_spacingY(float spacingY)
	{
		fbb_.AddElement<float>(Layout::VT_SPACINGY, spacingY, 0.0f);
	}
	void add_affectedByScale(bool affectedByScale)
	{
		fbb_.AddElement<uint8_t>(Layout::VT_AFFECTEDBYSCALE, static_cast<uint8_t>(affectedByScale), 0);
	}
	void add_axisDirection(AxisDirection axisDirection)
	{
		fbb_.AddElement<int8_t>(Layout::VT_AXISDIRECTION, static_cast<int8_t>(axisDirection), 0);
	}
	void add_cellSize(const Size* cellSize)
	{
		fbb_.AddStruct(Layout::VT_CELLSIZE, cellSize);
	}
	void add_paddingLeft(float paddingLeft)
	{
		fbb_.AddElement<float>(Layout::VT_PADDINGLEFT, paddingLeft, 0.0f);
	}
	void add_paddingRight(float paddingRight)
	{
		fbb_.AddElement<float>(Layout::VT_PADDINGRIGHT, paddingRight, 0.0f);
	}
	void add_paddingTop(float paddingTop)
	{
		fbb_.AddElement<float>(Layout::VT_PADDINGTOP, paddingTop, 0.0f);
	}
	void add_paddingBottom(float paddingBottom)
	{
		fbb_.AddElement<float>(Layout::VT_PADDINGBOTTOM, paddingBottom, 0.0f);
	}
	void add_verticalDirection(VerticalDirection verticalDirection)
	{
		fbb_.AddElement<int8_t>(Layout::VT_VERTICALDIRECTION, static_cast<int8_t>(verticalDirection), 0);
	}
	void add_horizontalDirection(HorizontalDirection horizontalDirection)
	{
		fbb_.AddElement<int8_t>(Layout::VT_HORIZONTALDIRECTION, static_cast<int8_t>(horizontalDirection), 0);
	}
	explicit LayoutBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	LayoutBuilder& operator=(const LayoutBuilder&);
	flatbuffers::Offset<Layout> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Layout>(end);
		return o;
	}
};

inline flatbuffers::Offset<Layout> CreateLayout(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	LayoutType layoutType = LayoutType_None,
	ResizeMode resizeMode = ResizeMode_None,
	float spacingX = 0.0f,
	float spacingY = 0.0f,
	bool affectedByScale = false,
	AxisDirection axisDirection = AxisDirection_Horizontal,
	const Size* cellSize = 0,
	float paddingLeft = 0.0f,
	float paddingRight = 0.0f,
	float paddingTop = 0.0f,
	float paddingBottom = 0.0f,
	VerticalDirection verticalDirection = VerticalDirection_BottomToTop,
	HorizontalDirection horizontalDirection = HorizontalDirection_LeftToRight)
{
	LayoutBuilder builder_(_fbb);
	builder_.add_paddingBottom(paddingBottom);
	builder_.add_paddingTop(paddingTop);
	builder_.add_paddingRight(paddingRight);
	builder_.add_paddingLeft(paddingLeft);
	builder_.add_cellSize(cellSize);
	builder_.add_spacingY(spacingY);
	builder_.add_spacingX(spacingX);
	builder_.add_node(node);
	builder_.add_horizontalDirection(horizontalDirection);
	builder_.add_verticalDirection(verticalDirection);
	builder_.add_axisDirection(axisDirection);
	builder_.add_affectedByScale(affectedByScale);
	builder_.add_resizeMode(resizeMode);
	builder_.add_layoutType(layoutType);
	return builder_.Finish();
}

struct EditBox FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_NODE = 4,
		VT_BACKGROUNDIMAGE = 6,
		VT_RETURNTYPE = 8,
		VT_INPUTFLAG = 10,
		VT_INPUTMODE = 12,
		VT_FONTSIZE = 14,
		VT_FONTCOLOR = 16,
		VT_PLACEHOLDER = 18,
		VT_PLACEHOLDERFONTSIZE = 20,
		VT_PLACEHOLDERFONTCOLOR = 22,
		VT_MAXLENGTH = 24,
		VT_TEXT = 26,
		VT_HORIZONTALALIGNMENT = 28,
		VT_VERTICALALIGNMENT = 30
	};
	const Node* node() const
	{
		return GetPointer<const Node*>(VT_NODE);
	}
	const flatbuffers::String* backgroundImage() const
	{
		return GetPointer<const flatbuffers::String*>(VT_BACKGROUNDIMAGE);
	}
	EditBoxReturnType returnType() const
	{
		return static_cast<EditBoxReturnType>(GetField<int8_t>(VT_RETURNTYPE, 0));
	}
	EditBoxInputFlag inputFlag() const
	{
		return static_cast<EditBoxInputFlag>(GetField<int8_t>(VT_INPUTFLAG, 0));
	}
	EditBoxInputMode inputMode() const
	{
		return static_cast<EditBoxInputMode>(GetField<int8_t>(VT_INPUTMODE, 0));
	}
	int32_t fontSize() const
	{
		return GetField<int32_t>(VT_FONTSIZE, 0);
	}
	const ColorRGB* fontColor() const
	{
		return GetStruct<const ColorRGB*>(VT_FONTCOLOR);
	}
	const flatbuffers::String* placeholder() const
	{
		return GetPointer<const flatbuffers::String*>(VT_PLACEHOLDER);
	}
	int32_t placeholderFontSize() const
	{
		return GetField<int32_t>(VT_PLACEHOLDERFONTSIZE, 0);
	}
	const ColorRGB* placeholderFontColor() const
	{
		return GetStruct<const ColorRGB*>(VT_PLACEHOLDERFONTCOLOR);
	}
	int32_t maxLength() const
	{
		return GetField<int32_t>(VT_MAXLENGTH, 0);
	}
	const flatbuffers::String* text() const
	{
		return GetPointer<const flatbuffers::String*>(VT_TEXT);
	}
	HorizontalAlignment horizontalAlignment() const
	{
		return static_cast<HorizontalAlignment>(GetField<int8_t>(VT_HORIZONTALALIGNMENT, 0));
	}
	VerticalAlignment verticalAlignment() const
	{
		return static_cast<VerticalAlignment>(GetField<int8_t>(VT_VERTICALALIGNMENT, 0));
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyOffset(verifier, VT_NODE) &&
			   verifier.VerifyTable(node()) &&
			   VerifyOffset(verifier, VT_BACKGROUNDIMAGE) &&
			   verifier.VerifyString(backgroundImage()) &&
			   VerifyField<int8_t>(verifier, VT_RETURNTYPE) &&
			   VerifyField<int8_t>(verifier, VT_INPUTFLAG) &&
			   VerifyField<int8_t>(verifier, VT_INPUTMODE) &&
			   VerifyField<int32_t>(verifier, VT_FONTSIZE) &&
			   VerifyField<ColorRGB>(verifier, VT_FONTCOLOR) &&
			   VerifyOffset(verifier, VT_PLACEHOLDER) &&
			   verifier.VerifyString(placeholder()) &&
			   VerifyField<int32_t>(verifier, VT_PLACEHOLDERFONTSIZE) &&
			   VerifyField<ColorRGB>(verifier, VT_PLACEHOLDERFONTCOLOR) &&
			   VerifyField<int32_t>(verifier, VT_MAXLENGTH) &&
			   VerifyOffset(verifier, VT_TEXT) &&
			   verifier.VerifyString(text()) &&
			   VerifyField<int8_t>(verifier, VT_HORIZONTALALIGNMENT) &&
			   VerifyField<int8_t>(verifier, VT_VERTICALALIGNMENT) &&
			   verifier.EndTable();
	}
};

struct EditBoxBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_node(flatbuffers::Offset<Node> node)
	{
		fbb_.AddOffset(EditBox::VT_NODE, node);
	}
	void add_backgroundImage(flatbuffers::Offset<flatbuffers::String> backgroundImage)
	{
		fbb_.AddOffset(EditBox::VT_BACKGROUNDIMAGE, backgroundImage);
	}
	void add_returnType(EditBoxReturnType returnType)
	{
		fbb_.AddElement<int8_t>(EditBox::VT_RETURNTYPE, static_cast<int8_t>(returnType), 0);
	}
	void add_inputFlag(EditBoxInputFlag inputFlag)
	{
		fbb_.AddElement<int8_t>(EditBox::VT_INPUTFLAG, static_cast<int8_t>(inputFlag), 0);
	}
	void add_inputMode(EditBoxInputMode inputMode)
	{
		fbb_.AddElement<int8_t>(EditBox::VT_INPUTMODE, static_cast<int8_t>(inputMode), 0);
	}
	void add_fontSize(int32_t fontSize)
	{
		fbb_.AddElement<int32_t>(EditBox::VT_FONTSIZE, fontSize, 0);
	}
	void add_fontColor(const ColorRGB* fontColor)
	{
		fbb_.AddStruct(EditBox::VT_FONTCOLOR, fontColor);
	}
	void add_placeholder(flatbuffers::Offset<flatbuffers::String> placeholder)
	{
		fbb_.AddOffset(EditBox::VT_PLACEHOLDER, placeholder);
	}
	void add_placeholderFontSize(int32_t placeholderFontSize)
	{
		fbb_.AddElement<int32_t>(EditBox::VT_PLACEHOLDERFONTSIZE, placeholderFontSize, 0);
	}
	void add_placeholderFontColor(const ColorRGB* placeholderFontColor)
	{
		fbb_.AddStruct(EditBox::VT_PLACEHOLDERFONTCOLOR, placeholderFontColor);
	}
	void add_maxLength(int32_t maxLength)
	{
		fbb_.AddElement<int32_t>(EditBox::VT_MAXLENGTH, maxLength, 0);
	}
	void add_text(flatbuffers::Offset<flatbuffers::String> text)
	{
		fbb_.AddOffset(EditBox::VT_TEXT, text);
	}
	void add_horizontalAlignment(HorizontalAlignment horizontalAlignment)
	{
		fbb_.AddElement<int8_t>(EditBox::VT_HORIZONTALALIGNMENT, static_cast<int8_t>(horizontalAlignment), 0);
	}
	void add_verticalAlignment(VerticalAlignment verticalAlignment)
	{
		fbb_.AddElement<int8_t>(EditBox::VT_VERTICALALIGNMENT, static_cast<int8_t>(verticalAlignment), 0);
	}
	explicit EditBoxBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	EditBoxBuilder& operator=(const EditBoxBuilder&);
	flatbuffers::Offset<EditBox> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<EditBox>(end);
		return o;
	}
};

inline flatbuffers::Offset<EditBox> CreateEditBox(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	flatbuffers::Offset<flatbuffers::String> backgroundImage = 0,
	EditBoxReturnType returnType = EditBoxReturnType_Default,
	EditBoxInputFlag inputFlag = EditBoxInputFlag_Password,
	EditBoxInputMode inputMode = EditBoxInputMode_Any,
	int32_t fontSize = 0,
	const ColorRGB* fontColor = 0,
	flatbuffers::Offset<flatbuffers::String> placeholder = 0,
	int32_t placeholderFontSize = 0,
	const ColorRGB* placeholderFontColor = 0,
	int32_t maxLength = 0,
	flatbuffers::Offset<flatbuffers::String> text = 0,
	HorizontalAlignment horizontalAlignment = HorizontalAlignment_Left,
	VerticalAlignment verticalAlignment = VerticalAlignment_Top)
{
	EditBoxBuilder builder_(_fbb);
	builder_.add_text(text);
	builder_.add_maxLength(maxLength);
	builder_.add_placeholderFontColor(placeholderFontColor);
	builder_.add_placeholderFontSize(placeholderFontSize);
	builder_.add_placeholder(placeholder);
	builder_.add_fontColor(fontColor);
	builder_.add_fontSize(fontSize);
	builder_.add_backgroundImage(backgroundImage);
	builder_.add_node(node);
	builder_.add_verticalAlignment(verticalAlignment);
	builder_.add_horizontalAlignment(horizontalAlignment);
	builder_.add_inputMode(inputMode);
	builder_.add_inputFlag(inputFlag);
	builder_.add_returnType(returnType);
	return builder_.Finish();
}

inline flatbuffers::Offset<EditBox> CreateEditBoxDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	const char* backgroundImage = nullptr,
	EditBoxReturnType returnType = EditBoxReturnType_Default,
	EditBoxInputFlag inputFlag = EditBoxInputFlag_Password,
	EditBoxInputMode inputMode = EditBoxInputMode_Any,
	int32_t fontSize = 0,
	const ColorRGB* fontColor = 0,
	const char* placeholder = nullptr,
	int32_t placeholderFontSize = 0,
	const ColorRGB* placeholderFontColor = 0,
	int32_t maxLength = 0,
	const char* text = nullptr,
	HorizontalAlignment horizontalAlignment = HorizontalAlignment_Left,
	VerticalAlignment verticalAlignment = VerticalAlignment_Top)
{
	return creator::buffers::CreateEditBox(
		_fbb,
		node,
		backgroundImage ? _fbb.CreateString(backgroundImage) : 0,
		returnType,
		inputFlag,
		inputMode,
		fontSize,
		fontColor,
		placeholder ? _fbb.CreateString(placeholder) : 0,
		placeholderFontSize,
		placeholderFontColor,
		maxLength,
		text ? _fbb.CreateString(text) : 0,
		horizontalAlignment,
		verticalAlignment);
}

struct VideoPlayer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_NODE = 4,
		VT_ISLOCAL = 6,
		VT_URL = 8,
		VT_FULLSCREEN = 10,
		VT_KEEPASPECT = 12
	};
	const Node* node() const
	{
		return GetPointer<const Node*>(VT_NODE);
	}
	bool isLocal() const
	{
		return GetField<uint8_t>(VT_ISLOCAL, 0) != 0;
	}
	const flatbuffers::String* url() const
	{
		return GetPointer<const flatbuffers::String*>(VT_URL);
	}
	bool fullScreen() const
	{
		return GetField<uint8_t>(VT_FULLSCREEN, 0) != 0;
	}
	bool keepAspect() const
	{
		return GetField<uint8_t>(VT_KEEPASPECT, 0) != 0;
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyOffset(verifier, VT_NODE) &&
			   verifier.VerifyTable(node()) &&
			   VerifyField<uint8_t>(verifier, VT_ISLOCAL) &&
			   VerifyOffset(verifier, VT_URL) &&
			   verifier.VerifyString(url()) &&
			   VerifyField<uint8_t>(verifier, VT_FULLSCREEN) &&
			   VerifyField<uint8_t>(verifier, VT_KEEPASPECT) &&
			   verifier.EndTable();
	}
};

struct VideoPlayerBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_node(flatbuffers::Offset<Node> node)
	{
		fbb_.AddOffset(VideoPlayer::VT_NODE, node);
	}
	void add_isLocal(bool isLocal)
	{
		fbb_.AddElement<uint8_t>(VideoPlayer::VT_ISLOCAL, static_cast<uint8_t>(isLocal), 0);
	}
	void add_url(flatbuffers::Offset<flatbuffers::String> url)
	{
		fbb_.AddOffset(VideoPlayer::VT_URL, url);
	}
	void add_fullScreen(bool fullScreen)
	{
		fbb_.AddElement<uint8_t>(VideoPlayer::VT_FULLSCREEN, static_cast<uint8_t>(fullScreen), 0);
	}
	void add_keepAspect(bool keepAspect)
	{
		fbb_.AddElement<uint8_t>(VideoPlayer::VT_KEEPASPECT, static_cast<uint8_t>(keepAspect), 0);
	}
	explicit VideoPlayerBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	VideoPlayerBuilder& operator=(const VideoPlayerBuilder&);
	flatbuffers::Offset<VideoPlayer> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<VideoPlayer>(end);
		return o;
	}
};

inline flatbuffers::Offset<VideoPlayer> CreateVideoPlayer(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	bool isLocal = false,
	flatbuffers::Offset<flatbuffers::String> url = 0,
	bool fullScreen = false,
	bool keepAspect = false)
{
	VideoPlayerBuilder builder_(_fbb);
	builder_.add_url(url);
	builder_.add_node(node);
	builder_.add_keepAspect(keepAspect);
	builder_.add_fullScreen(fullScreen);
	builder_.add_isLocal(isLocal);
	return builder_.Finish();
}

inline flatbuffers::Offset<VideoPlayer> CreateVideoPlayerDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	bool isLocal = false,
	const char* url = nullptr,
	bool fullScreen = false,
	bool keepAspect = false)
{
	return creator::buffers::CreateVideoPlayer(
		_fbb,
		node,
		isLocal,
		url ? _fbb.CreateString(url) : 0,
		fullScreen,
		keepAspect);
}

struct WebView FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_NODE = 4,
		VT_URL = 6
	};
	const Node* node() const
	{
		return GetPointer<const Node*>(VT_NODE);
	}
	const flatbuffers::String* url() const
	{
		return GetPointer<const flatbuffers::String*>(VT_URL);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyOffset(verifier, VT_NODE) &&
			   verifier.VerifyTable(node()) &&
			   VerifyOffset(verifier, VT_URL) &&
			   verifier.VerifyString(url()) &&
			   verifier.EndTable();
	}
};

struct WebViewBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_node(flatbuffers::Offset<Node> node)
	{
		fbb_.AddOffset(WebView::VT_NODE, node);
	}
	void add_url(flatbuffers::Offset<flatbuffers::String> url)
	{
		fbb_.AddOffset(WebView::VT_URL, url);
	}
	explicit WebViewBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	WebViewBuilder& operator=(const WebViewBuilder&);
	flatbuffers::Offset<WebView> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<WebView>(end);
		return o;
	}
};

inline flatbuffers::Offset<WebView> CreateWebView(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	flatbuffers::Offset<flatbuffers::String> url = 0)
{
	WebViewBuilder builder_(_fbb);
	builder_.add_url(url);
	builder_.add_node(node);
	return builder_.Finish();
}

inline flatbuffers::Offset<WebView> CreateWebViewDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	const char* url = nullptr)
{
	return creator::buffers::CreateWebView(
		_fbb,
		node,
		url ? _fbb.CreateString(url) : 0);
}

struct Slider FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_NODE = 4,
		VT_PERCENT = 6,
		VT_BARTEXTUREPATH = 8,
		VT_BARSIZE = 10,
		VT_NORMALTEXTUREPATH = 12,
		VT_PRESSEDTEXTUREPATH = 14,
		VT_DISABLEDTEXTUREPATH = 16,
		VT_BALLSIZE = 18
	};
	const Node* node() const
	{
		return GetPointer<const Node*>(VT_NODE);
	}
	int32_t percent() const
	{
		return GetField<int32_t>(VT_PERCENT, 0);
	}
	const flatbuffers::String* barTexturePath() const
	{
		return GetPointer<const flatbuffers::String*>(VT_BARTEXTUREPATH);
	}
	const Size* barSize() const
	{
		return GetStruct<const Size*>(VT_BARSIZE);
	}
	const flatbuffers::String* normalTexturePath() const
	{
		return GetPointer<const flatbuffers::String*>(VT_NORMALTEXTUREPATH);
	}
	const flatbuffers::String* pressedTexturePath() const
	{
		return GetPointer<const flatbuffers::String*>(VT_PRESSEDTEXTUREPATH);
	}
	const flatbuffers::String* disabledTexturePath() const
	{
		return GetPointer<const flatbuffers::String*>(VT_DISABLEDTEXTUREPATH);
	}
	const Size* ballSize() const
	{
		return GetStruct<const Size*>(VT_BALLSIZE);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyOffset(verifier, VT_NODE) &&
			   verifier.VerifyTable(node()) &&
			   VerifyField<int32_t>(verifier, VT_PERCENT) &&
			   VerifyOffset(verifier, VT_BARTEXTUREPATH) &&
			   verifier.VerifyString(barTexturePath()) &&
			   VerifyField<Size>(verifier, VT_BARSIZE) &&
			   VerifyOffset(verifier, VT_NORMALTEXTUREPATH) &&
			   verifier.VerifyString(normalTexturePath()) &&
			   VerifyOffset(verifier, VT_PRESSEDTEXTUREPATH) &&
			   verifier.VerifyString(pressedTexturePath()) &&
			   VerifyOffset(verifier, VT_DISABLEDTEXTUREPATH) &&
			   verifier.VerifyString(disabledTexturePath()) &&
			   VerifyField<Size>(verifier, VT_BALLSIZE) &&
			   verifier.EndTable();
	}
};

struct SliderBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_node(flatbuffers::Offset<Node> node)
	{
		fbb_.AddOffset(Slider::VT_NODE, node);
	}
	void add_percent(int32_t percent)
	{
		fbb_.AddElement<int32_t>(Slider::VT_PERCENT, percent, 0);
	}
	void add_barTexturePath(flatbuffers::Offset<flatbuffers::String> barTexturePath)
	{
		fbb_.AddOffset(Slider::VT_BARTEXTUREPATH, barTexturePath);
	}
	void add_barSize(const Size* barSize)
	{
		fbb_.AddStruct(Slider::VT_BARSIZE, barSize);
	}
	void add_normalTexturePath(flatbuffers::Offset<flatbuffers::String> normalTexturePath)
	{
		fbb_.AddOffset(Slider::VT_NORMALTEXTUREPATH, normalTexturePath);
	}
	void add_pressedTexturePath(flatbuffers::Offset<flatbuffers::String> pressedTexturePath)
	{
		fbb_.AddOffset(Slider::VT_PRESSEDTEXTUREPATH, pressedTexturePath);
	}
	void add_disabledTexturePath(flatbuffers::Offset<flatbuffers::String> disabledTexturePath)
	{
		fbb_.AddOffset(Slider::VT_DISABLEDTEXTUREPATH, disabledTexturePath);
	}
	void add_ballSize(const Size* ballSize)
	{
		fbb_.AddStruct(Slider::VT_BALLSIZE, ballSize);
	}
	explicit SliderBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	SliderBuilder& operator=(const SliderBuilder&);
	flatbuffers::Offset<Slider> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Slider>(end);
		return o;
	}
};

inline flatbuffers::Offset<Slider> CreateSlider(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	int32_t percent = 0,
	flatbuffers::Offset<flatbuffers::String> barTexturePath = 0,
	const Size* barSize = 0,
	flatbuffers::Offset<flatbuffers::String> normalTexturePath = 0,
	flatbuffers::Offset<flatbuffers::String> pressedTexturePath = 0,
	flatbuffers::Offset<flatbuffers::String> disabledTexturePath = 0,
	const Size* ballSize = 0)
{
	SliderBuilder builder_(_fbb);
	builder_.add_ballSize(ballSize);
	builder_.add_disabledTexturePath(disabledTexturePath);
	builder_.add_pressedTexturePath(pressedTexturePath);
	builder_.add_normalTexturePath(normalTexturePath);
	builder_.add_barSize(barSize);
	builder_.add_barTexturePath(barTexturePath);
	builder_.add_percent(percent);
	builder_.add_node(node);
	return builder_.Finish();
}

inline flatbuffers::Offset<Slider> CreateSliderDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	int32_t percent = 0,
	const char* barTexturePath = nullptr,
	const Size* barSize = 0,
	const char* normalTexturePath = nullptr,
	const char* pressedTexturePath = nullptr,
	const char* disabledTexturePath = nullptr,
	const Size* ballSize = 0)
{
	return creator::buffers::CreateSlider(
		_fbb,
		node,
		percent,
		barTexturePath ? _fbb.CreateString(barTexturePath) : 0,
		barSize,
		normalTexturePath ? _fbb.CreateString(normalTexturePath) : 0,
		pressedTexturePath ? _fbb.CreateString(pressedTexturePath) : 0,
		disabledTexturePath ? _fbb.CreateString(disabledTexturePath) : 0,
		ballSize);
}

struct Toggle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_NODE = 4,
		VT_INTERACTABLE = 6,
		VT_ENABLEAUTOGRAYEFFECT = 8,
		VT_ISCHECKED = 10,
		VT_BACKGROUNDSPRITEPATH = 12,
		VT_CHECKMARKSPRITEPATH = 14,
		VT_ZOOMSCALE = 16
	};
	const Node* node() const
	{
		return GetPointer<const Node*>(VT_NODE);
	}
	bool interactable() const
	{
		return GetField<uint8_t>(VT_INTERACTABLE, 0) != 0;
	}
	bool enableAutoGrayEffect() const
	{
		return GetField<uint8_t>(VT_ENABLEAUTOGRAYEFFECT, 0) != 0;
	}
	bool isChecked() const
	{
		return GetField<uint8_t>(VT_ISCHECKED, 0) != 0;
	}
	const flatbuffers::String* backgroundSpritePath() const
	{
		return GetPointer<const flatbuffers::String*>(VT_BACKGROUNDSPRITEPATH);
	}
	const flatbuffers::String* checkMarkSpritePath() const
	{
		return GetPointer<const flatbuffers::String*>(VT_CHECKMARKSPRITEPATH);
	}
	float zoomScale() const
	{
		return GetField<float>(VT_ZOOMSCALE, 0.0f);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyOffset(verifier, VT_NODE) &&
			   verifier.VerifyTable(node()) &&
			   VerifyField<uint8_t>(verifier, VT_INTERACTABLE) &&
			   VerifyField<uint8_t>(verifier, VT_ENABLEAUTOGRAYEFFECT) &&
			   VerifyField<uint8_t>(verifier, VT_ISCHECKED) &&
			   VerifyOffset(verifier, VT_BACKGROUNDSPRITEPATH) &&
			   verifier.VerifyString(backgroundSpritePath()) &&
			   VerifyOffset(verifier, VT_CHECKMARKSPRITEPATH) &&
			   verifier.VerifyString(checkMarkSpritePath()) &&
			   VerifyField<float>(verifier, VT_ZOOMSCALE) &&
			   verifier.EndTable();
	}
};

struct ToggleBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_node(flatbuffers::Offset<Node> node)
	{
		fbb_.AddOffset(Toggle::VT_NODE, node);
	}
	void add_interactable(bool interactable)
	{
		fbb_.AddElement<uint8_t>(Toggle::VT_INTERACTABLE, static_cast<uint8_t>(interactable), 0);
	}
	void add_enableAutoGrayEffect(bool enableAutoGrayEffect)
	{
		fbb_.AddElement<uint8_t>(Toggle::VT_ENABLEAUTOGRAYEFFECT, static_cast<uint8_t>(enableAutoGrayEffect), 0);
	}
	void add_isChecked(bool isChecked)
	{
		fbb_.AddElement<uint8_t>(Toggle::VT_ISCHECKED, static_cast<uint8_t>(isChecked), 0);
	}
	void add_backgroundSpritePath(flatbuffers::Offset<flatbuffers::String> backgroundSpritePath)
	{
		fbb_.AddOffset(Toggle::VT_BACKGROUNDSPRITEPATH, backgroundSpritePath);
	}
	void add_checkMarkSpritePath(flatbuffers::Offset<flatbuffers::String> checkMarkSpritePath)
	{
		fbb_.AddOffset(Toggle::VT_CHECKMARKSPRITEPATH, checkMarkSpritePath);
	}
	void add_zoomScale(float zoomScale)
	{
		fbb_.AddElement<float>(Toggle::VT_ZOOMSCALE, zoomScale, 0.0f);
	}
	explicit ToggleBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	ToggleBuilder& operator=(const ToggleBuilder&);
	flatbuffers::Offset<Toggle> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Toggle>(end);
		return o;
	}
};

inline flatbuffers::Offset<Toggle> CreateToggle(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	bool interactable = false,
	bool enableAutoGrayEffect = false,
	bool isChecked = false,
	flatbuffers::Offset<flatbuffers::String> backgroundSpritePath = 0,
	flatbuffers::Offset<flatbuffers::String> checkMarkSpritePath = 0,
	float zoomScale = 0.0f)
{
	ToggleBuilder builder_(_fbb);
	builder_.add_zoomScale(zoomScale);
	builder_.add_checkMarkSpritePath(checkMarkSpritePath);
	builder_.add_backgroundSpritePath(backgroundSpritePath);
	builder_.add_node(node);
	builder_.add_isChecked(isChecked);
	builder_.add_enableAutoGrayEffect(enableAutoGrayEffect);
	builder_.add_interactable(interactable);
	return builder_.Finish();
}

inline flatbuffers::Offset<Toggle> CreateToggleDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	bool interactable = false,
	bool enableAutoGrayEffect = false,
	bool isChecked = false,
	const char* backgroundSpritePath = nullptr,
	const char* checkMarkSpritePath = nullptr,
	float zoomScale = 0.0f)
{
	return creator::buffers::CreateToggle(
		_fbb,
		node,
		interactable,
		enableAutoGrayEffect,
		isChecked,
		backgroundSpritePath ? _fbb.CreateString(backgroundSpritePath) : 0,
		checkMarkSpritePath ? _fbb.CreateString(checkMarkSpritePath) : 0,
		zoomScale);
}

struct ToggleGroup FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_NODE = 4,
		VT_ALLOWSWITCHOFF = 6,
		VT_TOGGLES = 8
	};
	const Node* node() const
	{
		return GetPointer<const Node*>(VT_NODE);
	}
	bool allowSwitchOff() const
	{
		return GetField<uint8_t>(VT_ALLOWSWITCHOFF, 0) != 0;
	}
	const flatbuffers::Vector<flatbuffers::Offset<Toggle>>* toggles() const
	{
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Toggle>>*>(VT_TOGGLES);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyOffset(verifier, VT_NODE) &&
			   verifier.VerifyTable(node()) &&
			   VerifyField<uint8_t>(verifier, VT_ALLOWSWITCHOFF) &&
			   VerifyOffset(verifier, VT_TOGGLES) &&
			   verifier.VerifyVector(toggles()) &&
			   verifier.VerifyVectorOfTables(toggles()) &&
			   verifier.EndTable();
	}
};

struct ToggleGroupBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_node(flatbuffers::Offset<Node> node)
	{
		fbb_.AddOffset(ToggleGroup::VT_NODE, node);
	}
	void add_allowSwitchOff(bool allowSwitchOff)
	{
		fbb_.AddElement<uint8_t>(ToggleGroup::VT_ALLOWSWITCHOFF, static_cast<uint8_t>(allowSwitchOff), 0);
	}
	void add_toggles(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Toggle>>> toggles)
	{
		fbb_.AddOffset(ToggleGroup::VT_TOGGLES, toggles);
	}
	explicit ToggleGroupBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	ToggleGroupBuilder& operator=(const ToggleGroupBuilder&);
	flatbuffers::Offset<ToggleGroup> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<ToggleGroup>(end);
		return o;
	}
};

inline flatbuffers::Offset<ToggleGroup> CreateToggleGroup(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	bool allowSwitchOff = false,
	flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Toggle>>> toggles = 0)
{
	ToggleGroupBuilder builder_(_fbb);
	builder_.add_toggles(toggles);
	builder_.add_node(node);
	builder_.add_allowSwitchOff(allowSwitchOff);
	return builder_.Finish();
}

inline flatbuffers::Offset<ToggleGroup> CreateToggleGroupDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	bool allowSwitchOff = false,
	const std::vector<flatbuffers::Offset<Toggle>>* toggles = nullptr)
{
	return creator::buffers::CreateToggleGroup(
		_fbb,
		node,
		allowSwitchOff,
		toggles ? _fbb.CreateVector<flatbuffers::Offset<Toggle>>(*toggles) : 0);
}

struct Mask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_NODE = 4,
		VT_TYPE = 6,
		VT_INVERTED = 8,
		VT_SEGMENTS = 10,
		VT_ALPHATHRESHOLD = 12,
		VT_SPRITEFRAME = 14
	};
	const Node* node() const
	{
		return GetPointer<const Node*>(VT_NODE);
	}
	MaskType type() const
	{
		return static_cast<MaskType>(GetField<int8_t>(VT_TYPE, 0));
	}
	bool inverted() const
	{
		return GetField<uint8_t>(VT_INVERTED, 0) != 0;
	}
	int32_t segments() const
	{
		return GetField<int32_t>(VT_SEGMENTS, 0);
	}
	float alphaThreshold() const
	{
		return GetField<float>(VT_ALPHATHRESHOLD, 0.0f);
	}
	const flatbuffers::String* spriteFrame() const
	{
		return GetPointer<const flatbuffers::String*>(VT_SPRITEFRAME);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyOffset(verifier, VT_NODE) &&
			   verifier.VerifyTable(node()) &&
			   VerifyField<int8_t>(verifier, VT_TYPE) &&
			   VerifyField<uint8_t>(verifier, VT_INVERTED) &&
			   VerifyField<int32_t>(verifier, VT_SEGMENTS) &&
			   VerifyField<float>(verifier, VT_ALPHATHRESHOLD) &&
			   VerifyOffset(verifier, VT_SPRITEFRAME) &&
			   verifier.VerifyString(spriteFrame()) &&
			   verifier.EndTable();
	}
};

struct MaskBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_node(flatbuffers::Offset<Node> node)
	{
		fbb_.AddOffset(Mask::VT_NODE, node);
	}
	void add_type(MaskType type)
	{
		fbb_.AddElement<int8_t>(Mask::VT_TYPE, static_cast<int8_t>(type), 0);
	}
	void add_inverted(bool inverted)
	{
		fbb_.AddElement<uint8_t>(Mask::VT_INVERTED, static_cast<uint8_t>(inverted), 0);
	}
	void add_segments(int32_t segments)
	{
		fbb_.AddElement<int32_t>(Mask::VT_SEGMENTS, segments, 0);
	}
	void add_alphaThreshold(float alphaThreshold)
	{
		fbb_.AddElement<float>(Mask::VT_ALPHATHRESHOLD, alphaThreshold, 0.0f);
	}
	void add_spriteFrame(flatbuffers::Offset<flatbuffers::String> spriteFrame)
	{
		fbb_.AddOffset(Mask::VT_SPRITEFRAME, spriteFrame);
	}
	explicit MaskBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	MaskBuilder& operator=(const MaskBuilder&);
	flatbuffers::Offset<Mask> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Mask>(end);
		return o;
	}
};

inline flatbuffers::Offset<Mask> CreateMask(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	MaskType type = MaskType_Rect,
	bool inverted = false,
	int32_t segments = 0,
	float alphaThreshold = 0.0f,
	flatbuffers::Offset<flatbuffers::String> spriteFrame = 0)
{
	MaskBuilder builder_(_fbb);
	builder_.add_spriteFrame(spriteFrame);
	builder_.add_alphaThreshold(alphaThreshold);
	builder_.add_segments(segments);
	builder_.add_node(node);
	builder_.add_inverted(inverted);
	builder_.add_type(type);
	return builder_.Finish();
}

inline flatbuffers::Offset<Mask> CreateMaskDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	MaskType type = MaskType_Rect,
	bool inverted = false,
	int32_t segments = 0,
	float alphaThreshold = 0.0f,
	const char* spriteFrame = nullptr)
{
	return creator::buffers::CreateMask(
		_fbb,
		node,
		type,
		inverted,
		segments,
		alphaThreshold,
		spriteFrame ? _fbb.CreateString(spriteFrame) : 0);
}

struct PageViewIndicator FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_POSITIONANCHOR = 4,
		VT_SPRITEFRAME = 6,
		VT_SPRITEFRAMEFROMTP = 8,
		VT_SPACE = 10,
		VT_DIRECTION = 12
	};
	const Vec2* positionAnchor() const
	{
		return GetStruct<const Vec2*>(VT_POSITIONANCHOR);
	}
	const flatbuffers::String* spriteFrame() const
	{
		return GetPointer<const flatbuffers::String*>(VT_SPRITEFRAME);
	}
	bool spriteFrameFromTP() const
	{
		return GetField<uint8_t>(VT_SPRITEFRAMEFROMTP, 0) != 0;
	}
	float space() const
	{
		return GetField<float>(VT_SPACE, 0.0f);
	}
	int32_t direction() const
	{
		return GetField<int32_t>(VT_DIRECTION, 0);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyField<Vec2>(verifier, VT_POSITIONANCHOR) &&
			   VerifyOffset(verifier, VT_SPRITEFRAME) &&
			   verifier.VerifyString(spriteFrame()) &&
			   VerifyField<uint8_t>(verifier, VT_SPRITEFRAMEFROMTP) &&
			   VerifyField<float>(verifier, VT_SPACE) &&
			   VerifyField<int32_t>(verifier, VT_DIRECTION) &&
			   verifier.EndTable();
	}
};

struct PageViewIndicatorBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_positionAnchor(const Vec2* positionAnchor)
	{
		fbb_.AddStruct(PageViewIndicator::VT_POSITIONANCHOR, positionAnchor);
	}
	void add_spriteFrame(flatbuffers::Offset<flatbuffers::String> spriteFrame)
	{
		fbb_.AddOffset(PageViewIndicator::VT_SPRITEFRAME, spriteFrame);
	}
	void add_spriteFrameFromTP(bool spriteFrameFromTP)
	{
		fbb_.AddElement<uint8_t>(PageViewIndicator::VT_SPRITEFRAMEFROMTP, static_cast<uint8_t>(spriteFrameFromTP), 0);
	}
	void add_space(float space)
	{
		fbb_.AddElement<float>(PageViewIndicator::VT_SPACE, space, 0.0f);
	}
	void add_direction(int32_t direction)
	{
		fbb_.AddElement<int32_t>(PageViewIndicator::VT_DIRECTION, direction, 0);
	}
	explicit PageViewIndicatorBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	PageViewIndicatorBuilder& operator=(const PageViewIndicatorBuilder&);
	flatbuffers::Offset<PageViewIndicator> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<PageViewIndicator>(end);
		return o;
	}
};

inline flatbuffers::Offset<PageViewIndicator> CreatePageViewIndicator(
	flatbuffers::FlatBufferBuilder& _fbb,
	const Vec2* positionAnchor = 0,
	flatbuffers::Offset<flatbuffers::String> spriteFrame = 0,
	bool spriteFrameFromTP = false,
	float space = 0.0f,
	int32_t direction = 0)
{
	PageViewIndicatorBuilder builder_(_fbb);
	builder_.add_direction(direction);
	builder_.add_space(space);
	builder_.add_spriteFrame(spriteFrame);
	builder_.add_positionAnchor(positionAnchor);
	builder_.add_spriteFrameFromTP(spriteFrameFromTP);
	return builder_.Finish();
}

inline flatbuffers::Offset<PageViewIndicator> CreatePageViewIndicatorDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	const Vec2* positionAnchor = 0,
	const char* spriteFrame = nullptr,
	bool spriteFrameFromTP = false,
	float space = 0.0f,
	int32_t direction = 0)
{
	return creator::buffers::CreatePageViewIndicator(
		_fbb,
		positionAnchor,
		spriteFrame ? _fbb.CreateString(spriteFrame) : 0,
		spriteFrameFromTP,
		space,
		direction);
}

struct PageViewPage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_NODE = 4,
		VT_SPRITEFRAME = 6,
		VT_SPRITEFRAMEFROMTP = 8,
		VT_SCALE9ENABLED = 10
	};
	const Node* node() const
	{
		return GetPointer<const Node*>(VT_NODE);
	}
	const flatbuffers::String* spriteFrame() const
	{
		return GetPointer<const flatbuffers::String*>(VT_SPRITEFRAME);
	}
	bool spriteFrameFromTP() const
	{
		return GetField<uint8_t>(VT_SPRITEFRAMEFROMTP, 0) != 0;
	}
	bool scale9Enabled() const
	{
		return GetField<uint8_t>(VT_SCALE9ENABLED, 0) != 0;
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyOffset(verifier, VT_NODE) &&
			   verifier.VerifyTable(node()) &&
			   VerifyOffset(verifier, VT_SPRITEFRAME) &&
			   verifier.VerifyString(spriteFrame()) &&
			   VerifyField<uint8_t>(verifier, VT_SPRITEFRAMEFROMTP) &&
			   VerifyField<uint8_t>(verifier, VT_SCALE9ENABLED) &&
			   verifier.EndTable();
	}
};

struct PageViewPageBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_node(flatbuffers::Offset<Node> node)
	{
		fbb_.AddOffset(PageViewPage::VT_NODE, node);
	}
	void add_spriteFrame(flatbuffers::Offset<flatbuffers::String> spriteFrame)
	{
		fbb_.AddOffset(PageViewPage::VT_SPRITEFRAME, spriteFrame);
	}
	void add_spriteFrameFromTP(bool spriteFrameFromTP)
	{
		fbb_.AddElement<uint8_t>(PageViewPage::VT_SPRITEFRAMEFROMTP, static_cast<uint8_t>(spriteFrameFromTP), 0);
	}
	void add_scale9Enabled(bool scale9Enabled)
	{
		fbb_.AddElement<uint8_t>(PageViewPage::VT_SCALE9ENABLED, static_cast<uint8_t>(scale9Enabled), 0);
	}
	explicit PageViewPageBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	PageViewPageBuilder& operator=(const PageViewPageBuilder&);
	flatbuffers::Offset<PageViewPage> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<PageViewPage>(end);
		return o;
	}
};

inline flatbuffers::Offset<PageViewPage> CreatePageViewPage(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	flatbuffers::Offset<flatbuffers::String> spriteFrame = 0,
	bool spriteFrameFromTP = false,
	bool scale9Enabled = false)
{
	PageViewPageBuilder builder_(_fbb);
	builder_.add_spriteFrame(spriteFrame);
	builder_.add_node(node);
	builder_.add_scale9Enabled(scale9Enabled);
	builder_.add_spriteFrameFromTP(spriteFrameFromTP);
	return builder_.Finish();
}

inline flatbuffers::Offset<PageViewPage> CreatePageViewPageDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	const char* spriteFrame = nullptr,
	bool spriteFrameFromTP = false,
	bool scale9Enabled = false)
{
	return creator::buffers::CreatePageViewPage(
		_fbb,
		node,
		spriteFrame ? _fbb.CreateString(spriteFrame) : 0,
		spriteFrameFromTP,
		scale9Enabled);
}

struct PageViewBackground FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_SPRITEFRAME = 4,
		VT_SPRITEFRAMEFROMTP = 6
	};
	const flatbuffers::String* spriteFrame() const
	{
		return GetPointer<const flatbuffers::String*>(VT_SPRITEFRAME);
	}
	bool spriteFrameFromTP() const
	{
		return GetField<uint8_t>(VT_SPRITEFRAMEFROMTP, 0) != 0;
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyOffset(verifier, VT_SPRITEFRAME) &&
			   verifier.VerifyString(spriteFrame()) &&
			   VerifyField<uint8_t>(verifier, VT_SPRITEFRAMEFROMTP) &&
			   verifier.EndTable();
	}
};

struct PageViewBackgroundBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_spriteFrame(flatbuffers::Offset<flatbuffers::String> spriteFrame)
	{
		fbb_.AddOffset(PageViewBackground::VT_SPRITEFRAME, spriteFrame);
	}
	void add_spriteFrameFromTP(bool spriteFrameFromTP)
	{
		fbb_.AddElement<uint8_t>(PageViewBackground::VT_SPRITEFRAMEFROMTP, static_cast<uint8_t>(spriteFrameFromTP), 0);
	}
	explicit PageViewBackgroundBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	PageViewBackgroundBuilder& operator=(const PageViewBackgroundBuilder&);
	flatbuffers::Offset<PageViewBackground> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<PageViewBackground>(end);
		return o;
	}
};

inline flatbuffers::Offset<PageViewBackground> CreatePageViewBackground(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<flatbuffers::String> spriteFrame = 0,
	bool spriteFrameFromTP = false)
{
	PageViewBackgroundBuilder builder_(_fbb);
	builder_.add_spriteFrame(spriteFrame);
	builder_.add_spriteFrameFromTP(spriteFrameFromTP);
	return builder_.Finish();
}

inline flatbuffers::Offset<PageViewBackground> CreatePageViewBackgroundDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	const char* spriteFrame = nullptr,
	bool spriteFrameFromTP = false)
{
	return creator::buffers::CreatePageViewBackground(
		_fbb,
		spriteFrame ? _fbb.CreateString(spriteFrame) : 0,
		spriteFrameFromTP);
}

struct PageView FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_NODE = 4,
		VT_INERTIA = 6,
		VT_BOUNCEENABLED = 8,
		VT_DIRECTION = 10,
		VT_INDICATOR = 12,
		VT_PAGES = 14,
		VT_BACKGROUND = 16
	};
	const Node* node() const
	{
		return GetPointer<const Node*>(VT_NODE);
	}
	bool inertia() const
	{
		return GetField<uint8_t>(VT_INERTIA, 0) != 0;
	}
	bool bounceEnabled() const
	{
		return GetField<uint8_t>(VT_BOUNCEENABLED, 0) != 0;
	}
	ScrollViewDirection direction() const
	{
		return static_cast<ScrollViewDirection>(GetField<int8_t>(VT_DIRECTION, 0));
	}
	const PageViewIndicator* indicator() const
	{
		return GetPointer<const PageViewIndicator*>(VT_INDICATOR);
	}
	const flatbuffers::Vector<flatbuffers::Offset<PageViewPage>>* pages() const
	{
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PageViewPage>>*>(VT_PAGES);
	}
	const PageViewBackground* background() const
	{
		return GetPointer<const PageViewBackground*>(VT_BACKGROUND);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyOffset(verifier, VT_NODE) &&
			   verifier.VerifyTable(node()) &&
			   VerifyField<uint8_t>(verifier, VT_INERTIA) &&
			   VerifyField<uint8_t>(verifier, VT_BOUNCEENABLED) &&
			   VerifyField<int8_t>(verifier, VT_DIRECTION) &&
			   VerifyOffset(verifier, VT_INDICATOR) &&
			   verifier.VerifyTable(indicator()) &&
			   VerifyOffset(verifier, VT_PAGES) &&
			   verifier.VerifyVector(pages()) &&
			   verifier.VerifyVectorOfTables(pages()) &&
			   VerifyOffset(verifier, VT_BACKGROUND) &&
			   verifier.VerifyTable(background()) &&
			   verifier.EndTable();
	}
};

struct PageViewBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_node(flatbuffers::Offset<Node> node)
	{
		fbb_.AddOffset(PageView::VT_NODE, node);
	}
	void add_inertia(bool inertia)
	{
		fbb_.AddElement<uint8_t>(PageView::VT_INERTIA, static_cast<uint8_t>(inertia), 0);
	}
	void add_bounceEnabled(bool bounceEnabled)
	{
		fbb_.AddElement<uint8_t>(PageView::VT_BOUNCEENABLED, static_cast<uint8_t>(bounceEnabled), 0);
	}
	void add_direction(ScrollViewDirection direction)
	{
		fbb_.AddElement<int8_t>(PageView::VT_DIRECTION, static_cast<int8_t>(direction), 0);
	}
	void add_indicator(flatbuffers::Offset<PageViewIndicator> indicator)
	{
		fbb_.AddOffset(PageView::VT_INDICATOR, indicator);
	}
	void add_pages(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PageViewPage>>> pages)
	{
		fbb_.AddOffset(PageView::VT_PAGES, pages);
	}
	void add_background(flatbuffers::Offset<PageViewBackground> background)
	{
		fbb_.AddOffset(PageView::VT_BACKGROUND, background);
	}
	explicit PageViewBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	PageViewBuilder& operator=(const PageViewBuilder&);
	flatbuffers::Offset<PageView> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<PageView>(end);
		return o;
	}
};

inline flatbuffers::Offset<PageView> CreatePageView(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	bool inertia = false,
	bool bounceEnabled = false,
	ScrollViewDirection direction = ScrollViewDirection_None,
	flatbuffers::Offset<PageViewIndicator> indicator = 0,
	flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PageViewPage>>> pages = 0,
	flatbuffers::Offset<PageViewBackground> background = 0)
{
	PageViewBuilder builder_(_fbb);
	builder_.add_background(background);
	builder_.add_pages(pages);
	builder_.add_indicator(indicator);
	builder_.add_node(node);
	builder_.add_direction(direction);
	builder_.add_bounceEnabled(bounceEnabled);
	builder_.add_inertia(inertia);
	return builder_.Finish();
}

inline flatbuffers::Offset<PageView> CreatePageViewDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	bool inertia = false,
	bool bounceEnabled = false,
	ScrollViewDirection direction = ScrollViewDirection_None,
	flatbuffers::Offset<PageViewIndicator> indicator = 0,
	const std::vector<flatbuffers::Offset<PageViewPage>>* pages = nullptr,
	flatbuffers::Offset<PageViewBackground> background = 0)
{
	return creator::buffers::CreatePageView(
		_fbb,
		node,
		inertia,
		bounceEnabled,
		direction,
		indicator,
		pages ? _fbb.CreateVector<flatbuffers::Offset<PageViewPage>>(*pages) : 0,
		background);
}

struct MotionStreak FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_NODE = 4,
		VT_TIMETOFADE = 6,
		VT_MINSEG = 8,
		VT_STROKEWIDTH = 10,
		VT_STROKECOLOR = 12,
		VT_TEXTUREPATH = 14,
		VT_FASTMODE = 16
	};
	const Node* node() const
	{
		return GetPointer<const Node*>(VT_NODE);
	}
	float timeToFade() const
	{
		return GetField<float>(VT_TIMETOFADE, 0.0f);
	}
	float minSeg() const
	{
		return GetField<float>(VT_MINSEG, 0.0f);
	}
	float strokeWidth() const
	{
		return GetField<float>(VT_STROKEWIDTH, 0.0f);
	}
	const ColorRGB* strokeColor() const
	{
		return GetStruct<const ColorRGB*>(VT_STROKECOLOR);
	}
	const flatbuffers::String* texturePath() const
	{
		return GetPointer<const flatbuffers::String*>(VT_TEXTUREPATH);
	}
	bool fastMode() const
	{
		return GetField<uint8_t>(VT_FASTMODE, 0) != 0;
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyOffset(verifier, VT_NODE) &&
			   verifier.VerifyTable(node()) &&
			   VerifyField<float>(verifier, VT_TIMETOFADE) &&
			   VerifyField<float>(verifier, VT_MINSEG) &&
			   VerifyField<float>(verifier, VT_STROKEWIDTH) &&
			   VerifyField<ColorRGB>(verifier, VT_STROKECOLOR) &&
			   VerifyOffset(verifier, VT_TEXTUREPATH) &&
			   verifier.VerifyString(texturePath()) &&
			   VerifyField<uint8_t>(verifier, VT_FASTMODE) &&
			   verifier.EndTable();
	}
};

struct MotionStreakBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_node(flatbuffers::Offset<Node> node)
	{
		fbb_.AddOffset(MotionStreak::VT_NODE, node);
	}
	void add_timeToFade(float timeToFade)
	{
		fbb_.AddElement<float>(MotionStreak::VT_TIMETOFADE, timeToFade, 0.0f);
	}
	void add_minSeg(float minSeg)
	{
		fbb_.AddElement<float>(MotionStreak::VT_MINSEG, minSeg, 0.0f);
	}
	void add_strokeWidth(float strokeWidth)
	{
		fbb_.AddElement<float>(MotionStreak::VT_STROKEWIDTH, strokeWidth, 0.0f);
	}
	void add_strokeColor(const ColorRGB* strokeColor)
	{
		fbb_.AddStruct(MotionStreak::VT_STROKECOLOR, strokeColor);
	}
	void add_texturePath(flatbuffers::Offset<flatbuffers::String> texturePath)
	{
		fbb_.AddOffset(MotionStreak::VT_TEXTUREPATH, texturePath);
	}
	void add_fastMode(bool fastMode)
	{
		fbb_.AddElement<uint8_t>(MotionStreak::VT_FASTMODE, static_cast<uint8_t>(fastMode), 0);
	}
	explicit MotionStreakBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	MotionStreakBuilder& operator=(const MotionStreakBuilder&);
	flatbuffers::Offset<MotionStreak> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<MotionStreak>(end);
		return o;
	}
};

inline flatbuffers::Offset<MotionStreak> CreateMotionStreak(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	float timeToFade = 0.0f,
	float minSeg = 0.0f,
	float strokeWidth = 0.0f,
	const ColorRGB* strokeColor = 0,
	flatbuffers::Offset<flatbuffers::String> texturePath = 0,
	bool fastMode = false)
{
	MotionStreakBuilder builder_(_fbb);
	builder_.add_texturePath(texturePath);
	builder_.add_strokeColor(strokeColor);
	builder_.add_strokeWidth(strokeWidth);
	builder_.add_minSeg(minSeg);
	builder_.add_timeToFade(timeToFade);
	builder_.add_node(node);
	builder_.add_fastMode(fastMode);
	return builder_.Finish();
}

inline flatbuffers::Offset<MotionStreak> CreateMotionStreakDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	float timeToFade = 0.0f,
	float minSeg = 0.0f,
	float strokeWidth = 0.0f,
	const ColorRGB* strokeColor = 0,
	const char* texturePath = nullptr,
	bool fastMode = false)
{
	return creator::buffers::CreateMotionStreak(
		_fbb,
		node,
		timeToFade,
		minSeg,
		strokeWidth,
		strokeColor,
		texturePath ? _fbb.CreateString(texturePath) : 0,
		fastMode);
}

struct SpineSkeleton FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_NODE = 4,
		VT_JSONFILE = 6,
		VT_ATLASFILE = 8,
		VT_DEFAULTSKIN = 10,
		VT_DEFAULTANIMATION = 12,
		VT_LOOP = 14,
		VT_PREMULTIPLIEDALPHA = 16,
		VT_TIMESCALE = 18,
		VT_DEBUGSLOTS = 20,
		VT_DEBUGBONES = 22
	};
	const Node* node() const
	{
		return GetPointer<const Node*>(VT_NODE);
	}
	const flatbuffers::String* jsonFile() const
	{
		return GetPointer<const flatbuffers::String*>(VT_JSONFILE);
	}
	const flatbuffers::String* atlasFile() const
	{
		return GetPointer<const flatbuffers::String*>(VT_ATLASFILE);
	}
	const flatbuffers::String* defaultSkin() const
	{
		return GetPointer<const flatbuffers::String*>(VT_DEFAULTSKIN);
	}
	const flatbuffers::String* defaultAnimation() const
	{
		return GetPointer<const flatbuffers::String*>(VT_DEFAULTANIMATION);
	}
	bool loop() const
	{
		return GetField<uint8_t>(VT_LOOP, 0) != 0;
	}
	bool premultipliedAlpha() const
	{
		return GetField<uint8_t>(VT_PREMULTIPLIEDALPHA, 0) != 0;
	}
	float timeScale() const
	{
		return GetField<float>(VT_TIMESCALE, 1.0f);
	}
	bool debugSlots() const
	{
		return GetField<uint8_t>(VT_DEBUGSLOTS, 0) != 0;
	}
	bool debugBones() const
	{
		return GetField<uint8_t>(VT_DEBUGBONES, 0) != 0;
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyOffset(verifier, VT_NODE) &&
			   verifier.VerifyTable(node()) &&
			   VerifyOffset(verifier, VT_JSONFILE) &&
			   verifier.VerifyString(jsonFile()) &&
			   VerifyOffset(verifier, VT_ATLASFILE) &&
			   verifier.VerifyString(atlasFile()) &&
			   VerifyOffset(verifier, VT_DEFAULTSKIN) &&
			   verifier.VerifyString(defaultSkin()) &&
			   VerifyOffset(verifier, VT_DEFAULTANIMATION) &&
			   verifier.VerifyString(defaultAnimation()) &&
			   VerifyField<uint8_t>(verifier, VT_LOOP) &&
			   VerifyField<uint8_t>(verifier, VT_PREMULTIPLIEDALPHA) &&
			   VerifyField<float>(verifier, VT_TIMESCALE) &&
			   VerifyField<uint8_t>(verifier, VT_DEBUGSLOTS) &&
			   VerifyField<uint8_t>(verifier, VT_DEBUGBONES) &&
			   verifier.EndTable();
	}
};

struct SpineSkeletonBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_node(flatbuffers::Offset<Node> node)
	{
		fbb_.AddOffset(SpineSkeleton::VT_NODE, node);
	}
	void add_jsonFile(flatbuffers::Offset<flatbuffers::String> jsonFile)
	{
		fbb_.AddOffset(SpineSkeleton::VT_JSONFILE, jsonFile);
	}
	void add_atlasFile(flatbuffers::Offset<flatbuffers::String> atlasFile)
	{
		fbb_.AddOffset(SpineSkeleton::VT_ATLASFILE, atlasFile);
	}
	void add_defaultSkin(flatbuffers::Offset<flatbuffers::String> defaultSkin)
	{
		fbb_.AddOffset(SpineSkeleton::VT_DEFAULTSKIN, defaultSkin);
	}
	void add_defaultAnimation(flatbuffers::Offset<flatbuffers::String> defaultAnimation)
	{
		fbb_.AddOffset(SpineSkeleton::VT_DEFAULTANIMATION, defaultAnimation);
	}
	void add_loop(bool loop)
	{
		fbb_.AddElement<uint8_t>(SpineSkeleton::VT_LOOP, static_cast<uint8_t>(loop), 0);
	}
	void add_premultipliedAlpha(bool premultipliedAlpha)
	{
		fbb_.AddElement<uint8_t>(SpineSkeleton::VT_PREMULTIPLIEDALPHA, static_cast<uint8_t>(premultipliedAlpha), 0);
	}
	void add_timeScale(float timeScale)
	{
		fbb_.AddElement<float>(SpineSkeleton::VT_TIMESCALE, timeScale, 1.0f);
	}
	void add_debugSlots(bool debugSlots)
	{
		fbb_.AddElement<uint8_t>(SpineSkeleton::VT_DEBUGSLOTS, static_cast<uint8_t>(debugSlots), 0);
	}
	void add_debugBones(bool debugBones)
	{
		fbb_.AddElement<uint8_t>(SpineSkeleton::VT_DEBUGBONES, static_cast<uint8_t>(debugBones), 0);
	}
	explicit SpineSkeletonBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	SpineSkeletonBuilder& operator=(const SpineSkeletonBuilder&);
	flatbuffers::Offset<SpineSkeleton> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<SpineSkeleton>(end);
		return o;
	}
};

inline flatbuffers::Offset<SpineSkeleton> CreateSpineSkeleton(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	flatbuffers::Offset<flatbuffers::String> jsonFile = 0,
	flatbuffers::Offset<flatbuffers::String> atlasFile = 0,
	flatbuffers::Offset<flatbuffers::String> defaultSkin = 0,
	flatbuffers::Offset<flatbuffers::String> defaultAnimation = 0,
	bool loop = false,
	bool premultipliedAlpha = false,
	float timeScale = 1.0f,
	bool debugSlots = false,
	bool debugBones = false)
{
	SpineSkeletonBuilder builder_(_fbb);
	builder_.add_timeScale(timeScale);
	builder_.add_defaultAnimation(defaultAnimation);
	builder_.add_defaultSkin(defaultSkin);
	builder_.add_atlasFile(atlasFile);
	builder_.add_jsonFile(jsonFile);
	builder_.add_node(node);
	builder_.add_debugBones(debugBones);
	builder_.add_debugSlots(debugSlots);
	builder_.add_premultipliedAlpha(premultipliedAlpha);
	builder_.add_loop(loop);
	return builder_.Finish();
}

inline flatbuffers::Offset<SpineSkeleton> CreateSpineSkeletonDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	const char* jsonFile = nullptr,
	const char* atlasFile = nullptr,
	const char* defaultSkin = nullptr,
	const char* defaultAnimation = nullptr,
	bool loop = false,
	bool premultipliedAlpha = false,
	float timeScale = 1.0f,
	bool debugSlots = false,
	bool debugBones = false)
{
	return creator::buffers::CreateSpineSkeleton(
		_fbb,
		node,
		jsonFile ? _fbb.CreateString(jsonFile) : 0,
		atlasFile ? _fbb.CreateString(atlasFile) : 0,
		defaultSkin ? _fbb.CreateString(defaultSkin) : 0,
		defaultAnimation ? _fbb.CreateString(defaultAnimation) : 0,
		loop,
		premultipliedAlpha,
		timeScale,
		debugSlots,
		debugBones);
}

struct AnimationRef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_CLIPS = 4,
		VT_PLAYONLOAD = 6,
		VT_DEFAULTCLIP = 8
	};
	const flatbuffers::Vector<flatbuffers::Offset<AnimationClip>>* clips() const
	{
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimationClip>>*>(VT_CLIPS);
	}
	bool playOnLoad() const
	{
		return GetField<uint8_t>(VT_PLAYONLOAD, 0) != 0;
	}
	const flatbuffers::String* defaultClip() const
	{
		return GetPointer<const flatbuffers::String*>(VT_DEFAULTCLIP);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyOffset(verifier, VT_CLIPS) &&
			   verifier.VerifyVector(clips()) &&
			   verifier.VerifyVectorOfTables(clips()) &&
			   VerifyField<uint8_t>(verifier, VT_PLAYONLOAD) &&
			   VerifyOffset(verifier, VT_DEFAULTCLIP) &&
			   verifier.VerifyString(defaultClip()) &&
			   verifier.EndTable();
	}
};

struct AnimationRefBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_clips(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationClip>>> clips)
	{
		fbb_.AddOffset(AnimationRef::VT_CLIPS, clips);
	}
	void add_playOnLoad(bool playOnLoad)
	{
		fbb_.AddElement<uint8_t>(AnimationRef::VT_PLAYONLOAD, static_cast<uint8_t>(playOnLoad), 0);
	}
	void add_defaultClip(flatbuffers::Offset<flatbuffers::String> defaultClip)
	{
		fbb_.AddOffset(AnimationRef::VT_DEFAULTCLIP, defaultClip);
	}
	explicit AnimationRefBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	AnimationRefBuilder& operator=(const AnimationRefBuilder&);
	flatbuffers::Offset<AnimationRef> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<AnimationRef>(end);
		return o;
	}
};

inline flatbuffers::Offset<AnimationRef> CreateAnimationRef(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationClip>>> clips = 0,
	bool playOnLoad = false,
	flatbuffers::Offset<flatbuffers::String> defaultClip = 0)
{
	AnimationRefBuilder builder_(_fbb);
	builder_.add_defaultClip(defaultClip);
	builder_.add_clips(clips);
	builder_.add_playOnLoad(playOnLoad);
	return builder_.Finish();
}

inline flatbuffers::Offset<AnimationRef> CreateAnimationRefDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	const std::vector<flatbuffers::Offset<AnimationClip>>* clips = nullptr,
	bool playOnLoad = false,
	const char* defaultClip = nullptr)
{
	return creator::buffers::CreateAnimationRef(
		_fbb,
		clips ? _fbb.CreateVector<flatbuffers::Offset<AnimationClip>>(*clips) : 0,
		playOnLoad,
		defaultClip ? _fbb.CreateString(defaultClip) : 0);
}

struct Collider FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_TYPE = 4,
		VT_OFFSET = 6,
		VT_SIZE = 8,
		VT_POINTS = 10,
		VT_RADIUS = 12
	};
	ColliderType type() const
	{
		return static_cast<ColliderType>(GetField<int8_t>(VT_TYPE, 0));
	}
	const Vec2* offset() const
	{
		return GetStruct<const Vec2*>(VT_OFFSET);
	}
	const Size* size() const
	{
		return GetStruct<const Size*>(VT_SIZE);
	}
	const flatbuffers::Vector<const Vec2*>* points() const
	{
		return GetPointer<const flatbuffers::Vector<const Vec2*>*>(VT_POINTS);
	}
	float radius() const
	{
		return GetField<float>(VT_RADIUS, 0.0f);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyField<int8_t>(verifier, VT_TYPE) &&
			   VerifyField<Vec2>(verifier, VT_OFFSET) &&
			   VerifyField<Size>(verifier, VT_SIZE) &&
			   VerifyOffset(verifier, VT_POINTS) &&
			   verifier.VerifyVector(points()) &&
			   VerifyField<float>(verifier, VT_RADIUS) &&
			   verifier.EndTable();
	}
};

struct ColliderBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_type(ColliderType type)
	{
		fbb_.AddElement<int8_t>(Collider::VT_TYPE, static_cast<int8_t>(type), 0);
	}
	void add_offset(const Vec2* offset)
	{
		fbb_.AddStruct(Collider::VT_OFFSET, offset);
	}
	void add_size(const Size* size)
	{
		fbb_.AddStruct(Collider::VT_SIZE, size);
	}
	void add_points(flatbuffers::Offset<flatbuffers::Vector<const Vec2*>> points)
	{
		fbb_.AddOffset(Collider::VT_POINTS, points);
	}
	void add_radius(float radius)
	{
		fbb_.AddElement<float>(Collider::VT_RADIUS, radius, 0.0f);
	}
	explicit ColliderBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	ColliderBuilder& operator=(const ColliderBuilder&);
	flatbuffers::Offset<Collider> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<Collider>(end);
		return o;
	}
};

inline flatbuffers::Offset<Collider> CreateCollider(
	flatbuffers::FlatBufferBuilder& _fbb,
	ColliderType type = ColliderType_BoxCollider,
	const Vec2* offset = 0,
	const Size* size = 0,
	flatbuffers::Offset<flatbuffers::Vector<const Vec2*>> points = 0,
	float radius = 0.0f)
{
	ColliderBuilder builder_(_fbb);
	builder_.add_radius(radius);
	builder_.add_points(points);
	builder_.add_size(size);
	builder_.add_offset(offset);
	builder_.add_type(type);
	return builder_.Finish();
}

inline flatbuffers::Offset<Collider> CreateColliderDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	ColliderType type = ColliderType_BoxCollider,
	const Vec2* offset = 0,
	const Size* size = 0,
	const std::vector<Vec2>* points = nullptr,
	float radius = 0.0f)
{
	return creator::buffers::CreateCollider(
		_fbb,
		type,
		offset,
		size,
		points ? _fbb.CreateVectorOfStructs<Vec2>(*points) : 0,
		radius);
}

struct DragonBones FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_NODE = 4,
		VT_BONEDATAPATH = 6,
		VT_BONEDATANAME = 8,
		VT_TEXTUREDATAPATH = 10,
		VT_ARMATURE = 12,
		VT_ANIMATION = 14,
		VT_TIMESCALE = 16,
		VT_PLAYTIMES = 18
	};
	const Node* node() const
	{
		return GetPointer<const Node*>(VT_NODE);
	}
	const flatbuffers::String* boneDataPath() const
	{
		return GetPointer<const flatbuffers::String*>(VT_BONEDATAPATH);
	}
	const flatbuffers::String* boneDataName() const
	{
		return GetPointer<const flatbuffers::String*>(VT_BONEDATANAME);
	}
	const flatbuffers::String* textureDataPath() const
	{
		return GetPointer<const flatbuffers::String*>(VT_TEXTUREDATAPATH);
	}
	const flatbuffers::String* armature() const
	{
		return GetPointer<const flatbuffers::String*>(VT_ARMATURE);
	}
	const flatbuffers::String* animation() const
	{
		return GetPointer<const flatbuffers::String*>(VT_ANIMATION);
	}
	float timeScale() const
	{
		return GetField<float>(VT_TIMESCALE, 0.0f);
	}
	int32_t playTimes() const
	{
		return GetField<int32_t>(VT_PLAYTIMES, 0);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyOffset(verifier, VT_NODE) &&
			   verifier.VerifyTable(node()) &&
			   VerifyOffset(verifier, VT_BONEDATAPATH) &&
			   verifier.VerifyString(boneDataPath()) &&
			   VerifyOffset(verifier, VT_BONEDATANAME) &&
			   verifier.VerifyString(boneDataName()) &&
			   VerifyOffset(verifier, VT_TEXTUREDATAPATH) &&
			   verifier.VerifyString(textureDataPath()) &&
			   VerifyOffset(verifier, VT_ARMATURE) &&
			   verifier.VerifyString(armature()) &&
			   VerifyOffset(verifier, VT_ANIMATION) &&
			   verifier.VerifyString(animation()) &&
			   VerifyField<float>(verifier, VT_TIMESCALE) &&
			   VerifyField<int32_t>(verifier, VT_PLAYTIMES) &&
			   verifier.EndTable();
	}
};

struct DragonBonesBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_node(flatbuffers::Offset<Node> node)
	{
		fbb_.AddOffset(DragonBones::VT_NODE, node);
	}
	void add_boneDataPath(flatbuffers::Offset<flatbuffers::String> boneDataPath)
	{
		fbb_.AddOffset(DragonBones::VT_BONEDATAPATH, boneDataPath);
	}
	void add_boneDataName(flatbuffers::Offset<flatbuffers::String> boneDataName)
	{
		fbb_.AddOffset(DragonBones::VT_BONEDATANAME, boneDataName);
	}
	void add_textureDataPath(flatbuffers::Offset<flatbuffers::String> textureDataPath)
	{
		fbb_.AddOffset(DragonBones::VT_TEXTUREDATAPATH, textureDataPath);
	}
	void add_armature(flatbuffers::Offset<flatbuffers::String> armature)
	{
		fbb_.AddOffset(DragonBones::VT_ARMATURE, armature);
	}
	void add_animation(flatbuffers::Offset<flatbuffers::String> animation)
	{
		fbb_.AddOffset(DragonBones::VT_ANIMATION, animation);
	}
	void add_timeScale(float timeScale)
	{
		fbb_.AddElement<float>(DragonBones::VT_TIMESCALE, timeScale, 0.0f);
	}
	void add_playTimes(int32_t playTimes)
	{
		fbb_.AddElement<int32_t>(DragonBones::VT_PLAYTIMES, playTimes, 0);
	}
	explicit DragonBonesBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	DragonBonesBuilder& operator=(const DragonBonesBuilder&);
	flatbuffers::Offset<DragonBones> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<DragonBones>(end);
		return o;
	}
};

inline flatbuffers::Offset<DragonBones> CreateDragonBones(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	flatbuffers::Offset<flatbuffers::String> boneDataPath = 0,
	flatbuffers::Offset<flatbuffers::String> boneDataName = 0,
	flatbuffers::Offset<flatbuffers::String> textureDataPath = 0,
	flatbuffers::Offset<flatbuffers::String> armature = 0,
	flatbuffers::Offset<flatbuffers::String> animation = 0,
	float timeScale = 0.0f,
	int32_t playTimes = 0)
{
	DragonBonesBuilder builder_(_fbb);
	builder_.add_playTimes(playTimes);
	builder_.add_timeScale(timeScale);
	builder_.add_animation(animation);
	builder_.add_armature(armature);
	builder_.add_textureDataPath(textureDataPath);
	builder_.add_boneDataName(boneDataName);
	builder_.add_boneDataPath(boneDataPath);
	builder_.add_node(node);
	return builder_.Finish();
}

inline flatbuffers::Offset<DragonBones> CreateDragonBonesDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<Node> node = 0,
	const char* boneDataPath = nullptr,
	const char* boneDataName = nullptr,
	const char* textureDataPath = nullptr,
	const char* armature = nullptr,
	const char* animation = nullptr,
	float timeScale = 0.0f,
	int32_t playTimes = 0)
{
	return creator::buffers::CreateDragonBones(
		_fbb,
		node,
		boneDataPath ? _fbb.CreateString(boneDataPath) : 0,
		boneDataName ? _fbb.CreateString(boneDataName) : 0,
		textureDataPath ? _fbb.CreateString(textureDataPath) : 0,
		armature ? _fbb.CreateString(armature) : 0,
		animation ? _fbb.CreateString(animation) : 0,
		timeScale,
		playTimes);
}

struct AnimationClip FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_NAME = 4,
		VT_DURATION = 6,
		VT_SAMPLE = 8,
		VT_SPEED = 10,
		VT_WRAPMODE = 12,
		VT_CURVEDATA = 14
	};
	const flatbuffers::String* name() const
	{
		return GetPointer<const flatbuffers::String*>(VT_NAME);
	}
	float duration() const
	{
		return GetField<float>(VT_DURATION, 0.0f);
	}
	float sample() const
	{
		return GetField<float>(VT_SAMPLE, 0.0f);
	}
	float speed() const
	{
		return GetField<float>(VT_SPEED, 0.0f);
	}
	AnimWrapMode wrapMode() const
	{
		return static_cast<AnimWrapMode>(GetField<int8_t>(VT_WRAPMODE, 0));
	}
	const flatbuffers::Vector<flatbuffers::Offset<AnimCurveData>>* curveData() const
	{
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimCurveData>>*>(VT_CURVEDATA);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyOffset(verifier, VT_NAME) &&
			   verifier.VerifyString(name()) &&
			   VerifyField<float>(verifier, VT_DURATION) &&
			   VerifyField<float>(verifier, VT_SAMPLE) &&
			   VerifyField<float>(verifier, VT_SPEED) &&
			   VerifyField<int8_t>(verifier, VT_WRAPMODE) &&
			   VerifyOffset(verifier, VT_CURVEDATA) &&
			   verifier.VerifyVector(curveData()) &&
			   verifier.VerifyVectorOfTables(curveData()) &&
			   verifier.EndTable();
	}
};

struct AnimationClipBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_name(flatbuffers::Offset<flatbuffers::String> name)
	{
		fbb_.AddOffset(AnimationClip::VT_NAME, name);
	}
	void add_duration(float duration)
	{
		fbb_.AddElement<float>(AnimationClip::VT_DURATION, duration, 0.0f);
	}
	void add_sample(float sample)
	{
		fbb_.AddElement<float>(AnimationClip::VT_SAMPLE, sample, 0.0f);
	}
	void add_speed(float speed)
	{
		fbb_.AddElement<float>(AnimationClip::VT_SPEED, speed, 0.0f);
	}
	void add_wrapMode(AnimWrapMode wrapMode)
	{
		fbb_.AddElement<int8_t>(AnimationClip::VT_WRAPMODE, static_cast<int8_t>(wrapMode), 0);
	}
	void add_curveData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimCurveData>>> curveData)
	{
		fbb_.AddOffset(AnimationClip::VT_CURVEDATA, curveData);
	}
	explicit AnimationClipBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	AnimationClipBuilder& operator=(const AnimationClipBuilder&);
	flatbuffers::Offset<AnimationClip> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<AnimationClip>(end);
		return o;
	}
};

inline flatbuffers::Offset<AnimationClip> CreateAnimationClip(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<flatbuffers::String> name = 0,
	float duration = 0.0f,
	float sample = 0.0f,
	float speed = 0.0f,
	AnimWrapMode wrapMode = AnimWrapMode_Default,
	flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimCurveData>>> curveData = 0)
{
	AnimationClipBuilder builder_(_fbb);
	builder_.add_curveData(curveData);
	builder_.add_speed(speed);
	builder_.add_sample(sample);
	builder_.add_duration(duration);
	builder_.add_name(name);
	builder_.add_wrapMode(wrapMode);
	return builder_.Finish();
}

inline flatbuffers::Offset<AnimationClip> CreateAnimationClipDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	const char* name = nullptr,
	float duration = 0.0f,
	float sample = 0.0f,
	float speed = 0.0f,
	AnimWrapMode wrapMode = AnimWrapMode_Default,
	const std::vector<flatbuffers::Offset<AnimCurveData>>* curveData = nullptr)
{
	return creator::buffers::CreateAnimationClip(
		_fbb,
		name ? _fbb.CreateString(name) : 0,
		duration,
		sample,
		speed,
		wrapMode,
		curveData ? _fbb.CreateVector<flatbuffers::Offset<AnimCurveData>>(*curveData) : 0);
}

struct AnimCurveData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_PATH = 4,
		VT_PROPS = 6
	};
	const flatbuffers::String* path() const
	{
		return GetPointer<const flatbuffers::String*>(VT_PATH);
	}
	const AnimProps* props() const
	{
		return GetPointer<const AnimProps*>(VT_PROPS);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyOffset(verifier, VT_PATH) &&
			   verifier.VerifyString(path()) &&
			   VerifyOffset(verifier, VT_PROPS) &&
			   verifier.VerifyTable(props()) &&
			   verifier.EndTable();
	}
};

struct AnimCurveDataBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_path(flatbuffers::Offset<flatbuffers::String> path)
	{
		fbb_.AddOffset(AnimCurveData::VT_PATH, path);
	}
	void add_props(flatbuffers::Offset<AnimProps> props)
	{
		fbb_.AddOffset(AnimCurveData::VT_PROPS, props);
	}
	explicit AnimCurveDataBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	AnimCurveDataBuilder& operator=(const AnimCurveDataBuilder&);
	flatbuffers::Offset<AnimCurveData> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<AnimCurveData>(end);
		return o;
	}
};

inline flatbuffers::Offset<AnimCurveData> CreateAnimCurveData(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<flatbuffers::String> path = 0,
	flatbuffers::Offset<AnimProps> props = 0)
{
	AnimCurveDataBuilder builder_(_fbb);
	builder_.add_props(props);
	builder_.add_path(path);
	return builder_.Finish();
}

inline flatbuffers::Offset<AnimCurveData> CreateAnimCurveDataDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	const char* path = nullptr,
	flatbuffers::Offset<AnimProps> props = 0)
{
	return creator::buffers::CreateAnimCurveData(
		_fbb,
		path ? _fbb.CreateString(path) : 0,
		props);
}

struct AnimProps FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_ROTATION = 4,
		VT_POSITION = 6,
		VT_POSITIONX = 8,
		VT_POSITIONY = 10,
		VT_ANCHORX = 12,
		VT_ANCHORY = 14,
		VT_COLOR = 16,
		VT_OPACITY = 18,
		VT_WIDTH = 20,
		VT_HEIGHT = 22,
		VT_SCALEX = 24,
		VT_SCALEY = 26,
		VT_SKEWX = 28,
		VT_SKEWY = 30,
		VT_ACTIVE = 32,
		VT_SPRITEFRAME = 34
	};
	const flatbuffers::Vector<flatbuffers::Offset<AnimPropRotation>>* rotation() const
	{
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropRotation>>*>(VT_ROTATION);
	}
	const flatbuffers::Vector<flatbuffers::Offset<AnimPropPosition>>* position() const
	{
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropPosition>>*>(VT_POSITION);
	}
	const flatbuffers::Vector<flatbuffers::Offset<AnimPropPositionX>>* positionX() const
	{
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropPositionX>>*>(VT_POSITIONX);
	}
	const flatbuffers::Vector<flatbuffers::Offset<AnimPropPositionY>>* positionY() const
	{
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropPositionY>>*>(VT_POSITIONY);
	}
	const flatbuffers::Vector<flatbuffers::Offset<AnimPropAnchorX>>* anchorX() const
	{
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropAnchorX>>*>(VT_ANCHORX);
	}
	const flatbuffers::Vector<flatbuffers::Offset<AnimPropAnchorY>>* anchorY() const
	{
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropAnchorY>>*>(VT_ANCHORY);
	}
	const flatbuffers::Vector<flatbuffers::Offset<AnimPropColor>>* color() const
	{
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropColor>>*>(VT_COLOR);
	}
	const flatbuffers::Vector<flatbuffers::Offset<AnimPropOpacity>>* opacity() const
	{
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropOpacity>>*>(VT_OPACITY);
	}
	const flatbuffers::Vector<flatbuffers::Offset<AnimPropWidth>>* width() const
	{
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropWidth>>*>(VT_WIDTH);
	}
	const flatbuffers::Vector<flatbuffers::Offset<AnimPropHeight>>* height() const
	{
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropHeight>>*>(VT_HEIGHT);
	}
	const flatbuffers::Vector<flatbuffers::Offset<AnimPropScaleX>>* scaleX() const
	{
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropScaleX>>*>(VT_SCALEX);
	}
	const flatbuffers::Vector<flatbuffers::Offset<AnimPropScaleY>>* scaleY() const
	{
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropScaleY>>*>(VT_SCALEY);
	}
	const flatbuffers::Vector<flatbuffers::Offset<AnimPropSkewX>>* skewX() const
	{
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropSkewX>>*>(VT_SKEWX);
	}
	const flatbuffers::Vector<flatbuffers::Offset<AnimPropSkewY>>* skewY() const
	{
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropSkewY>>*>(VT_SKEWY);
	}
	const flatbuffers::Vector<flatbuffers::Offset<AnimPropActive>>* active() const
	{
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropActive>>*>(VT_ACTIVE);
	}
	const flatbuffers::Vector<flatbuffers::Offset<AnimPropSpriteFrame>>* spriteFrame() const
	{
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropSpriteFrame>>*>(VT_SPRITEFRAME);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyOffset(verifier, VT_ROTATION) &&
			   verifier.VerifyVector(rotation()) &&
			   verifier.VerifyVectorOfTables(rotation()) &&
			   VerifyOffset(verifier, VT_POSITION) &&
			   verifier.VerifyVector(position()) &&
			   verifier.VerifyVectorOfTables(position()) &&
			   VerifyOffset(verifier, VT_POSITIONX) &&
			   verifier.VerifyVector(positionX()) &&
			   verifier.VerifyVectorOfTables(positionX()) &&
			   VerifyOffset(verifier, VT_POSITIONY) &&
			   verifier.VerifyVector(positionY()) &&
			   verifier.VerifyVectorOfTables(positionY()) &&
			   VerifyOffset(verifier, VT_ANCHORX) &&
			   verifier.VerifyVector(anchorX()) &&
			   verifier.VerifyVectorOfTables(anchorX()) &&
			   VerifyOffset(verifier, VT_ANCHORY) &&
			   verifier.VerifyVector(anchorY()) &&
			   verifier.VerifyVectorOfTables(anchorY()) &&
			   VerifyOffset(verifier, VT_COLOR) &&
			   verifier.VerifyVector(color()) &&
			   verifier.VerifyVectorOfTables(color()) &&
			   VerifyOffset(verifier, VT_OPACITY) &&
			   verifier.VerifyVector(opacity()) &&
			   verifier.VerifyVectorOfTables(opacity()) &&
			   VerifyOffset(verifier, VT_WIDTH) &&
			   verifier.VerifyVector(width()) &&
			   verifier.VerifyVectorOfTables(width()) &&
			   VerifyOffset(verifier, VT_HEIGHT) &&
			   verifier.VerifyVector(height()) &&
			   verifier.VerifyVectorOfTables(height()) &&
			   VerifyOffset(verifier, VT_SCALEX) &&
			   verifier.VerifyVector(scaleX()) &&
			   verifier.VerifyVectorOfTables(scaleX()) &&
			   VerifyOffset(verifier, VT_SCALEY) &&
			   verifier.VerifyVector(scaleY()) &&
			   verifier.VerifyVectorOfTables(scaleY()) &&
			   VerifyOffset(verifier, VT_SKEWX) &&
			   verifier.VerifyVector(skewX()) &&
			   verifier.VerifyVectorOfTables(skewX()) &&
			   VerifyOffset(verifier, VT_SKEWY) &&
			   verifier.VerifyVector(skewY()) &&
			   verifier.VerifyVectorOfTables(skewY()) &&
			   VerifyOffset(verifier, VT_ACTIVE) &&
			   verifier.VerifyVector(active()) &&
			   verifier.VerifyVectorOfTables(active()) &&
			   VerifyOffset(verifier, VT_SPRITEFRAME) &&
			   verifier.VerifyVector(spriteFrame()) &&
			   verifier.VerifyVectorOfTables(spriteFrame()) &&
			   verifier.EndTable();
	}
};

struct AnimPropsBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_rotation(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropRotation>>> rotation)
	{
		fbb_.AddOffset(AnimProps::VT_ROTATION, rotation);
	}
	void add_position(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropPosition>>> position)
	{
		fbb_.AddOffset(AnimProps::VT_POSITION, position);
	}
	void add_positionX(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropPositionX>>> positionX)
	{
		fbb_.AddOffset(AnimProps::VT_POSITIONX, positionX);
	}
	void add_positionY(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropPositionY>>> positionY)
	{
		fbb_.AddOffset(AnimProps::VT_POSITIONY, positionY);
	}
	void add_anchorX(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropAnchorX>>> anchorX)
	{
		fbb_.AddOffset(AnimProps::VT_ANCHORX, anchorX);
	}
	void add_anchorY(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropAnchorY>>> anchorY)
	{
		fbb_.AddOffset(AnimProps::VT_ANCHORY, anchorY);
	}
	void add_color(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropColor>>> color)
	{
		fbb_.AddOffset(AnimProps::VT_COLOR, color);
	}
	void add_opacity(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropOpacity>>> opacity)
	{
		fbb_.AddOffset(AnimProps::VT_OPACITY, opacity);
	}
	void add_width(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropWidth>>> width)
	{
		fbb_.AddOffset(AnimProps::VT_WIDTH, width);
	}
	void add_height(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropHeight>>> height)
	{
		fbb_.AddOffset(AnimProps::VT_HEIGHT, height);
	}
	void add_scaleX(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropScaleX>>> scaleX)
	{
		fbb_.AddOffset(AnimProps::VT_SCALEX, scaleX);
	}
	void add_scaleY(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropScaleY>>> scaleY)
	{
		fbb_.AddOffset(AnimProps::VT_SCALEY, scaleY);
	}
	void add_skewX(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropSkewX>>> skewX)
	{
		fbb_.AddOffset(AnimProps::VT_SKEWX, skewX);
	}
	void add_skewY(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropSkewY>>> skewY)
	{
		fbb_.AddOffset(AnimProps::VT_SKEWY, skewY);
	}
	void add_active(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropActive>>> active)
	{
		fbb_.AddOffset(AnimProps::VT_ACTIVE, active);
	}
	void add_spriteFrame(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropSpriteFrame>>> spriteFrame)
	{
		fbb_.AddOffset(AnimProps::VT_SPRITEFRAME, spriteFrame);
	}
	explicit AnimPropsBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	AnimPropsBuilder& operator=(const AnimPropsBuilder&);
	flatbuffers::Offset<AnimProps> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<AnimProps>(end);
		return o;
	}
};

inline flatbuffers::Offset<AnimProps> CreateAnimProps(
	flatbuffers::FlatBufferBuilder& _fbb,
	flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropRotation>>> rotation = 0,
	flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropPosition>>> position = 0,
	flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropPositionX>>> positionX = 0,
	flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropPositionY>>> positionY = 0,
	flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropAnchorX>>> anchorX = 0,
	flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropAnchorY>>> anchorY = 0,
	flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropColor>>> color = 0,
	flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropOpacity>>> opacity = 0,
	flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropWidth>>> width = 0,
	flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropHeight>>> height = 0,
	flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropScaleX>>> scaleX = 0,
	flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropScaleY>>> scaleY = 0,
	flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropSkewX>>> skewX = 0,
	flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropSkewY>>> skewY = 0,
	flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropActive>>> active = 0,
	flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropSpriteFrame>>> spriteFrame = 0)
{
	AnimPropsBuilder builder_(_fbb);
	builder_.add_spriteFrame(spriteFrame);
	builder_.add_active(active);
	builder_.add_skewY(skewY);
	builder_.add_skewX(skewX);
	builder_.add_scaleY(scaleY);
	builder_.add_scaleX(scaleX);
	builder_.add_height(height);
	builder_.add_width(width);
	builder_.add_opacity(opacity);
	builder_.add_color(color);
	builder_.add_anchorY(anchorY);
	builder_.add_anchorX(anchorX);
	builder_.add_positionY(positionY);
	builder_.add_positionX(positionX);
	builder_.add_position(position);
	builder_.add_rotation(rotation);
	return builder_.Finish();
}

inline flatbuffers::Offset<AnimProps> CreateAnimPropsDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	const std::vector<flatbuffers::Offset<AnimPropRotation>>* rotation = nullptr,
	const std::vector<flatbuffers::Offset<AnimPropPosition>>* position = nullptr,
	const std::vector<flatbuffers::Offset<AnimPropPositionX>>* positionX = nullptr,
	const std::vector<flatbuffers::Offset<AnimPropPositionY>>* positionY = nullptr,
	const std::vector<flatbuffers::Offset<AnimPropAnchorX>>* anchorX = nullptr,
	const std::vector<flatbuffers::Offset<AnimPropAnchorY>>* anchorY = nullptr,
	const std::vector<flatbuffers::Offset<AnimPropColor>>* color = nullptr,
	const std::vector<flatbuffers::Offset<AnimPropOpacity>>* opacity = nullptr,
	const std::vector<flatbuffers::Offset<AnimPropWidth>>* width = nullptr,
	const std::vector<flatbuffers::Offset<AnimPropHeight>>* height = nullptr,
	const std::vector<flatbuffers::Offset<AnimPropScaleX>>* scaleX = nullptr,
	const std::vector<flatbuffers::Offset<AnimPropScaleY>>* scaleY = nullptr,
	const std::vector<flatbuffers::Offset<AnimPropSkewX>>* skewX = nullptr,
	const std::vector<flatbuffers::Offset<AnimPropSkewY>>* skewY = nullptr,
	const std::vector<flatbuffers::Offset<AnimPropActive>>* active = nullptr,
	const std::vector<flatbuffers::Offset<AnimPropSpriteFrame>>* spriteFrame = nullptr)
{
	return creator::buffers::CreateAnimProps(
		_fbb,
		rotation ? _fbb.CreateVector<flatbuffers::Offset<AnimPropRotation>>(*rotation) : 0,
		position ? _fbb.CreateVector<flatbuffers::Offset<AnimPropPosition>>(*position) : 0,
		positionX ? _fbb.CreateVector<flatbuffers::Offset<AnimPropPositionX>>(*positionX) : 0,
		positionY ? _fbb.CreateVector<flatbuffers::Offset<AnimPropPositionY>>(*positionY) : 0,
		anchorX ? _fbb.CreateVector<flatbuffers::Offset<AnimPropAnchorX>>(*anchorX) : 0,
		anchorY ? _fbb.CreateVector<flatbuffers::Offset<AnimPropAnchorY>>(*anchorY) : 0,
		color ? _fbb.CreateVector<flatbuffers::Offset<AnimPropColor>>(*color) : 0,
		opacity ? _fbb.CreateVector<flatbuffers::Offset<AnimPropOpacity>>(*opacity) : 0,
		width ? _fbb.CreateVector<flatbuffers::Offset<AnimPropWidth>>(*width) : 0,
		height ? _fbb.CreateVector<flatbuffers::Offset<AnimPropHeight>>(*height) : 0,
		scaleX ? _fbb.CreateVector<flatbuffers::Offset<AnimPropScaleX>>(*scaleX) : 0,
		scaleY ? _fbb.CreateVector<flatbuffers::Offset<AnimPropScaleY>>(*scaleY) : 0,
		skewX ? _fbb.CreateVector<flatbuffers::Offset<AnimPropSkewX>>(*skewX) : 0,
		skewY ? _fbb.CreateVector<flatbuffers::Offset<AnimPropSkewY>>(*skewY) : 0,
		active ? _fbb.CreateVector<flatbuffers::Offset<AnimPropActive>>(*active) : 0,
		spriteFrame ? _fbb.CreateVector<flatbuffers::Offset<AnimPropSpriteFrame>>(*spriteFrame) : 0);
}

struct AnimEvents FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   verifier.EndTable();
	}
};

struct AnimEventsBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	explicit AnimEventsBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	AnimEventsBuilder& operator=(const AnimEventsBuilder&);
	flatbuffers::Offset<AnimEvents> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<AnimEvents>(end);
		return o;
	}
};

inline flatbuffers::Offset<AnimEvents> CreateAnimEvents(
	flatbuffers::FlatBufferBuilder& _fbb)
{
	AnimEventsBuilder builder_(_fbb);
	return builder_.Finish();
}

struct AnimPropActive FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_FRAME = 4,
		VT_VALUE = 6,
		VT_CURVETYPE = 8,
		VT_CURVEDATA = 10
	};
	float frame() const
	{
		return GetField<float>(VT_FRAME, 0.0f);
	}
	bool value() const
	{
		return GetField<uint8_t>(VT_VALUE, 0) != 0;
	}
	const flatbuffers::String* curveType() const
	{
		return GetPointer<const flatbuffers::String*>(VT_CURVETYPE);
	}
	const flatbuffers::Vector<float>* curveData() const
	{
		return GetPointer<const flatbuffers::Vector<float>*>(VT_CURVEDATA);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyField<float>(verifier, VT_FRAME) &&
			   VerifyField<uint8_t>(verifier, VT_VALUE) &&
			   VerifyOffset(verifier, VT_CURVETYPE) &&
			   verifier.VerifyString(curveType()) &&
			   VerifyOffset(verifier, VT_CURVEDATA) &&
			   verifier.VerifyVector(curveData()) &&
			   verifier.EndTable();
	}
};

struct AnimPropActiveBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_frame(float frame)
	{
		fbb_.AddElement<float>(AnimPropActive::VT_FRAME, frame, 0.0f);
	}
	void add_value(bool value)
	{
		fbb_.AddElement<uint8_t>(AnimPropActive::VT_VALUE, static_cast<uint8_t>(value), 0);
	}
	void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType)
	{
		fbb_.AddOffset(AnimPropActive::VT_CURVETYPE, curveType);
	}
	void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData)
	{
		fbb_.AddOffset(AnimPropActive::VT_CURVEDATA, curveData);
	}
	explicit AnimPropActiveBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	AnimPropActiveBuilder& operator=(const AnimPropActiveBuilder&);
	flatbuffers::Offset<AnimPropActive> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<AnimPropActive>(end);
		return o;
	}
};

inline flatbuffers::Offset<AnimPropActive> CreateAnimPropActive(
	flatbuffers::FlatBufferBuilder& _fbb,
	float frame = 0.0f,
	bool value = false,
	flatbuffers::Offset<flatbuffers::String> curveType = 0,
	flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0)
{
	AnimPropActiveBuilder builder_(_fbb);
	builder_.add_curveData(curveData);
	builder_.add_curveType(curveType);
	builder_.add_frame(frame);
	builder_.add_value(value);
	return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropActive> CreateAnimPropActiveDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	float frame = 0.0f,
	bool value = false,
	const char* curveType = nullptr,
	const std::vector<float>* curveData = nullptr)
{
	return creator::buffers::CreateAnimPropActive(
		_fbb,
		frame,
		value,
		curveType ? _fbb.CreateString(curveType) : 0,
		curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropRotation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_FRAME = 4,
		VT_VALUE = 6,
		VT_CURVETYPE = 8,
		VT_CURVEDATA = 10
	};
	float frame() const
	{
		return GetField<float>(VT_FRAME, 0.0f);
	}
	float value() const
	{
		return GetField<float>(VT_VALUE, 0.0f);
	}
	const flatbuffers::String* curveType() const
	{
		return GetPointer<const flatbuffers::String*>(VT_CURVETYPE);
	}
	const flatbuffers::Vector<float>* curveData() const
	{
		return GetPointer<const flatbuffers::Vector<float>*>(VT_CURVEDATA);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyField<float>(verifier, VT_FRAME) &&
			   VerifyField<float>(verifier, VT_VALUE) &&
			   VerifyOffset(verifier, VT_CURVETYPE) &&
			   verifier.VerifyString(curveType()) &&
			   VerifyOffset(verifier, VT_CURVEDATA) &&
			   verifier.VerifyVector(curveData()) &&
			   verifier.EndTable();
	}
};

struct AnimPropRotationBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_frame(float frame)
	{
		fbb_.AddElement<float>(AnimPropRotation::VT_FRAME, frame, 0.0f);
	}
	void add_value(float value)
	{
		fbb_.AddElement<float>(AnimPropRotation::VT_VALUE, value, 0.0f);
	}
	void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType)
	{
		fbb_.AddOffset(AnimPropRotation::VT_CURVETYPE, curveType);
	}
	void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData)
	{
		fbb_.AddOffset(AnimPropRotation::VT_CURVEDATA, curveData);
	}
	explicit AnimPropRotationBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	AnimPropRotationBuilder& operator=(const AnimPropRotationBuilder&);
	flatbuffers::Offset<AnimPropRotation> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<AnimPropRotation>(end);
		return o;
	}
};

inline flatbuffers::Offset<AnimPropRotation> CreateAnimPropRotation(
	flatbuffers::FlatBufferBuilder& _fbb,
	float frame = 0.0f,
	float value = 0.0f,
	flatbuffers::Offset<flatbuffers::String> curveType = 0,
	flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0)
{
	AnimPropRotationBuilder builder_(_fbb);
	builder_.add_curveData(curveData);
	builder_.add_curveType(curveType);
	builder_.add_value(value);
	builder_.add_frame(frame);
	return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropRotation> CreateAnimPropRotationDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	float frame = 0.0f,
	float value = 0.0f,
	const char* curveType = nullptr,
	const std::vector<float>* curveData = nullptr)
{
	return creator::buffers::CreateAnimPropRotation(
		_fbb,
		frame,
		value,
		curveType ? _fbb.CreateString(curveType) : 0,
		curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropPosition FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_FRAME = 4,
		VT_VALUE = 6,
		VT_CURVETYPE = 8,
		VT_CURVEDATA = 10
	};
	float frame() const
	{
		return GetField<float>(VT_FRAME, 0.0f);
	}
	const Vec2* value() const
	{
		return GetStruct<const Vec2*>(VT_VALUE);
	}
	const flatbuffers::String* curveType() const
	{
		return GetPointer<const flatbuffers::String*>(VT_CURVETYPE);
	}
	const flatbuffers::Vector<float>* curveData() const
	{
		return GetPointer<const flatbuffers::Vector<float>*>(VT_CURVEDATA);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyField<float>(verifier, VT_FRAME) &&
			   VerifyField<Vec2>(verifier, VT_VALUE) &&
			   VerifyOffset(verifier, VT_CURVETYPE) &&
			   verifier.VerifyString(curveType()) &&
			   VerifyOffset(verifier, VT_CURVEDATA) &&
			   verifier.VerifyVector(curveData()) &&
			   verifier.EndTable();
	}
};

struct AnimPropPositionBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_frame(float frame)
	{
		fbb_.AddElement<float>(AnimPropPosition::VT_FRAME, frame, 0.0f);
	}
	void add_value(const Vec2* value)
	{
		fbb_.AddStruct(AnimPropPosition::VT_VALUE, value);
	}
	void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType)
	{
		fbb_.AddOffset(AnimPropPosition::VT_CURVETYPE, curveType);
	}
	void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData)
	{
		fbb_.AddOffset(AnimPropPosition::VT_CURVEDATA, curveData);
	}
	explicit AnimPropPositionBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	AnimPropPositionBuilder& operator=(const AnimPropPositionBuilder&);
	flatbuffers::Offset<AnimPropPosition> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<AnimPropPosition>(end);
		return o;
	}
};

inline flatbuffers::Offset<AnimPropPosition> CreateAnimPropPosition(
	flatbuffers::FlatBufferBuilder& _fbb,
	float frame = 0.0f,
	const Vec2* value = 0,
	flatbuffers::Offset<flatbuffers::String> curveType = 0,
	flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0)
{
	AnimPropPositionBuilder builder_(_fbb);
	builder_.add_curveData(curveData);
	builder_.add_curveType(curveType);
	builder_.add_value(value);
	builder_.add_frame(frame);
	return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropPosition> CreateAnimPropPositionDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	float frame = 0.0f,
	const Vec2* value = 0,
	const char* curveType = nullptr,
	const std::vector<float>* curveData = nullptr)
{
	return creator::buffers::CreateAnimPropPosition(
		_fbb,
		frame,
		value,
		curveType ? _fbb.CreateString(curveType) : 0,
		curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropPositionX FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_FRAME = 4,
		VT_VALUE = 6,
		VT_CURVETYPE = 8,
		VT_CURVEDATA = 10
	};
	float frame() const
	{
		return GetField<float>(VT_FRAME, 0.0f);
	}
	float value() const
	{
		return GetField<float>(VT_VALUE, 0.0f);
	}
	const flatbuffers::String* curveType() const
	{
		return GetPointer<const flatbuffers::String*>(VT_CURVETYPE);
	}
	const flatbuffers::Vector<float>* curveData() const
	{
		return GetPointer<const flatbuffers::Vector<float>*>(VT_CURVEDATA);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyField<float>(verifier, VT_FRAME) &&
			   VerifyField<float>(verifier, VT_VALUE) &&
			   VerifyOffset(verifier, VT_CURVETYPE) &&
			   verifier.VerifyString(curveType()) &&
			   VerifyOffset(verifier, VT_CURVEDATA) &&
			   verifier.VerifyVector(curveData()) &&
			   verifier.EndTable();
	}
};

struct AnimPropPositionXBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_frame(float frame)
	{
		fbb_.AddElement<float>(AnimPropPositionX::VT_FRAME, frame, 0.0f);
	}
	void add_value(float value)
	{
		fbb_.AddElement<float>(AnimPropPositionX::VT_VALUE, value, 0.0f);
	}
	void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType)
	{
		fbb_.AddOffset(AnimPropPositionX::VT_CURVETYPE, curveType);
	}
	void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData)
	{
		fbb_.AddOffset(AnimPropPositionX::VT_CURVEDATA, curveData);
	}
	explicit AnimPropPositionXBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	AnimPropPositionXBuilder& operator=(const AnimPropPositionXBuilder&);
	flatbuffers::Offset<AnimPropPositionX> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<AnimPropPositionX>(end);
		return o;
	}
};

inline flatbuffers::Offset<AnimPropPositionX> CreateAnimPropPositionX(
	flatbuffers::FlatBufferBuilder& _fbb,
	float frame = 0.0f,
	float value = 0.0f,
	flatbuffers::Offset<flatbuffers::String> curveType = 0,
	flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0)
{
	AnimPropPositionXBuilder builder_(_fbb);
	builder_.add_curveData(curveData);
	builder_.add_curveType(curveType);
	builder_.add_value(value);
	builder_.add_frame(frame);
	return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropPositionX> CreateAnimPropPositionXDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	float frame = 0.0f,
	float value = 0.0f,
	const char* curveType = nullptr,
	const std::vector<float>* curveData = nullptr)
{
	return creator::buffers::CreateAnimPropPositionX(
		_fbb,
		frame,
		value,
		curveType ? _fbb.CreateString(curveType) : 0,
		curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropPositionY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_FRAME = 4,
		VT_VALUE = 6,
		VT_CURVETYPE = 8,
		VT_CURVEDATA = 10
	};
	float frame() const
	{
		return GetField<float>(VT_FRAME, 0.0f);
	}
	float value() const
	{
		return GetField<float>(VT_VALUE, 0.0f);
	}
	const flatbuffers::String* curveType() const
	{
		return GetPointer<const flatbuffers::String*>(VT_CURVETYPE);
	}
	const flatbuffers::Vector<float>* curveData() const
	{
		return GetPointer<const flatbuffers::Vector<float>*>(VT_CURVEDATA);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyField<float>(verifier, VT_FRAME) &&
			   VerifyField<float>(verifier, VT_VALUE) &&
			   VerifyOffset(verifier, VT_CURVETYPE) &&
			   verifier.VerifyString(curveType()) &&
			   VerifyOffset(verifier, VT_CURVEDATA) &&
			   verifier.VerifyVector(curveData()) &&
			   verifier.EndTable();
	}
};

struct AnimPropPositionYBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_frame(float frame)
	{
		fbb_.AddElement<float>(AnimPropPositionY::VT_FRAME, frame, 0.0f);
	}
	void add_value(float value)
	{
		fbb_.AddElement<float>(AnimPropPositionY::VT_VALUE, value, 0.0f);
	}
	void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType)
	{
		fbb_.AddOffset(AnimPropPositionY::VT_CURVETYPE, curveType);
	}
	void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData)
	{
		fbb_.AddOffset(AnimPropPositionY::VT_CURVEDATA, curveData);
	}
	explicit AnimPropPositionYBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	AnimPropPositionYBuilder& operator=(const AnimPropPositionYBuilder&);
	flatbuffers::Offset<AnimPropPositionY> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<AnimPropPositionY>(end);
		return o;
	}
};

inline flatbuffers::Offset<AnimPropPositionY> CreateAnimPropPositionY(
	flatbuffers::FlatBufferBuilder& _fbb,
	float frame = 0.0f,
	float value = 0.0f,
	flatbuffers::Offset<flatbuffers::String> curveType = 0,
	flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0)
{
	AnimPropPositionYBuilder builder_(_fbb);
	builder_.add_curveData(curveData);
	builder_.add_curveType(curveType);
	builder_.add_value(value);
	builder_.add_frame(frame);
	return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropPositionY> CreateAnimPropPositionYDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	float frame = 0.0f,
	float value = 0.0f,
	const char* curveType = nullptr,
	const std::vector<float>* curveData = nullptr)
{
	return creator::buffers::CreateAnimPropPositionY(
		_fbb,
		frame,
		value,
		curveType ? _fbb.CreateString(curveType) : 0,
		curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropScaleX FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_FRAME = 4,
		VT_VALUE = 6,
		VT_CURVETYPE = 8,
		VT_CURVEDATA = 10
	};
	float frame() const
	{
		return GetField<float>(VT_FRAME, 0.0f);
	}
	float value() const
	{
		return GetField<float>(VT_VALUE, 0.0f);
	}
	const flatbuffers::String* curveType() const
	{
		return GetPointer<const flatbuffers::String*>(VT_CURVETYPE);
	}
	const flatbuffers::Vector<float>* curveData() const
	{
		return GetPointer<const flatbuffers::Vector<float>*>(VT_CURVEDATA);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyField<float>(verifier, VT_FRAME) &&
			   VerifyField<float>(verifier, VT_VALUE) &&
			   VerifyOffset(verifier, VT_CURVETYPE) &&
			   verifier.VerifyString(curveType()) &&
			   VerifyOffset(verifier, VT_CURVEDATA) &&
			   verifier.VerifyVector(curveData()) &&
			   verifier.EndTable();
	}
};

struct AnimPropScaleXBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_frame(float frame)
	{
		fbb_.AddElement<float>(AnimPropScaleX::VT_FRAME, frame, 0.0f);
	}
	void add_value(float value)
	{
		fbb_.AddElement<float>(AnimPropScaleX::VT_VALUE, value, 0.0f);
	}
	void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType)
	{
		fbb_.AddOffset(AnimPropScaleX::VT_CURVETYPE, curveType);
	}
	void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData)
	{
		fbb_.AddOffset(AnimPropScaleX::VT_CURVEDATA, curveData);
	}
	explicit AnimPropScaleXBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	AnimPropScaleXBuilder& operator=(const AnimPropScaleXBuilder&);
	flatbuffers::Offset<AnimPropScaleX> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<AnimPropScaleX>(end);
		return o;
	}
};

inline flatbuffers::Offset<AnimPropScaleX> CreateAnimPropScaleX(
	flatbuffers::FlatBufferBuilder& _fbb,
	float frame = 0.0f,
	float value = 0.0f,
	flatbuffers::Offset<flatbuffers::String> curveType = 0,
	flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0)
{
	AnimPropScaleXBuilder builder_(_fbb);
	builder_.add_curveData(curveData);
	builder_.add_curveType(curveType);
	builder_.add_value(value);
	builder_.add_frame(frame);
	return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropScaleX> CreateAnimPropScaleXDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	float frame = 0.0f,
	float value = 0.0f,
	const char* curveType = nullptr,
	const std::vector<float>* curveData = nullptr)
{
	return creator::buffers::CreateAnimPropScaleX(
		_fbb,
		frame,
		value,
		curveType ? _fbb.CreateString(curveType) : 0,
		curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropScaleY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_FRAME = 4,
		VT_VALUE = 6,
		VT_CURVETYPE = 8,
		VT_CURVEDATA = 10
	};
	float frame() const
	{
		return GetField<float>(VT_FRAME, 0.0f);
	}
	float value() const
	{
		return GetField<float>(VT_VALUE, 0.0f);
	}
	const flatbuffers::String* curveType() const
	{
		return GetPointer<const flatbuffers::String*>(VT_CURVETYPE);
	}
	const flatbuffers::Vector<float>* curveData() const
	{
		return GetPointer<const flatbuffers::Vector<float>*>(VT_CURVEDATA);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyField<float>(verifier, VT_FRAME) &&
			   VerifyField<float>(verifier, VT_VALUE) &&
			   VerifyOffset(verifier, VT_CURVETYPE) &&
			   verifier.VerifyString(curveType()) &&
			   VerifyOffset(verifier, VT_CURVEDATA) &&
			   verifier.VerifyVector(curveData()) &&
			   verifier.EndTable();
	}
};

struct AnimPropScaleYBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_frame(float frame)
	{
		fbb_.AddElement<float>(AnimPropScaleY::VT_FRAME, frame, 0.0f);
	}
	void add_value(float value)
	{
		fbb_.AddElement<float>(AnimPropScaleY::VT_VALUE, value, 0.0f);
	}
	void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType)
	{
		fbb_.AddOffset(AnimPropScaleY::VT_CURVETYPE, curveType);
	}
	void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData)
	{
		fbb_.AddOffset(AnimPropScaleY::VT_CURVEDATA, curveData);
	}
	explicit AnimPropScaleYBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	AnimPropScaleYBuilder& operator=(const AnimPropScaleYBuilder&);
	flatbuffers::Offset<AnimPropScaleY> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<AnimPropScaleY>(end);
		return o;
	}
};

inline flatbuffers::Offset<AnimPropScaleY> CreateAnimPropScaleY(
	flatbuffers::FlatBufferBuilder& _fbb,
	float frame = 0.0f,
	float value = 0.0f,
	flatbuffers::Offset<flatbuffers::String> curveType = 0,
	flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0)
{
	AnimPropScaleYBuilder builder_(_fbb);
	builder_.add_curveData(curveData);
	builder_.add_curveType(curveType);
	builder_.add_value(value);
	builder_.add_frame(frame);
	return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropScaleY> CreateAnimPropScaleYDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	float frame = 0.0f,
	float value = 0.0f,
	const char* curveType = nullptr,
	const std::vector<float>* curveData = nullptr)
{
	return creator::buffers::CreateAnimPropScaleY(
		_fbb,
		frame,
		value,
		curveType ? _fbb.CreateString(curveType) : 0,
		curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropWidth FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_FRAME = 4,
		VT_VALUE = 6,
		VT_CURVETYPE = 8,
		VT_CURVEDATA = 10
	};
	float frame() const
	{
		return GetField<float>(VT_FRAME, 0.0f);
	}
	float value() const
	{
		return GetField<float>(VT_VALUE, 0.0f);
	}
	const flatbuffers::String* curveType() const
	{
		return GetPointer<const flatbuffers::String*>(VT_CURVETYPE);
	}
	const flatbuffers::Vector<float>* curveData() const
	{
		return GetPointer<const flatbuffers::Vector<float>*>(VT_CURVEDATA);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyField<float>(verifier, VT_FRAME) &&
			   VerifyField<float>(verifier, VT_VALUE) &&
			   VerifyOffset(verifier, VT_CURVETYPE) &&
			   verifier.VerifyString(curveType()) &&
			   VerifyOffset(verifier, VT_CURVEDATA) &&
			   verifier.VerifyVector(curveData()) &&
			   verifier.EndTable();
	}
};

struct AnimPropWidthBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_frame(float frame)
	{
		fbb_.AddElement<float>(AnimPropWidth::VT_FRAME, frame, 0.0f);
	}
	void add_value(float value)
	{
		fbb_.AddElement<float>(AnimPropWidth::VT_VALUE, value, 0.0f);
	}
	void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType)
	{
		fbb_.AddOffset(AnimPropWidth::VT_CURVETYPE, curveType);
	}
	void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData)
	{
		fbb_.AddOffset(AnimPropWidth::VT_CURVEDATA, curveData);
	}
	explicit AnimPropWidthBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	AnimPropWidthBuilder& operator=(const AnimPropWidthBuilder&);
	flatbuffers::Offset<AnimPropWidth> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<AnimPropWidth>(end);
		return o;
	}
};

inline flatbuffers::Offset<AnimPropWidth> CreateAnimPropWidth(
	flatbuffers::FlatBufferBuilder& _fbb,
	float frame = 0.0f,
	float value = 0.0f,
	flatbuffers::Offset<flatbuffers::String> curveType = 0,
	flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0)
{
	AnimPropWidthBuilder builder_(_fbb);
	builder_.add_curveData(curveData);
	builder_.add_curveType(curveType);
	builder_.add_value(value);
	builder_.add_frame(frame);
	return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropWidth> CreateAnimPropWidthDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	float frame = 0.0f,
	float value = 0.0f,
	const char* curveType = nullptr,
	const std::vector<float>* curveData = nullptr)
{
	return creator::buffers::CreateAnimPropWidth(
		_fbb,
		frame,
		value,
		curveType ? _fbb.CreateString(curveType) : 0,
		curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropHeight FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_FRAME = 4,
		VT_VALUE = 6,
		VT_CURVETYPE = 8,
		VT_CURVEDATA = 10
	};
	float frame() const
	{
		return GetField<float>(VT_FRAME, 0.0f);
	}
	float value() const
	{
		return GetField<float>(VT_VALUE, 0.0f);
	}
	const flatbuffers::String* curveType() const
	{
		return GetPointer<const flatbuffers::String*>(VT_CURVETYPE);
	}
	const flatbuffers::Vector<float>* curveData() const
	{
		return GetPointer<const flatbuffers::Vector<float>*>(VT_CURVEDATA);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyField<float>(verifier, VT_FRAME) &&
			   VerifyField<float>(verifier, VT_VALUE) &&
			   VerifyOffset(verifier, VT_CURVETYPE) &&
			   verifier.VerifyString(curveType()) &&
			   VerifyOffset(verifier, VT_CURVEDATA) &&
			   verifier.VerifyVector(curveData()) &&
			   verifier.EndTable();
	}
};

struct AnimPropHeightBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_frame(float frame)
	{
		fbb_.AddElement<float>(AnimPropHeight::VT_FRAME, frame, 0.0f);
	}
	void add_value(float value)
	{
		fbb_.AddElement<float>(AnimPropHeight::VT_VALUE, value, 0.0f);
	}
	void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType)
	{
		fbb_.AddOffset(AnimPropHeight::VT_CURVETYPE, curveType);
	}
	void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData)
	{
		fbb_.AddOffset(AnimPropHeight::VT_CURVEDATA, curveData);
	}
	explicit AnimPropHeightBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	AnimPropHeightBuilder& operator=(const AnimPropHeightBuilder&);
	flatbuffers::Offset<AnimPropHeight> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<AnimPropHeight>(end);
		return o;
	}
};

inline flatbuffers::Offset<AnimPropHeight> CreateAnimPropHeight(
	flatbuffers::FlatBufferBuilder& _fbb,
	float frame = 0.0f,
	float value = 0.0f,
	flatbuffers::Offset<flatbuffers::String> curveType = 0,
	flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0)
{
	AnimPropHeightBuilder builder_(_fbb);
	builder_.add_curveData(curveData);
	builder_.add_curveType(curveType);
	builder_.add_value(value);
	builder_.add_frame(frame);
	return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropHeight> CreateAnimPropHeightDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	float frame = 0.0f,
	float value = 0.0f,
	const char* curveType = nullptr,
	const std::vector<float>* curveData = nullptr)
{
	return creator::buffers::CreateAnimPropHeight(
		_fbb,
		frame,
		value,
		curveType ? _fbb.CreateString(curveType) : 0,
		curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropColor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_FRAME = 4,
		VT_VALUE = 6,
		VT_CURVETYPE = 8,
		VT_CURVEDATA = 10
	};
	float frame() const
	{
		return GetField<float>(VT_FRAME, 0.0f);
	}
	const ColorRGBA* value() const
	{
		return GetStruct<const ColorRGBA*>(VT_VALUE);
	}
	const flatbuffers::String* curveType() const
	{
		return GetPointer<const flatbuffers::String*>(VT_CURVETYPE);
	}
	const flatbuffers::Vector<float>* curveData() const
	{
		return GetPointer<const flatbuffers::Vector<float>*>(VT_CURVEDATA);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyField<float>(verifier, VT_FRAME) &&
			   VerifyField<ColorRGBA>(verifier, VT_VALUE) &&
			   VerifyOffset(verifier, VT_CURVETYPE) &&
			   verifier.VerifyString(curveType()) &&
			   VerifyOffset(verifier, VT_CURVEDATA) &&
			   verifier.VerifyVector(curveData()) &&
			   verifier.EndTable();
	}
};

struct AnimPropColorBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_frame(float frame)
	{
		fbb_.AddElement<float>(AnimPropColor::VT_FRAME, frame, 0.0f);
	}
	void add_value(const ColorRGBA* value)
	{
		fbb_.AddStruct(AnimPropColor::VT_VALUE, value);
	}
	void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType)
	{
		fbb_.AddOffset(AnimPropColor::VT_CURVETYPE, curveType);
	}
	void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData)
	{
		fbb_.AddOffset(AnimPropColor::VT_CURVEDATA, curveData);
	}
	explicit AnimPropColorBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	AnimPropColorBuilder& operator=(const AnimPropColorBuilder&);
	flatbuffers::Offset<AnimPropColor> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<AnimPropColor>(end);
		return o;
	}
};

inline flatbuffers::Offset<AnimPropColor> CreateAnimPropColor(
	flatbuffers::FlatBufferBuilder& _fbb,
	float frame = 0.0f,
	const ColorRGBA* value = 0,
	flatbuffers::Offset<flatbuffers::String> curveType = 0,
	flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0)
{
	AnimPropColorBuilder builder_(_fbb);
	builder_.add_curveData(curveData);
	builder_.add_curveType(curveType);
	builder_.add_value(value);
	builder_.add_frame(frame);
	return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropColor> CreateAnimPropColorDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	float frame = 0.0f,
	const ColorRGBA* value = 0,
	const char* curveType = nullptr,
	const std::vector<float>* curveData = nullptr)
{
	return creator::buffers::CreateAnimPropColor(
		_fbb,
		frame,
		value,
		curveType ? _fbb.CreateString(curveType) : 0,
		curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropOpacity FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_FRAME = 4,
		VT_VALUE = 6,
		VT_CURVETYPE = 8,
		VT_CURVEDATA = 10
	};
	float frame() const
	{
		return GetField<float>(VT_FRAME, 0.0f);
	}
	float value() const
	{
		return GetField<float>(VT_VALUE, 0.0f);
	}
	const flatbuffers::String* curveType() const
	{
		return GetPointer<const flatbuffers::String*>(VT_CURVETYPE);
	}
	const flatbuffers::Vector<float>* curveData() const
	{
		return GetPointer<const flatbuffers::Vector<float>*>(VT_CURVEDATA);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyField<float>(verifier, VT_FRAME) &&
			   VerifyField<float>(verifier, VT_VALUE) &&
			   VerifyOffset(verifier, VT_CURVETYPE) &&
			   verifier.VerifyString(curveType()) &&
			   VerifyOffset(verifier, VT_CURVEDATA) &&
			   verifier.VerifyVector(curveData()) &&
			   verifier.EndTable();
	}
};

struct AnimPropOpacityBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_frame(float frame)
	{
		fbb_.AddElement<float>(AnimPropOpacity::VT_FRAME, frame, 0.0f);
	}
	void add_value(float value)
	{
		fbb_.AddElement<float>(AnimPropOpacity::VT_VALUE, value, 0.0f);
	}
	void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType)
	{
		fbb_.AddOffset(AnimPropOpacity::VT_CURVETYPE, curveType);
	}
	void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData)
	{
		fbb_.AddOffset(AnimPropOpacity::VT_CURVEDATA, curveData);
	}
	explicit AnimPropOpacityBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	AnimPropOpacityBuilder& operator=(const AnimPropOpacityBuilder&);
	flatbuffers::Offset<AnimPropOpacity> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<AnimPropOpacity>(end);
		return o;
	}
};

inline flatbuffers::Offset<AnimPropOpacity> CreateAnimPropOpacity(
	flatbuffers::FlatBufferBuilder& _fbb,
	float frame = 0.0f,
	float value = 0.0f,
	flatbuffers::Offset<flatbuffers::String> curveType = 0,
	flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0)
{
	AnimPropOpacityBuilder builder_(_fbb);
	builder_.add_curveData(curveData);
	builder_.add_curveType(curveType);
	builder_.add_value(value);
	builder_.add_frame(frame);
	return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropOpacity> CreateAnimPropOpacityDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	float frame = 0.0f,
	float value = 0.0f,
	const char* curveType = nullptr,
	const std::vector<float>* curveData = nullptr)
{
	return creator::buffers::CreateAnimPropOpacity(
		_fbb,
		frame,
		value,
		curveType ? _fbb.CreateString(curveType) : 0,
		curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropAnchorX FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_FRAME = 4,
		VT_VALUE = 6,
		VT_CURVETYPE = 8,
		VT_CURVEDATA = 10
	};
	float frame() const
	{
		return GetField<float>(VT_FRAME, 0.0f);
	}
	float value() const
	{
		return GetField<float>(VT_VALUE, 0.0f);
	}
	const flatbuffers::String* curveType() const
	{
		return GetPointer<const flatbuffers::String*>(VT_CURVETYPE);
	}
	const flatbuffers::Vector<float>* curveData() const
	{
		return GetPointer<const flatbuffers::Vector<float>*>(VT_CURVEDATA);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyField<float>(verifier, VT_FRAME) &&
			   VerifyField<float>(verifier, VT_VALUE) &&
			   VerifyOffset(verifier, VT_CURVETYPE) &&
			   verifier.VerifyString(curveType()) &&
			   VerifyOffset(verifier, VT_CURVEDATA) &&
			   verifier.VerifyVector(curveData()) &&
			   verifier.EndTable();
	}
};

struct AnimPropAnchorXBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_frame(float frame)
	{
		fbb_.AddElement<float>(AnimPropAnchorX::VT_FRAME, frame, 0.0f);
	}
	void add_value(float value)
	{
		fbb_.AddElement<float>(AnimPropAnchorX::VT_VALUE, value, 0.0f);
	}
	void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType)
	{
		fbb_.AddOffset(AnimPropAnchorX::VT_CURVETYPE, curveType);
	}
	void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData)
	{
		fbb_.AddOffset(AnimPropAnchorX::VT_CURVEDATA, curveData);
	}
	explicit AnimPropAnchorXBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	AnimPropAnchorXBuilder& operator=(const AnimPropAnchorXBuilder&);
	flatbuffers::Offset<AnimPropAnchorX> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<AnimPropAnchorX>(end);
		return o;
	}
};

inline flatbuffers::Offset<AnimPropAnchorX> CreateAnimPropAnchorX(
	flatbuffers::FlatBufferBuilder& _fbb,
	float frame = 0.0f,
	float value = 0.0f,
	flatbuffers::Offset<flatbuffers::String> curveType = 0,
	flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0)
{
	AnimPropAnchorXBuilder builder_(_fbb);
	builder_.add_curveData(curveData);
	builder_.add_curveType(curveType);
	builder_.add_value(value);
	builder_.add_frame(frame);
	return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropAnchorX> CreateAnimPropAnchorXDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	float frame = 0.0f,
	float value = 0.0f,
	const char* curveType = nullptr,
	const std::vector<float>* curveData = nullptr)
{
	return creator::buffers::CreateAnimPropAnchorX(
		_fbb,
		frame,
		value,
		curveType ? _fbb.CreateString(curveType) : 0,
		curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropAnchorY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_FRAME = 4,
		VT_VALUE = 6,
		VT_CURVETYPE = 8,
		VT_CURVEDATA = 10
	};
	float frame() const
	{
		return GetField<float>(VT_FRAME, 0.0f);
	}
	float value() const
	{
		return GetField<float>(VT_VALUE, 0.0f);
	}
	const flatbuffers::String* curveType() const
	{
		return GetPointer<const flatbuffers::String*>(VT_CURVETYPE);
	}
	const flatbuffers::Vector<float>* curveData() const
	{
		return GetPointer<const flatbuffers::Vector<float>*>(VT_CURVEDATA);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyField<float>(verifier, VT_FRAME) &&
			   VerifyField<float>(verifier, VT_VALUE) &&
			   VerifyOffset(verifier, VT_CURVETYPE) &&
			   verifier.VerifyString(curveType()) &&
			   VerifyOffset(verifier, VT_CURVEDATA) &&
			   verifier.VerifyVector(curveData()) &&
			   verifier.EndTable();
	}
};

struct AnimPropAnchorYBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_frame(float frame)
	{
		fbb_.AddElement<float>(AnimPropAnchorY::VT_FRAME, frame, 0.0f);
	}
	void add_value(float value)
	{
		fbb_.AddElement<float>(AnimPropAnchorY::VT_VALUE, value, 0.0f);
	}
	void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType)
	{
		fbb_.AddOffset(AnimPropAnchorY::VT_CURVETYPE, curveType);
	}
	void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData)
	{
		fbb_.AddOffset(AnimPropAnchorY::VT_CURVEDATA, curveData);
	}
	explicit AnimPropAnchorYBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	AnimPropAnchorYBuilder& operator=(const AnimPropAnchorYBuilder&);
	flatbuffers::Offset<AnimPropAnchorY> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<AnimPropAnchorY>(end);
		return o;
	}
};

inline flatbuffers::Offset<AnimPropAnchorY> CreateAnimPropAnchorY(
	flatbuffers::FlatBufferBuilder& _fbb,
	float frame = 0.0f,
	float value = 0.0f,
	flatbuffers::Offset<flatbuffers::String> curveType = 0,
	flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0)
{
	AnimPropAnchorYBuilder builder_(_fbb);
	builder_.add_curveData(curveData);
	builder_.add_curveType(curveType);
	builder_.add_value(value);
	builder_.add_frame(frame);
	return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropAnchorY> CreateAnimPropAnchorYDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	float frame = 0.0f,
	float value = 0.0f,
	const char* curveType = nullptr,
	const std::vector<float>* curveData = nullptr)
{
	return creator::buffers::CreateAnimPropAnchorY(
		_fbb,
		frame,
		value,
		curveType ? _fbb.CreateString(curveType) : 0,
		curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropSkewX FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_FRAME = 4,
		VT_VALUE = 6,
		VT_CURVETYPE = 8,
		VT_CURVEDATA = 10
	};
	float frame() const
	{
		return GetField<float>(VT_FRAME, 0.0f);
	}
	float value() const
	{
		return GetField<float>(VT_VALUE, 0.0f);
	}
	const flatbuffers::String* curveType() const
	{
		return GetPointer<const flatbuffers::String*>(VT_CURVETYPE);
	}
	const flatbuffers::Vector<float>* curveData() const
	{
		return GetPointer<const flatbuffers::Vector<float>*>(VT_CURVEDATA);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyField<float>(verifier, VT_FRAME) &&
			   VerifyField<float>(verifier, VT_VALUE) &&
			   VerifyOffset(verifier, VT_CURVETYPE) &&
			   verifier.VerifyString(curveType()) &&
			   VerifyOffset(verifier, VT_CURVEDATA) &&
			   verifier.VerifyVector(curveData()) &&
			   verifier.EndTable();
	}
};

struct AnimPropSkewXBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_frame(float frame)
	{
		fbb_.AddElement<float>(AnimPropSkewX::VT_FRAME, frame, 0.0f);
	}
	void add_value(float value)
	{
		fbb_.AddElement<float>(AnimPropSkewX::VT_VALUE, value, 0.0f);
	}
	void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType)
	{
		fbb_.AddOffset(AnimPropSkewX::VT_CURVETYPE, curveType);
	}
	void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData)
	{
		fbb_.AddOffset(AnimPropSkewX::VT_CURVEDATA, curveData);
	}
	explicit AnimPropSkewXBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	AnimPropSkewXBuilder& operator=(const AnimPropSkewXBuilder&);
	flatbuffers::Offset<AnimPropSkewX> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<AnimPropSkewX>(end);
		return o;
	}
};

inline flatbuffers::Offset<AnimPropSkewX> CreateAnimPropSkewX(
	flatbuffers::FlatBufferBuilder& _fbb,
	float frame = 0.0f,
	float value = 0.0f,
	flatbuffers::Offset<flatbuffers::String> curveType = 0,
	flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0)
{
	AnimPropSkewXBuilder builder_(_fbb);
	builder_.add_curveData(curveData);
	builder_.add_curveType(curveType);
	builder_.add_value(value);
	builder_.add_frame(frame);
	return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropSkewX> CreateAnimPropSkewXDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	float frame = 0.0f,
	float value = 0.0f,
	const char* curveType = nullptr,
	const std::vector<float>* curveData = nullptr)
{
	return creator::buffers::CreateAnimPropSkewX(
		_fbb,
		frame,
		value,
		curveType ? _fbb.CreateString(curveType) : 0,
		curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropSkewY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_FRAME = 4,
		VT_VALUE = 6,
		VT_CURVETYPE = 8,
		VT_CURVEDATA = 10
	};
	float frame() const
	{
		return GetField<float>(VT_FRAME, 0.0f);
	}
	float value() const
	{
		return GetField<float>(VT_VALUE, 0.0f);
	}
	const flatbuffers::String* curveType() const
	{
		return GetPointer<const flatbuffers::String*>(VT_CURVETYPE);
	}
	const flatbuffers::Vector<float>* curveData() const
	{
		return GetPointer<const flatbuffers::Vector<float>*>(VT_CURVEDATA);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyField<float>(verifier, VT_FRAME) &&
			   VerifyField<float>(verifier, VT_VALUE) &&
			   VerifyOffset(verifier, VT_CURVETYPE) &&
			   verifier.VerifyString(curveType()) &&
			   VerifyOffset(verifier, VT_CURVEDATA) &&
			   verifier.VerifyVector(curveData()) &&
			   verifier.EndTable();
	}
};

struct AnimPropSkewYBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_frame(float frame)
	{
		fbb_.AddElement<float>(AnimPropSkewY::VT_FRAME, frame, 0.0f);
	}
	void add_value(float value)
	{
		fbb_.AddElement<float>(AnimPropSkewY::VT_VALUE, value, 0.0f);
	}
	void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType)
	{
		fbb_.AddOffset(AnimPropSkewY::VT_CURVETYPE, curveType);
	}
	void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData)
	{
		fbb_.AddOffset(AnimPropSkewY::VT_CURVEDATA, curveData);
	}
	explicit AnimPropSkewYBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	AnimPropSkewYBuilder& operator=(const AnimPropSkewYBuilder&);
	flatbuffers::Offset<AnimPropSkewY> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<AnimPropSkewY>(end);
		return o;
	}
};

inline flatbuffers::Offset<AnimPropSkewY> CreateAnimPropSkewY(
	flatbuffers::FlatBufferBuilder& _fbb,
	float frame = 0.0f,
	float value = 0.0f,
	flatbuffers::Offset<flatbuffers::String> curveType = 0,
	flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0)
{
	AnimPropSkewYBuilder builder_(_fbb);
	builder_.add_curveData(curveData);
	builder_.add_curveType(curveType);
	builder_.add_value(value);
	builder_.add_frame(frame);
	return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropSkewY> CreateAnimPropSkewYDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	float frame = 0.0f,
	float value = 0.0f,
	const char* curveType = nullptr,
	const std::vector<float>* curveData = nullptr)
{
	return creator::buffers::CreateAnimPropSkewY(
		_fbb,
		frame,
		value,
		curveType ? _fbb.CreateString(curveType) : 0,
		curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropSpriteFrame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_FRAME = 4,
		VT_VALUE = 6,
		VT_CURVETYPE = 8,
		VT_CURVEDATA = 10
	};
	float frame() const
	{
		return GetField<float>(VT_FRAME, 0.0f);
	}
	const flatbuffers::String* value() const
	{
		return GetPointer<const flatbuffers::String*>(VT_VALUE);
	}
	const flatbuffers::String* curveType() const
	{
		return GetPointer<const flatbuffers::String*>(VT_CURVETYPE);
	}
	const flatbuffers::Vector<float>* curveData() const
	{
		return GetPointer<const flatbuffers::Vector<float>*>(VT_CURVEDATA);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyField<float>(verifier, VT_FRAME) &&
			   VerifyOffset(verifier, VT_VALUE) &&
			   verifier.VerifyString(value()) &&
			   VerifyOffset(verifier, VT_CURVETYPE) &&
			   verifier.VerifyString(curveType()) &&
			   VerifyOffset(verifier, VT_CURVEDATA) &&
			   verifier.VerifyVector(curveData()) &&
			   verifier.EndTable();
	}
};

struct AnimPropSpriteFrameBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_frame(float frame)
	{
		fbb_.AddElement<float>(AnimPropSpriteFrame::VT_FRAME, frame, 0.0f);
	}
	void add_value(flatbuffers::Offset<flatbuffers::String> value)
	{
		fbb_.AddOffset(AnimPropSpriteFrame::VT_VALUE, value);
	}
	void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType)
	{
		fbb_.AddOffset(AnimPropSpriteFrame::VT_CURVETYPE, curveType);
	}
	void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData)
	{
		fbb_.AddOffset(AnimPropSpriteFrame::VT_CURVEDATA, curveData);
	}
	explicit AnimPropSpriteFrameBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	AnimPropSpriteFrameBuilder& operator=(const AnimPropSpriteFrameBuilder&);
	flatbuffers::Offset<AnimPropSpriteFrame> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<AnimPropSpriteFrame>(end);
		return o;
	}
};

inline flatbuffers::Offset<AnimPropSpriteFrame> CreateAnimPropSpriteFrame(
	flatbuffers::FlatBufferBuilder& _fbb,
	float frame = 0.0f,
	flatbuffers::Offset<flatbuffers::String> value = 0,
	flatbuffers::Offset<flatbuffers::String> curveType = 0,
	flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0)
{
	AnimPropSpriteFrameBuilder builder_(_fbb);
	builder_.add_curveData(curveData);
	builder_.add_curveType(curveType);
	builder_.add_value(value);
	builder_.add_frame(frame);
	return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropSpriteFrame> CreateAnimPropSpriteFrameDirect(
	flatbuffers::FlatBufferBuilder& _fbb,
	float frame = 0.0f,
	const char* value = nullptr,
	const char* curveType = nullptr,
	const std::vector<float>* curveData = nullptr)
{
	return creator::buffers::CreateAnimPropSpriteFrame(
		_fbb,
		frame,
		value ? _fbb.CreateString(value) : 0,
		curveType ? _fbb.CreateString(curveType) : 0,
		curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct LabelOutline FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_COLOR = 4,
		VT_WIDTH = 6
	};
	const ColorRGBA* color() const
	{
		return GetStruct<const ColorRGBA*>(VT_COLOR);
	}
	float width() const
	{
		return GetField<float>(VT_WIDTH, 0.0f);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyField<ColorRGBA>(verifier, VT_COLOR) &&
			   VerifyField<float>(verifier, VT_WIDTH) &&
			   verifier.EndTable();
	}
};

struct LabelOutlineBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_color(const ColorRGBA* color)
	{
		fbb_.AddStruct(LabelOutline::VT_COLOR, color);
	}
	void add_width(float width)
	{
		fbb_.AddElement<float>(LabelOutline::VT_WIDTH, width, 0.0f);
	}
	explicit LabelOutlineBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	LabelOutlineBuilder& operator=(const LabelOutlineBuilder&);
	flatbuffers::Offset<LabelOutline> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<LabelOutline>(end);
		return o;
	}
};

inline flatbuffers::Offset<LabelOutline> CreateLabelOutline(
	flatbuffers::FlatBufferBuilder& _fbb,
	const ColorRGBA* color = 0,
	float width = 0.0f)
{
	LabelOutlineBuilder builder_(_fbb);
	builder_.add_width(width);
	builder_.add_color(color);
	return builder_.Finish();
}

struct LabelShadow FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	enum
	{
		VT_COLOR = 4,
		VT_BLURRADIUS = 6,
		VT_OFFSET = 8
	};
	const ColorRGBA* color() const
	{
		return GetStruct<const ColorRGBA*>(VT_COLOR);
	}
	float blurRadius() const
	{
		return GetField<float>(VT_BLURRADIUS, 0.0f);
	}
	const Vec2* offset() const
	{
		return GetStruct<const Vec2*>(VT_OFFSET);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) &&
			   VerifyField<ColorRGBA>(verifier, VT_COLOR) &&
			   VerifyField<float>(verifier, VT_BLURRADIUS) &&
			   VerifyField<Vec2>(verifier, VT_OFFSET) &&
			   verifier.EndTable();
	}
};

struct LabelShadowBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t start_;
	void add_color(const ColorRGBA* color)
	{
		fbb_.AddStruct(LabelShadow::VT_COLOR, color);
	}
	void add_blurRadius(float blurRadius)
	{
		fbb_.AddElement<float>(LabelShadow::VT_BLURRADIUS, blurRadius, 0.0f);
	}
	void add_offset(const Vec2* offset)
	{
		fbb_.AddStruct(LabelShadow::VT_OFFSET, offset);
	}
	explicit LabelShadowBuilder(flatbuffers::FlatBufferBuilder& _fbb) :
		fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	LabelShadowBuilder& operator=(const LabelShadowBuilder&);
	flatbuffers::Offset<LabelShadow> Finish()
	{
		const auto end = fbb_.EndTable(start_);
		auto o = flatbuffers::Offset<LabelShadow>(end);
		return o;
	}
};

inline flatbuffers::Offset<LabelShadow> CreateLabelShadow(
	flatbuffers::FlatBufferBuilder& _fbb,
	const ColorRGBA* color = 0,
	float blurRadius = 0.0f,
	const Vec2* offset = 0)
{
	LabelShadowBuilder builder_(_fbb);
	builder_.add_offset(offset);
	builder_.add_blurRadius(blurRadius);
	builder_.add_color(color);
	return builder_.Finish();
}

inline bool VerifyAnyNode(flatbuffers::Verifier& verifier, const void* obj, AnyNode type)
{
	switch (type)
	{
	case AnyNode_NONE: {
		return true;
	}
	case AnyNode_Scene: {
		auto ptr = reinterpret_cast<const Scene*>(obj);
		return verifier.VerifyTable(ptr);
	}
	case AnyNode_Sprite: {
		auto ptr = reinterpret_cast<const Sprite*>(obj);
		return verifier.VerifyTable(ptr);
	}
	case AnyNode_Label: {
		auto ptr = reinterpret_cast<const Label*>(obj);
		return verifier.VerifyTable(ptr);
	}
	case AnyNode_Particle: {
		auto ptr = reinterpret_cast<const Particle*>(obj);
		return verifier.VerifyTable(ptr);
	}
	case AnyNode_TileMap: {
		auto ptr = reinterpret_cast<const TileMap*>(obj);
		return verifier.VerifyTable(ptr);
	}
	case AnyNode_Node: {
		auto ptr = reinterpret_cast<const Node*>(obj);
		return verifier.VerifyTable(ptr);
	}
	case AnyNode_Button: {
		auto ptr = reinterpret_cast<const Button*>(obj);
		return verifier.VerifyTable(ptr);
	}
	case AnyNode_ProgressBar: {
		auto ptr = reinterpret_cast<const ProgressBar*>(obj);
		return verifier.VerifyTable(ptr);
	}
	case AnyNode_ScrollView: {
		auto ptr = reinterpret_cast<const ScrollView*>(obj);
		return verifier.VerifyTable(ptr);
	}
	case AnyNode_CreatorScene: {
		auto ptr = reinterpret_cast<const CreatorScene*>(obj);
		return verifier.VerifyTable(ptr);
	}
	case AnyNode_EditBox: {
		auto ptr = reinterpret_cast<const EditBox*>(obj);
		return verifier.VerifyTable(ptr);
	}
	case AnyNode_RichText: {
		auto ptr = reinterpret_cast<const RichText*>(obj);
		return verifier.VerifyTable(ptr);
	}
	case AnyNode_SpineSkeleton: {
		auto ptr = reinterpret_cast<const SpineSkeleton*>(obj);
		return verifier.VerifyTable(ptr);
	}
	case AnyNode_VideoPlayer: {
		auto ptr = reinterpret_cast<const VideoPlayer*>(obj);
		return verifier.VerifyTable(ptr);
	}
	case AnyNode_WebView: {
		auto ptr = reinterpret_cast<const WebView*>(obj);
		return verifier.VerifyTable(ptr);
	}
	case AnyNode_Slider: {
		auto ptr = reinterpret_cast<const Slider*>(obj);
		return verifier.VerifyTable(ptr);
	}
	case AnyNode_Toggle: {
		auto ptr = reinterpret_cast<const Toggle*>(obj);
		return verifier.VerifyTable(ptr);
	}
	case AnyNode_ToggleGroup: {
		auto ptr = reinterpret_cast<const ToggleGroup*>(obj);
		return verifier.VerifyTable(ptr);
	}
	case AnyNode_PageView: {
		auto ptr = reinterpret_cast<const PageView*>(obj);
		return verifier.VerifyTable(ptr);
	}
	case AnyNode_Mask: {
		auto ptr = reinterpret_cast<const Mask*>(obj);
		return verifier.VerifyTable(ptr);
	}
	case AnyNode_DragonBones: {
		auto ptr = reinterpret_cast<const DragonBones*>(obj);
		return verifier.VerifyTable(ptr);
	}
	case AnyNode_MotionStreak: {
		auto ptr = reinterpret_cast<const MotionStreak*>(obj);
		return verifier.VerifyTable(ptr);
	}
	case AnyNode_Prefab: {
		auto ptr = reinterpret_cast<const Prefab*>(obj);
		return verifier.VerifyTable(ptr);
	}
	case AnyNode_Layout: {
		auto ptr = reinterpret_cast<const Layout*>(obj);
		return verifier.VerifyTable(ptr);
	}
	default: return false;
	}
}

inline bool VerifyAnyNodeVector(flatbuffers::Verifier& verifier, const flatbuffers::Vector<flatbuffers::Offset<void>>* values, const flatbuffers::Vector<uint8_t>* types)
{
	if (!values || !types)
		return !values && !types;
	if (values->size() != types->size())
		return false;
	for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i)
	{
		if (!VerifyAnyNode(
				verifier, values->Get(i), types->GetEnum<AnyNode>(i)))
		{
			return false;
		}
	}
	return true;
}

inline const creator::buffers::NodeGraph* GetNodeGraph(const void* buf)
{
	return flatbuffers::GetRoot<creator::buffers::NodeGraph>(buf);
}

inline const creator::buffers::NodeGraph* GetSizePrefixedNodeGraph(const void* buf)
{
	return flatbuffers::GetSizePrefixedRoot<creator::buffers::NodeGraph>(buf);
}

inline const char* NodeGraphIdentifier()
{
	return "CCRE";
}

inline bool NodeGraphBufferHasIdentifier(const void* buf)
{
	return flatbuffers::BufferHasIdentifier(
		buf, NodeGraphIdentifier());
}

inline bool VerifyNodeGraphBuffer(
	flatbuffers::Verifier& verifier)
{
	return verifier.VerifyBuffer<creator::buffers::NodeGraph>(NodeGraphIdentifier());
}

inline bool VerifySizePrefixedNodeGraphBuffer(
	flatbuffers::Verifier& verifier)
{
	return verifier.VerifySizePrefixedBuffer<creator::buffers::NodeGraph>(NodeGraphIdentifier());
}

inline const char* NodeGraphExtension()
{
	return "ccreator";
}

inline void FinishNodeGraphBuffer(
	flatbuffers::FlatBufferBuilder& fbb,
	flatbuffers::Offset<creator::buffers::NodeGraph> root)
{
	fbb.Finish(root, NodeGraphIdentifier());
}

inline void FinishSizePrefixedNodeGraphBuffer(
	flatbuffers::FlatBufferBuilder& fbb,
	flatbuffers::Offset<creator::buffers::NodeGraph> root)
{
	fbb.FinishSizePrefixed(root, NodeGraphIdentifier());
}

} // namespace buffers
} // namespace creator

#endif // FLATBUFFERS_GENERATED_CREATORREADER_CREATOR_BUFFERS_H_
